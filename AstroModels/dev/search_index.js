var documenterSearchIndex = {"docs":
[{"location":"spacecraft_cad_model/#CAD-Model","page":"CAD Model","title":"CAD Model","text":"The cad_model field provides 3D visualization support for spacecraft by linking to external CAD model files.","category":"section"},{"location":"spacecraft_cad_model/#Basic-Usage","page":"CAD Model","title":"Basic Usage","text":"using AstroModels\n\n# Add a 3D model to spacecraft\nsc = Spacecraft(\n    cad_model = CADModel(\n        file_path = \"path/to/spacecraft.obj\",\n        scale = 100.0,\n        visible = true\n    )\n)\n\nSee CADModel documentation for field details and default values.\n\nThe cad_model field stores only the file path and display settings. The visualization package (e.g., Epicycle) must support the referenced file format. See Epicycle documentation for supported formats and visualization details.","category":"section"},{"location":"spacecraft_cad_model/#Best-Practices","page":"CAD Model","title":"Best Practices","text":"","category":"section"},{"location":"spacecraft_cad_model/#File-Paths","page":"CAD Model","title":"File Paths","text":"Use relative paths from your project directory:\n\n# Good - relative path\ncad_model = CADModel(file_path = \"models/satellite.obj\")\n\n# Avoid - absolute paths are not portable\ncad_model = CADModel(file_path = \"C:/Users/Me/models/satellite.obj\")","category":"section"},{"location":"spacecraft_cad_model/#See-Also","page":"CAD Model","title":"See Also","text":"Spacecraft Overview - Main spacecraft documentation\nReference - Complete API documentation","category":"section"},{"location":"history/#Spacecraft-History","page":"History","title":"Spacecraft History","text":"Trajectory history is automatically recorded during spacecraft propagation and organized into segments. This guide covers the history data structures and how to access trajectory data. \n\nSpacecraftHistory stores the time-ordered position and velocity data generated during propagation. History is organized into segments - continuous chunks of trajectory separated by discontinuities (e.g., maneuvers) or mission phases.","category":"section"},{"location":"history/#Data-Structures","page":"History","title":"Data Structures","text":"","category":"section"},{"location":"history/#SpacecraftHistory","page":"History","title":"SpacecraftHistory","text":"Container for all trajectory segments:\n\nmutable struct SpacecraftHistory\n    segments::Vector{HistorySegment}      # Solution trajectory\n    iterations::Vector{HistorySegment}    # Solver iterations (diagnostic)\n    record_segments::Bool                  # Enable solution recording\n    record_iterations::Bool                # Enable iteration recording\nend\n\nTwo types of segments:\n\nsegments: Final solution trajectory (mission data)\niterations: Solver convergence iterations (diagnostic data)","category":"section"},{"location":"history/#HistorySegment","page":"History","title":"HistorySegment","text":"A continuous segment of trajectory data:\n\nstruct HistorySegment\n    times::Vector{Time{Float64}}              # Time points\n    states::Vector{CartesianState{Float64}}   # Position/velocity states\n    coordinate_system::CoordinateSystem        # Reference frame\n    name::String                               # Segment identifier\n    metadata::Dict{String, Any}                # Extensible metadata\nend\n\nKey points:\n\nStates always stored as Float64 (automatic conversion from AD types)\nParallel times and states vectors\nCoordinate system applies to entire segment\nOptional name for identification","category":"section"},{"location":"history/#Accessing-History-Data","page":"History","title":"Accessing History Data","text":"Spacecraft history is automatically populated during propagation and maneuvers. The examples below use a spacecraft sat with populated history created by this setup:\n\nnote: Full Epicycle Ecosystem Required\nThe setup below requires AstroProp and AstroManeuvers. The data access examples below work with any populated SpacecraftHistory.\n\nusing Epicycle\nusing LinearAlgebra\n    \n# Create spacecraft\nsat = Spacecraft()\n\n# Setup propagator\ngravity = PointMassGravity(earth, ())  # Only Earth gravity\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(DP8(); abstol=1e-12, reltol=1e-12, dt=60.0)\nprop    = OrbitPropagator(forces, integ)\n\n# Setup maneuver\ntoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 2.518,\n)\n\n# Propagate and maneuver - this populates history\npropagate(prop, sat, StopAt(sat, PropDurationDays(), 0.5))\nmaneuver(sat, toi)\npropagate(prop, sat, StopAt(sat, PropDurationDays(), 0.5))\n\n# sat.history now contains 3 segments","category":"section"},{"location":"history/#Basic-Access","page":"History","title":"Basic Access","text":"# Access segments\nhistory = sat.history\nsegments = history.segments\n\n# Number of segments\nn = length(history)\n\n# Check if empty\nis_empty = isempty(history)\n\n# Get specific segment\nsegment = history[1]              # First segment\nsegment = history.segments[2]     # Second segment","category":"section"},{"location":"history/#Iteration","page":"History","title":"Iteration","text":"# Iterate over all segments\nfor segment in sat.history\n    println(\"Segment: $(segment.name)\")\n    println(\"  Points: $(length(segment.times))\")\nend","category":"section"},{"location":"history/#Segment-Data","page":"History","title":"Segment Data","text":"segment = history.segments[1]\n\n# Access times and states\ntimes = segment.times                    # Vector{Time{Float64}}\nstates = segment.states                  # Vector{CartesianState{Float64}}\n\n# Get coordinate system\ncoord_sys = segment.coordinate_system\n\n# Get name and metadata\nname = segment.name\nmetadata = segment.metadata","category":"section"},{"location":"history/#Extracting-Position/Velocity","page":"History","title":"Extracting Position/Velocity","text":"# Loop over states in a segment\nfor (t, state) in zip(segment.times, segment.states)\n    x, y, z = state.position\n    vx, vy, vz = state.velocity\n    # Process data...\nend","category":"section"},{"location":"history/#Solution-vs-Iterations","page":"History","title":"Solution vs Iterations","text":"","category":"section"},{"location":"history/#Solution-Trajectory-(segments)","page":"History","title":"Solution Trajectory (segments)","text":"The segments field contains the final mission trajectory:\n\n# Final trajectory after propagation or optimization\nfor segment in sat.history.segments\n    # This is the actual mission trajectory\nend\n\nThis is what you use for:\n\nVisualization (plotting orbits)\nEphemeris generation\nMission analysis\nReports","category":"section"},{"location":"history/#Solver-Iterations-(iterations)","page":"History","title":"Solver Iterations (iterations)","text":"The iterations field contains diagnostic data from trajectory optimization:\n\n# Check if iterations were recorded\nif !isempty(sat.history.iterations)\n    println(\"Solver iterations: \", length(sat.history.iterations))\n    \n    # Analyze convergence\n    for iteration in sat.history.iterations\n        # Each iteration is a full trajectory attempt\n    end\nend\n\nIterations are opt-in and used for:\n\nDebugging convergence problems\nVisualizing optimization process\nPerformance analysis\n\nSee AstroSolve documentation for trajectory_solve(...; record_iterations=true).","category":"section"},{"location":"history/#Recording-Control","page":"History","title":"Recording Control","text":"History recording is controlled by flags:\n\nhistory = sat.history\n\n# Check recording status\nhistory.record_segments      # true = recording solution\nhistory.record_iterations    # true = recording iterations\n\n# Flags are typically managed by solver\n# Users rarely need to modify these directly\n\nDefault behavior:\n\nrecord_segments = true: Solution trajectory is recorded\nrecord_iterations = false: Iterations not recorded (saves memory)","category":"section"},{"location":"history/#Common-Patterns","page":"History","title":"Common Patterns","text":"","category":"section"},{"location":"history/#Check-for-Data","page":"History","title":"Check for Data","text":"# Check if spacecraft has history\nif !isempty(sat.history)\n    println(\"History contains $(length(sat.history)) segments\")\nelse\n    println(\"No history recorded\")\nend","category":"section"},{"location":"history/#Multi-Segment-Missions","page":"History","title":"Multi-Segment Missions","text":"# After multi-phase mission\npropagate(prop, sat, StopAt(sat, PropDurationDays(), 0.5))\nmaneuver(sat, toi)\npropagate(prop, sat, StopAt(sat, PropDurationDays(), 0.5))\n\n# Inspect phases\nfor (i, segment) in enumerate(sat.history)\n    println(\"Segment $i: $(segment.name)\")\n    t_start = segment.times[1]\n    t_end = segment.times[end]\n    println(\"  Duration: $(t_end - t_start)\")\nend","category":"section"},{"location":"history/#Coordinate-System-Awareness","page":"History","title":"Coordinate System Awareness","text":"# Segments may have different coordinate systems\nfor segment in sat.history\n    origin = segment.coordinate_system.origin\n    axes = segment.coordinate_system.axes\n    println(\"Frame: $(origin.name) $(typeof(axes))\")\nend","category":"section"},{"location":"history/#Integration-with-Other-Modules","page":"History","title":"Integration with Other Modules","text":"","category":"section"},{"location":"history/#Automatic-Recording","page":"History","title":"Automatic Recording","text":"History is populated automatically:\n\nAstroProp: Creates new segment when propagate() is called\n\npropagate(prop, sat, StopAt(sat, PropDurationDays(), 0.5))\n# sat.history now contains propagation data\n\nAstroManeuvers: Creates new segment at maneuver application\n\nmaneuver(sat, toi)\n# New segment created for post-maneuver trajectory\n\nSee respective module documentation for details on how they interact with history.","category":"section"},{"location":"history/#Visualization","page":"History","title":"Visualization","text":"View3D (in Epicycle module) automatically renders all segments:\n\nusing Epicycle\n\nview = View3D()\nadd_spacecraft!(view, sat)  # Renders entire history\ndisplay_view(view)\n\nEach segment can be rendered with different colors for multi-phase missions.","category":"section"},{"location":"history/#See-Also","page":"History","title":"See Also","text":"Spacecraft Guide - Spacecraft construction and fields\nAstroProp Documentation - Orbit propagation\nAstroSolve Documentation - Trajectory optimization\nReference - Complete API documentation","category":"section"},{"location":"spacecraft_coord_sys/#Coordinate-System","page":"Coordinate System","title":"Coordinate System","text":"The coord_sys field specifies the coordinate system (origin body and axes) for the spacecraft's state.","category":"section"},{"location":"spacecraft_coord_sys/#Basic-Usage","page":"Coordinate System","title":"Basic Usage","text":"using AstroFrames, AstroUniverse\n\n# Earth-centered inertial (default)\nsc = Spacecraft(\n    coord_sys = CoordinateSystem(earth, ICRFAxes())\n)\n\n# Mars-centered inertial\nsc = Spacecraft(\n    coord_sys = CoordinateSystem(mars, ICRFAxes())\n)\n\n# Moon-centered inertial\nsc = Spacecraft(\n    coord_sys = CoordinateSystem(moon, ICRFAxes())\n)","category":"section"},{"location":"spacecraft_coord_sys/#Accessing-Coordinate-System","page":"Coordinate System","title":"Accessing Coordinate System","text":"# Get origin body\norigin = sc.coord_sys.origin  # CelestialBody\n\n# Get axes type\naxes = sc.coord_sys.axes  # AbstractAxes","category":"section"},{"location":"spacecraft/#Spacecraft-Overview","page":"Overview","title":"Spacecraft Overview","text":"The Spacecraft type represents a spacecraft with orbital state, time, physical properties, and trajectory history.","category":"section"},{"location":"spacecraft/#Spacecraft-Fields","page":"Overview","title":"Spacecraft Fields","text":"state::OrbitState — Orbital state (position and velocity) - see State\ntime::Time — Epoch - see Time\nmass::T — Total mass (kg) - see Mass\ncoord_sys::CoordinateSystem — Coordinate system (origin and axes) - see Coordinate System\nhistory::SpacecraftHistory — Trajectory history - see History\nname::String — User label\ncad_model::CADModel — 3D model for visualization - see CAD Model","category":"section"},{"location":"spacecraft/#Basic-Construction","page":"Overview","title":"Basic Construction","text":"using AstroModels, AstroStates, AstroEpochs\n\n# Create spacecraft with all key properties\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    mass = 1000.0,\n    coord_sys = CoordinateSystem(earth, ICRFAxes()),\n    name = \"MySat\"\n)\n\nSee the Spacecraft constructor documentation for default values and additional options.","category":"section"},{"location":"spacecraft/#Type-Promotion","page":"Overview","title":"Type Promotion","text":"Spacecraft automatically promotes numeric types for automatic differentiation:\n\nusing ForwardDiff\n\n# Mass with dual number\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    mass = ForwardDiff.Dual(1000.0, 1.0)\n)\n\n# All numeric fields promote to Dual\nsc.state  # OrbitState with Dual elements\nsc.mass   # Dual number\nsc.time   # Time with Dual jd1, jd2\n\nThe numeric type T is determined by: T = promote_type(eltype(state), typeof(time.jd1), typeof(mass))","category":"section"},{"location":"spacecraft/#Deep-Copy","page":"Overview","title":"Deep Copy","text":"sc_copy = deepcopy(sc)\n# All mutable fields (state, time, history) are independently copied","category":"section"},{"location":"reference/#API-Reference","page":"Reference","title":"API Reference","text":"Complete API documentation for AstroModels.","category":"section"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/#AstroModels.AstroModels","page":"Reference","title":"AstroModels.AstroModels","text":"Module containing physical models such as spacecraft. \n\n\n\n\n\n","category":"module"},{"location":"reference/#AstroModels.CADModel","page":"Reference","title":"AstroModels.CADModel","text":"CADModel(; file_path=\"\", scale=1.0, visible=false)\n\nRepresents a 3D CAD model for visualization of spacecraft or other objects.\n\nKeyword Arguments\n\nfile_path::String = \"\" — Path to CAD model file (empty string means no model). If visible=true, must not be empty.\nscale::Float64 = 1.0 — Scaling factor for the model. Must be positive (> 0.0).\nvisible::Bool = false — Whether the model should be displayed (default hidden until model is set)\n\nExamples\n\nmodel = CADModel(file_path=\"data/SpacecraftCADModel.obj\", scale=10.0, visible=true)\n\n\n\n\n\n","category":"type"},{"location":"reference/#AstroModels.CADModel-Tuple{}","page":"Reference","title":"AstroModels.CADModel","text":"CADModel(; file_path=\"\", scale=1.0, visible=false)\n\nKwarg constructor with defaults for all fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.HistorySegment","page":"Reference","title":"AstroModels.HistorySegment","text":"HistorySegment\n\nRepresents a continuous segment of spacecraft trajectory history.\n\nA history segment stores time-ordered state data for a portion of a spacecraft's  trajectory. Segments are used to delineate discontinuities (e.g., maneuvers) and  to organize mission events (e.g., propagation phases).\n\nFields\n\ntimes::Vector{Time}: Ordered vector of time points\nstates::Vector{CartesianState{Float64}}: Corresponding state vectors (always Float64)\ncoordinate_system::CoordinateSystem: Reference frame for this segment\nname::String: Optional segment identifier (empty string if unnamed)\nmetadata::Dict{String,Any}: Extensible metadata storage for custom attributes\n\nNotes\n\nStates are always stored as Float64 regardless of input type (e.g., Dual numbers)\nImmutable struct, but internal vectors can be mutated for efficiency\ntimes and states are parallel vectors of equal length\n\nExamples\n\nusing AstroModels, AstroUniverse, AstroEpochs, AstroFrames, AstroStates\n\n# Create empty segment\ncoord_sys = CoordinateSystem(earth, ICRFAxes())\nsegment = HistorySegment(coord_sys, name=\"initial_orbit\")\n\n# Create segment from existing data\ntimes = [Time(\"2024-01-01T00:00:00\", TAI(), ISOT()), \n         Time(\"2024-01-01T01:00:00\", TAI(), ISOT())]\nstates = [CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]),\n          CartesianState([7100.0, 100.0, 0.0, 0.0, 7.4, 0.1])]\nsegment = HistorySegment(times, states, coord_sys, name=\"propagation_1\")\n\n\n\n\n\n","category":"type"},{"location":"reference/#AstroModels.HistorySegment-Tuple{CoordinateSystem}","page":"Reference","title":"AstroModels.HistorySegment","text":"HistorySegment(coord_system::CoordinateSystem; \n               name::String=\"\", \n               metadata::Dict{String,Any}=Dict{String,Any}())\n\nCreate an empty history segment with specified coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.HistorySegment-Union{Tuple{S}, Tuple{T}, Tuple{Vector{T}, Vector{S}, CoordinateSystem}} where {T<:Time, S<:CartesianState}","page":"Reference","title":"AstroModels.HistorySegment","text":"HistorySegment(times::Vector{<:Time}, \n               states::Vector{CartesianState{Float64}}, \n               coord_system::CoordinateSystem;\n               name::String=\"\",\n               metadata::Dict{String,Any}=Dict{String,Any}())\n\nCreate a history segment from existing time and state data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.Spacecraft","page":"Reference","title":"AstroModels.Spacecraft","text":"mutable struct Spacecraft{S<:OrbitState, TT<:Time, CS<:AbstractCoordinateSystem, T<:Real}\n\nSpacecraft struct with state, time, mass, name, history, and coordinate system and other data\n\nFields\n\nstate::S — orbital state as an OrbitState struct\ntime::TT — epoch as a Time struct\nmass::T — total mass \nname::String — user label.\nhistory::SpacecraftHistory — trajectory history organized into segments\ncoord_sys::CS — coordinate system (origin and axes) associated with the spacecraft.\ncad_model::CADModel — 3D model for visualization\n\nNotes:\n\nUse the keyword constructor to create spacecraft and only define the fields you want to change from the defaults.\nState can be provided two ways as shown in the example below\nhistory stores trajectory data in segments; use history.segments to access individual HistorySegments\nNumeric parameter T is chosen by promotion: T = promote_type(eltype(state), typeof(time.jd1), typeof(mass)).\n\nExamples\n\nusing AstroModels, AstroStates, AstroEpochs, AstroFrames, AstroUniverse\n\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time  = Time(\"2015-09-21T00:00:00\", TAI(), ISOT()),\n    mass  = 1000.0,\n    name  = \"Demo\"\n)\n\n# alternative epoch definition\nsc = Spacecraft(state = OrbitState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03],Cartesian()))\n\n\n\n\n\n","category":"type"},{"location":"reference/#AstroModels.Spacecraft-Tuple{}","page":"Reference","title":"AstroModels.Spacecraft","text":"Spacecraft(; state = CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]),\n                  time = Time(\"2015-09-21T12:23:12\", UTC(), ISOT()),\n                  mass = 1000.0,\n                  name = \"unnamed\",\n                  history = nothing,\n                  coord_sys = CoordinateSystem(earth, ICRFAxes()))\n\nKwarg outer constructor for Spacecraft with defaults for all fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.Spacecraft-Union{Tuple{CS}, Tuple{TT}, Tuple{Union{AbstractState, OrbitState}, TT}} where {TT<:Time, CS<:AbstractCoordinateSystem}","page":"Reference","title":"AstroModels.Spacecraft","text":"Spacecraft(state::Union{AbstractState,OrbitState}, time::TT; mass=1000.0, name=\"unnamed\",\n           history=nothing, coord_sys=CoordinateSystem(earth, ICRFAxes())) where {TT<:Time}\n\nOuter positional constructor for Spacecraft that promotes numeric types as needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.SpacecraftHistory","page":"Reference","title":"AstroModels.SpacecraftHistory","text":"SpacecraftHistory\n\nContainer for spacecraft trajectory history, organized into segments.\n\nA SpacecraftHistory stores the complete trajectory of a spacecraft as a collection  of segments. Each segment represents a continuous portion of the  trajectory, with segments typically separated by discontinuities (e.g., maneuvers)  or mission phase boundaries.\n\nFields\n\nsegments::Vector{HistorySegment}: Solution trajectory segments\niterations::Vector{HistorySegment}: Solver iteration segments (diagnostic data)\nrecord_segments::Bool: Enable solution segment recording (default: true)\nrecord_iterations::Bool: Enable iteration segment recording (default: false)\n\nNotes\n\nMutable struct to allow solver to control recording flags\nEmpty history is valid (zero segments)\nProvides iteration, indexing, and standard collection interfaces\nIteration and indexing operate on segments only (solution trajectory)\nAccess iterations directly for diagnostic data: history.iterations\n\nExamples\n\nusing AstroModels, AstroEpochs, AstroUniverse, AstroFrames\n\n# Basic usage - record solution trajectory (default)\nhistory = SpacecraftHistory()\ncoord_sys = CoordinateSystem(earth, ICRFAxes())\n\nsegment1 = HistorySegment(coord_sys, name=\"orbit_1\")\npush_segment!(history, segment1)\n\n# Iterate over solution segments\nfor (i, segment) in enumerate(history)\n    println(\"Segment \", i, \": \", segment.name, \" (\", length(segment.times), \" points)\")\nend\n\n# Access by index (operates on solution segments only)\nfirst_segment = history[1]\nprintln(\"History contains \", length(history), \" solution segments\")\n\n# Advanced: Solver iteration recording for diagnostics\n# Disable solution recording, enable iteration recording\nhistory.record_segments = false\nhistory.record_iterations = true\n\n# During optimization, segments go to iterations vector\nfor iter in 1:10\n    segment = HistorySegment(coord_sys, name=\"iteration_$iter\")\n    push_segment!(history, segment)  # Routes to history.iterations\nend\n\n# Switch back for final solution\nhistory.record_segments = true\nhistory.record_iterations = false\nfinal_segment = HistorySegment(coord_sys, name=\"solution\")\npush_segment!(history, final_segment)  # Routes to history.segments\n\n# Result: 1 solution segment, 10 diagnostic iterations\nprintln(length(history))             # 1 (solution only)\nprintln(length(history.iterations))  # 10 (diagnostic data)\n\n\n\n\n\n","category":"type"},{"location":"reference/#AstroModels.SpacecraftHistory-Tuple{Vector{HistorySegment}}","page":"Reference","title":"AstroModels.SpacecraftHistory","text":"SpacecraftHistory(segments::Vector{HistorySegment})\n\nCreate a SpacecraftHistory from an existing vector of segments with default recording settings.\n\nDefaults\n\niterations: Empty vector (no iteration data)\nrecord_segments = true: Solution trajectory recording enabled\nrecord_iterations = false: Iteration recording disabled\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.SpacecraftHistory-Tuple{}","page":"Reference","title":"AstroModels.SpacecraftHistory","text":"SpacecraftHistory()\n\nCreate an empty SpacecraftHistory with default settings.\n\nDefaults\n\nrecord_segments = true: Solution trajectory recording enabled\nrecord_iterations = false: Iteration recording disabled (diagnostic mode off)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels._indent_and_print-Tuple{IO, Any, AbstractString}","page":"Reference","title":"AstroModels._indent_and_print","text":"_indent_and_print(io::IO, obj, prefix::AbstractString)\n\nIndent and print composed objects using their own show methods\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels._value_to_float64-Tuple{Real}","page":"Reference","title":"AstroModels._value_to_float64","text":"_value_to_float64(x::Real)\n\nHelper to safely convert any Real to Float64, handling Dual numbers from AD.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.get_state-Tuple{Spacecraft, AbstractOrbitStateType}","page":"Reference","title":"AstroModels.get_state","text":"get_state(sc::Spacecraft, target::AbstractOrbitStateType) -> AbstractOrbitState\n\nReturn the spacecraft's orbital state as the concrete type specified by target, converting if needed. Does not mutate sc.\n\nNotes\n\nIf conversion requires the gravitational parameter μ, it is taken from sc.coord_sys.origin.mu when available; otherwise an error is thrown.\nIf the current state already matches target, the existing state is returned without conversion to the new type.\nState is returned in the coordinate system of the spacecraft; no coordinate transformations are performed.\n\nExamples\n\nusing AstroModels\nsc = Spacecraft(\n           state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n           time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT())\n           );\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.push_segment!-Tuple{SpacecraftHistory, HistorySegment}","page":"Reference","title":"AstroModels.push_segment!","text":"push_segment!(history::SpacecraftHistory, segment::HistorySegment)\n\nAdd a segment to the history, routing based on recording flags.\n\nRouting Logic\n\nIf record_iterations=true: adds to history.iterations (diagnostic data)\nElse if record_segments=true: adds to history.segments (solution trajectory)\nElse: no-op (segment not recorded)\n\nNotes\n\nThis routing is controlled by the solver during trajectory optimization:\n\nDuring optimization iterations: record_iterations=true, record_segments=false\nFinal solution run: record_iterations=false, record_segments=true\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.set_posvel!-Tuple{Spacecraft, AbstractVector{<:Real}}","page":"Reference","title":"AstroModels.set_posvel!","text":"set_posvel!(sc::Spacecraft, x::AbstractVector{<:Real})\n\nSet the Cartesian position-velocity vector [x, y, z, vx, vy, vz] for sc in-place.\n\nSupported\n\nOrbitState with statetype == Cartesian().\n\nLimitations\n\nOther state representations currently throw an ArgumentError.  Use get_state(sc, Cartesian()) first.\n\nExamples\n\nusing AstroModels, AstroStates, AstroEpochs\nsc = Spacecraft(\n           state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n           time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT())\n       );\nset_posvel!(sc, [7050.0, 0.0, 0.0, 0.0, 7.6, 0.0]);\nto_posvel(sc)\n\n# output\n6-element Vector{Float64}:\n 7050.0\n    0.0\n    0.0\n    0.0\n    7.6\n    0.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.state_eltype-Tuple{OrbitState}","page":"Reference","title":"AstroModels.state_eltype","text":"state_eltype(os::OrbitState) = eltype(os.state)\n\nReturns the type of the elements in the state vector of an OrbitState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.to_float64-Tuple{CartesianState{Float64}}","page":"Reference","title":"AstroModels.to_float64","text":"to_float64(state::CartesianState{Float64})\nto_float64(state::CartesianState)\n\nConvert a CartesianState of any numeric type to CartesianState{Float64}.\n\nThis function handles automatic conversion from automatic differentiation types  (Dual numbers), BigFloat, and other numeric types to Float64 for history storage.\n\nArguments\n\nstate::CartesianState: State to convert (any numeric type parameter)\n\nReturns\n\nCartesianState{Float64}: State with Float64 components\n\nNotes\n\nNo-op for CartesianState{Float64} (returns input unchanged)\nUses to_vector() and broadcasts Float64 conversion\n\nExamples\n\n# From Dual numbers (automatic differentiation)\nstate_dual = CartesianState{Dual}([...])\nstate_f64 = to_float64(state_dual)\n\n# From BigFloat\nstate_big = CartesianState{BigFloat}([...])\nstate_f64 = to_float64(state_big)\n\n# From Float64 (no-op)\nstate = CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0])\nsame_state = to_float64(state)  \n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.to_float64-Tuple{Time{Float64}}","page":"Reference","title":"AstroModels.to_float64","text":"to_float64(time::Time{Float64})\nto_float64(time::Time)\n\nConvert a Time of any numeric type to Time{Float64}.\n\nThis function handles automatic conversion from automatic differentiation types  (Dual numbers), BigFloat, and other numeric types to Float64 for history storage.\n\nArguments\n\ntime::Time: Time to convert (any numeric type parameter)\n\nReturns\n\nTime{Float64}: Time with Float64 components\n\nNotes\n\nNo-op for Time{Float64} (returns input unchanged)\nPreserves time scale and format during conversion\n\nExamples\n\n# From Dual numbers (automatic differentiation)\ntime_dual = Time{Dual}(...)\ntime_f64 = to_float64(time_dual)\n\n# From Float64 (no-op)\ntime = Time(\"2024-01-01T00:00:00\", TAI(), ISOT())\nsame_time = to_float64(time)  # Returns input unchanged\n\n\n\n\n\n","category":"method"},{"location":"reference/#AstroModels.to_posvel-Tuple{Spacecraft}","page":"Reference","title":"AstroModels.to_posvel","text":"to_posvel(sc::Spacecraft) -> Vector{<:Real}\n\nReturn the Cartesian position-velocity vector [x, y, z, vx, vy, vz] for sc in its current coordinate system, converting the stored orbital state if needed.\n\nCurrently supported\n\nOrbitState with statetype == Cartesian() — returns the internal 6-vector (fast path).\nCartesianState — returns to_vector(state).\n\nLimitations\n\nOther state types currently throw an ArgumentError. Use get_state(sc, Cartesian()) first or extend conversions.\n\nExamples\n\nusing AstroModels, AstroStates, AstroEpochs, AstroFrames, AstroUniverse\nsc = Spacecraft(\n           state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n           time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()));\nto_posvel(sc)\n\n# output\n6-element Vector{Float64}:\n 7000.0\n  300.0\n    0.0\n    0.0\n    7.5\n    0.03\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.copy-Tuple{SpacecraftHistory}","page":"Reference","title":"Base.copy","text":"Base.copy(history::SpacecraftHistory)\n\nCreate a deep copy of a SpacecraftHistory, copying all segments and iterations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.deepcopy_internal-Tuple{Spacecraft, IdDict}","page":"Reference","title":"Base.deepcopy_internal","text":"Base.deepcopy_internal(sc::Spacecraft, dict::IdDict)\n\nDeep copy a spacecraft to ensure no aliasing of inner mutable fields\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.deepcopy_internal-Tuple{SpacecraftHistory, IdDict}","page":"Reference","title":"Base.deepcopy_internal","text":"Base.deepcopy_internal(history::SpacecraftHistory, dict::IdDict)\n\nDeep copy implementation for SpacecraftHistory to ensure proper copying of mutable fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.promote-Union{Tuple{Tnew}, Tuple{T}, Tuple{CS}, Tuple{TT}, Tuple{S}, Tuple{Spacecraft{S, TT, CS, T}, Type{Tnew}}} where {S, TT, CS, T, Tnew<:Real}","page":"Reference","title":"Base.promote","text":"Base.promote(sc::Spacecraft{S,TT,CS,T}, ::Type{Tnew}) where {S,TT,CS,T,Tnew<:Real}\n\nPromotes a Spacecraft to a new numeric type Tnew for automatic differentiation support. The state, time, and mass are promoted to Tnew, while history remains as Float64 for efficiency.\n\nThis enables AD workflows where computation types (e.g., ForwardDiff.Dual) are promoted while preserving Float64 ephemeris storage.\n\nArguments\n\nsc::Spacecraft: The spacecraft to promote\n::Type{Tnew}: Target numeric type (e.g., ForwardDiff.Dual{Nothing,Float64,3})\n\nReturns\n\nSpacecraft{S_new, TT_new, CS, Tnew}: Promoted spacecraft\n\nExample\n\nusing ForwardDiff\nsc = Spacecraft(state=CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]))\nsc_dual = promote(sc, ForwardDiff.Dual{Nothing,Float64,3})\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, CADModel}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, model::CADModel)\n\nPretty-print CADModel configuration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, HistorySegment}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, segment::HistorySegment)\n\nPretty-print a HistorySegment in a human-readable, multi-line summary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, SpacecraftHistory}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, history::SpacecraftHistory)\n\nDisplay a SpacecraftHistory in a human-readable format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, Spacecraft}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, sc::Spacecraft)\n\nPretty-print a Spacecraft in a human-readable, multi-line summary.\n\n\n\n\n\n","category":"method"},{"location":"dev/spacecraft_spec/#Spacecraft-Specification","page":"Spacecraft Specification","title":"Spacecraft Specification","text":"","category":"section"},{"location":"dev/spacecraft_spec/#History","page":"Spacecraft Specification","title":"History","text":"","category":"section"},{"location":"dev/spacecraft_spec/#1.-Overview-and-Motivation","page":"Spacecraft Specification","title":"1. Overview & Motivation","text":"The history field of Spacecraft stores propagated orbit state data for use in creating ephemeris files, 3D plots, reports etc. History segments are used to delineate discontinuities, and for separate mission events such as maneuver(), and propagate().\n\nHistory is stored as a vector of Time and matrix of cartesian state numbers but does not use the CartesianState struct. It does not scale well with new data like CoordinateSystem, segment name etc. Users access history data directly and the interface does not hide implementation so it is brittle.\nImplement a composed solution that provides an extendible interface for adding more history attributes like CoordinateSystem. Provide a better user interface that hides the implementation of the data/struct from the user. This means, accessing data for plotting, reporting etc. and a clean interface for integration with AstroCallbacks. ","category":"section"},{"location":"dev/spacecraft_spec/#2.-Requirements","page":"Spacecraft Specification","title":"2. Requirements","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Data-Requirements","page":"Spacecraft Specification","title":"Data Requirements","text":"Store Time and CartesianState per data point within a segment\nStore CoordinateSystem per segment\nSupport segment metadata (name, description, event type)\nSupport multiple segments with discontinuities between them\nThe history struct shall be extensible to handle potential fields and future metadata needs","category":"section"},{"location":"dev/spacecraft_spec/#Query/Access-Requirements","page":"Spacecraft Specification","title":"Query/Access Requirements","text":"Access state at specific point\nAccess state at specific time (with interpolation if needed)\nAccess full segment by index or name\nAccess data over time range (potentially spanning multiple segments)\nExport to arrays/matrices for plotting libraries\nProvide efficient iteration over time-state pairs\nSupport querying segment boundaries and metadata","category":"section"},{"location":"dev/spacecraft_spec/#Non-functional-Requirements","page":"Spacecraft Specification","title":"Non-functional Requirements","text":"Efficient append operations during propagation\nMemory efficient for long-duration propagations\nType stable for performance-critical operations\nMinimal overhead for single-segment use cases","category":"section"},{"location":"dev/spacecraft_spec/#Interface-Requirements","page":"Spacecraft Specification","title":"Interface Requirements","text":"Provide clean API for AstroCallbacks integration (adding history points during propagation)\nSupport ephemeris file generation (access to time-ordered state data)\nSupport 3D plotting (efficient bulk data access)\nHide implementation details from user code (abstraction barrier)","category":"section"},{"location":"dev/spacecraft_spec/#3.-Proposed-Data-Structure","page":"Spacecraft Specification","title":"3. Proposed Data Structure","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Core-Types","page":"Spacecraft Specification","title":"Core Types","text":"\"\"\"\n    HistorySegment\n\nRepresents a continuous segment of spacecraft trajectory history.\n\"\"\"\nstruct HistorySegment\n    times::Vector{Time}                      # Ordered vector of time points\n    states::Vector{CartesianState{Float64}}  # State vectors (always Float64)\n    coordinate_system::CoordinateSystem      # Reference frame for this segment\n    name::String                             # Optional segment identifier\n    metadata::Dict{String, Any}              # Extensible metadata storage\nend\n\n\"\"\"\n    SpacecraftHistory\n\nContainer for spacecraft trajectory history, organized into segments.\n\"\"\"\nstruct SpacecraftHistory\n    segments::Vector{HistorySegment}         # Solution trajectory segments\n    iterations::Vector{HistorySegment}       # Solver iteration segments (diagnostic)\n    record_segments::Bool                    # Enable solution segment recording\n    record_iterations::Bool                  # Enable iteration segment recording\nend","category":"section"},{"location":"dev/spacecraft_spec/#Design-Rationale","page":"Spacecraft Specification","title":"Design Rationale","text":"Storage Type Choice:\n\nHistory stores Float64 exclusively for simplicity and type stability\nAD types (Dual numbers) are automatically cast to Float64 during recording\nHistory is for output/analysis (plots, ephemeris), not gradient computation\nEliminates type parameter complexity while maintaining performance\n\nHistorySegment Fields:\n\ntimes and states as parallel vectors for efficient storage and access\ncoordinate_system at segment level (assumes single frame per segment)\nname for human-readable identification (empty string if unnamed)\nmetadata Dict provides extensibility without modifying struct\n\nSpacecraftHistory:\n\nSeparates solution trajectory (segments) from diagnostic data (iterations)\nRecording flags control which segments are populated during propagation\nDefault behavior: record solution only, skip iterations for efficiency\nThin abstraction layer to hide implementation","category":"section"},{"location":"dev/spacecraft_spec/#Alternative-Considerations","page":"Spacecraft Specification","title":"Alternative Considerations","text":"Single vectors vs. Vector of tuples: Parallel vectors chosen for performance and easier bulk access\nMutable vs. Immutable: Immutable structs chosen for safety; append operations create new segments or history\nDict metadata vs. explicit fields: Dict provides flexibility; can refactor to explicit fields if common patterns emerge\nSeparate coordinate system per point: Too granular; segment-level is sufficient for most use cases","category":"section"},{"location":"dev/spacecraft_spec/#4.-API-Design","page":"Spacecraft Specification","title":"4. API Design","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Constructors","page":"Spacecraft Specification","title":"Constructors","text":"# Create empty history\nSpacecraftHistory()\n\n# Create empty segment\nHistorySegment(coord_system::CoordinateSystem; \n               name::String=\"\", \n               metadata::Dict{String,Any}=Dict{String,Any}())\n\n# Create segment from existing data\nHistorySegment(times::Vector{Time}, \n               states::Vector{CartesianState{Float64}}, \n               coord_system::CoordinateSystem;\n               name::String=\"\",\n               metadata::Dict{String,Any}=Dict{String,Any}())","category":"section"},{"location":"dev/spacecraft_spec/#Adding/Updating-History","page":"Spacecraft Specification","title":"Adding/Updating History","text":"# Add a point to an existing segment (mutates segment's times/states vectors)\n# Automatically converts Dual/BigFloat to Float64\npush_state!(segment::HistorySegment, time::Time, state::CartesianState)\n\n# Add a new segment to history (routes based on history.record_segments and history.record_iterations flags)\n# - If record_iterations=true: adds to history.iterations\n# - If record_segments=true and record_iterations=false: adds to history.segments\n# - Otherwise: no-op (segment not recorded)\npush_segment!(history::SpacecraftHistory, segment::HistorySegment)\n\n# Start a new segment (convenience for propagation - creates and adds empty segment)\nnew_segment!(history::SpacecraftHistory, \n             coord_system::CoordinateSystem; \n             name::String=\"\",\n             metadata::Dict{String,Any}=Dict{String,Any}())","category":"section"},{"location":"dev/spacecraft_spec/#Query/Access-Methods","page":"Spacecraft Specification","title":"Query/Access Methods","text":"# Direct field access (no getters needed)\nsegment.times                    # Vector{Time{Float64}}\nsegment.states                   # Vector{CartesianState{Float64}}\nsegment.coordinate_system        # CoordinateSystem\nsegment.name                     # String\nsegment.metadata                 # Dict{String,Any}\n\nhistory.segments                 # Vector{HistorySegment} - solution trajectory\nhistory.iterations               # Vector{HistorySegment} - solver iterations (if recorded)\nhistory.record_segments          # Bool - is solution recording enabled?\nhistory.record_iterations        # Bool - is iteration recording enabled?\nhistory.record_iterations        # Bool - is iteration recording enabled?\nhistory[i]                       # Get segment by index from solution trajectory\nlength(history)                  # Number of solution segments\nisempty(history)                 # Check if solution trajectory empty\nisempty(segment)                 # Check if segment empty\n\n# Iteration (iterates over solution segments only)tory)                 # Check if empty\nisempty(segment)                 # Check if segment empty\n\n# Iteration\nfor segment in history\n    # Process each segment\nend","category":"section"},{"location":"dev/spacecraft_spec/#Export/Conversion","page":"Spacecraft Specification","title":"Export/Conversion","text":"Export functions TBD when integrating with plotting/reporting systems","category":"section"},{"location":"dev/spacecraft_spec/#Integration-Points","page":"Spacecraft Specification","title":"Integration Points","text":"# For AstroCallbacks - append during propagation\n# Callback adds (time, state) to current segment\nfunction record_history!(history::SpacecraftHistory, time::Time, state::CartesianState)\n    current_segment = last(history.segments)\n    push_state!(current_segment, time, state)\nend\n\n# For propagate() - start new segment\nfunction propagate!(sc::Spacecraft, ...)\n    new_segment!(sc.history, sc.coordinate_system, name=\"propagate_\\$(timestamp)\")\n    # ... propagation loop calls record_history!\nend\n\n# For maneuver() - mark discontinuity with new segment  \nfunction maneuver!(sc::Spacecraft, ...)\n    new_segment!(sc.history, sc.coordinate_system, name=\"maneuver_\\$(timestamp)\")\n    # ... maneuver updates state\nend","category":"section"},{"location":"dev/spacecraft_spec/#Design-Notes","page":"Spacecraft Specification","title":"Design Notes","text":"Immutability compromise: While structs are immutable, the vectors they contain can be mutated for efficiency during propagation. push_state! modifies the underlying vector.\nNaming convention: push_*! for mutations, direct field access for data retrieval\nType inference: Return types preserve T parameter for type stability\nSegment access: Direct indexing history[i] in Phase 1, name-based lookup in Phase 2\nNo getter functions: Fields are public, use direct access (e.g., segment.times not get_times(segment))","category":"section"},{"location":"dev/spacecraft_spec/#5.-Usage-Examples","page":"Spacecraft Specification","title":"5. Usage Examples","text":"This section explores how the history design integrates with other system components and enables common user workflows.","category":"section"},{"location":"dev/spacecraft_spec/#Plotting-Integration","page":"Spacecraft Specification","title":"Plotting Integration","text":"Use Case: User wants to visualize trajectory after propagation\n\n# Simple case - plot entire trajectory\npropagate!(sat, duration=3days)\nview = View3D()\nadd_spacecraft!(view, sat)\ndisplay_view(view)\n\nRequirements from History:\n\nEfficient iteration over segments and time-state pairs\nExtract position data (x, y, z) from CartesianState\nSupport per-segment visualization (different colors for each segment)\nQuery coordinate system for proper frame rendering","category":"section"},{"location":"dev/spacecraft_spec/#AstroCallbacks-Integration","page":"Spacecraft Specification","title":"AstroCallbacks Integration","text":"Use Case: History is recorded automatically during propagation\n\n# History recording happens automatically\npropagate!(sat, duration=1day)\n# sat.history now contains trajectory data\n\nRequirements from History:\n\nFast append operations (push_state!) called frequently during integration\nAccess to current segment for appending\nAutomatic segment creation when propagate() or maneuver() is called\n\nInternal Implementation Note: History recording is handled internally by the propagation system via callbacks. Users don't need to configure history recording - it just works.","category":"section"},{"location":"dev/spacecraft_spec/#Ephemeris-File-Generation","page":"Spacecraft Specification","title":"Ephemeris File Generation","text":"Use Case: Export trajectory to SPK or other ephemeris format\n\n# Create ephemeris configuration\nephem = EphemerisFile(\n    filename = \"mission.bsp\",\n    format = :spk,\n    interpolation = :hermite\n)\n\n# Add spacecraft trajectory\nadd_spacecraft!(ephem, sat)\n\n# Write the file\nwrite_ephemeris(ephem)\n\nRequirements from History:\n\nTime-ordered state data access per segment\nCoordinate system metadata for frame specifications\nSegment boundaries map naturally to SPK segments\nSupport iteration for different interpolation schemes\n\nRequirements from History:\n\nTime-ordered state data access per segment\nCoordinate system metadata for frame specifications\nSegment boundaries map naturally to SPK segments\nSupport iteration for different interpolation schemes","category":"section"},{"location":"dev/spacecraft_spec/#2D-Plotting","page":"Spacecraft Specification","title":"2D Plotting","text":"Use Case: Create 2D plots of trajectory data\n\n# Create plot configuration\nplot2d = Plot2D(\n    title = \"Altitude Profile\",\n    xlabel = \"Time (days)\",\n    ylabel = \"Altitude (km)\"\n)\n\n# Add quantities to plot\nadd_quantity!(plot2d, sat, :altitude)\nadd_quantity!(plot2d, sat, :velocity_magnitude)\n\n# Display the plot\ndisplay_plot(plot2d)\n\nRequirements from History:\n\nEfficient extraction of time series data\nAccess to full state vectors for computing derived quantities\nSupport for multiple spacecraft on same plot\nHandle segment boundaries (discontinuities in plots)","category":"section"},{"location":"dev/spacecraft_spec/#Report-Generation","page":"Spacecraft Specification","title":"Report Generation","text":"Use Case: Generate mission analysis reports\n\n# Create report configuration\nreport = MissionReport(\n    title = \"Orbital Analysis\",\n    format = :pdf\n)\n\n# Add report sections\nadd_section!(report, :trajectory_summary, sat)\nadd_section!(report, :maneuver_performance, sat)\nadd_section!(report, :orbit_statistics, sat)\n\n# Generate the report\ngenerate_report(report, \"mission_report.pdf\")\n\nRequirements from History:\n\nQuery time ranges and statistics per segment\nAccess segment metadata (names, event types)\nExtract state data for analysis functions\nSupport tabular data export for report tables","category":"section"},{"location":"dev/spacecraft_spec/#Common-User-Workflows","page":"Spacecraft Specification","title":"Common User Workflows","text":"Workflow 1: Quick trajectory inspection (segments transparent)\n\npropagate!(sat, duration=2days)\nplot(sat.history)  # User doesn't think about segments\n\nWorkflow 2: Multi-phase mission (segments visible)\n\npropagate!(sat, duration=1day)\nmaneuver!(sat, dv=[0.1, 0, 0])\npropagate!(sat, duration=1day)\n\n# User wants to see each phase\nfor (i, segment) in enumerate(history.segments)\n    println(\"Segment \\$i: \\$(segment.name), \\$(length(segment.times)) points\")\nend\n\nWorkflow 3: Custom analysis (full API access)\n\n# User has direct field access\nsegment1_times = history.segments[1].times\nsegment1_states = history.segments[1].states\n# Custom processing...","category":"section"},{"location":"dev/spacecraft_spec/#Design-Implications","page":"Spacecraft Specification","title":"Design Implications","text":"Flattening is key: Many operations (plot, export) should work across all segments by default\nSegment awareness optional: User shouldn't need to know about segments for simple cases\nPerformance matters for callbacks: push_state! will be called thousands of times\nMetadata enables rich features: Names, coordinate systems, metadata enable better reports/plots\nStandard interfaces: Consider implementing standard Julia interfaces (Tables.jl, Plots.jl recipes)","category":"section"},{"location":"dev/spacecraft_spec/#6.-Implementation-Details","page":"Spacecraft Specification","title":"6. Implementation Details","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Storage-Format","page":"Spacecraft Specification","title":"Storage Format","text":"mutable struct SpacecraftHistory     segments::Vector{HistorySegment}     iterations::Vector{HistorySegment}     recordsegments::Bool     recorditerations::Bool end\n\n- Mutable to allow flag modification by solver\n- Separate vectors for solution vs iteration segments\n- No type parameters - history always stores Float64\n- Internal vectors\n- Simple wrapper around vector of segments\n- No type parameters - history always stores Float64\n- Immutable struct, but internal vector can grow via `push!`\n\n**HistorySegment struct:**\n\njulia struct HistorySegment     times::Vector{Time}     states::Vector{CartesianState{Float64}}     coordinate_system::CoordinateSystem     name::String     metadata::Dict{String, Any} end\n\n- Parallel vectors (`times`, `states`) for cache-friendly access\n- Concrete Float64 type for full type stability\n- Immutable struct protects invariants, but vectors can be mutated internally\n\n**Memory layout:**\n- Contiguous vectors enable SIMD and efficient bulk operations\n- Vector{CartesianState{Float64}} stores actual data inline (not pointers)\n- Metadata Dict only allocated when needed (empty dict is lightweight)\n\n#### Indexing Strategy\n\n**Direct field access (internal use only):**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#Fast-path-for-performance-critical-code","page":"Spacecraft Specification","title":"Fast path for performance-critical code","text":"segment = getfield(history, :segments)[idx] times_vec = getfield(segment, :times)\n\n\n**Property access via getproperty (user interface):**\n\njulia Base.getproperty(h::SpacecraftHistory, s::Symbol) =      if s === :num_segments         length(getfield(h, :segments))     elseif s === :segments         getfield(h, :segments)     else         getfield(h, s)     end\n\nBase.getproperty(seg::HistorySegment, s::Symbol) =      if s === :num_points         length(getfield(seg, :times))     else         getfield(seg, s)     end\n\n\n**Array-like indexing:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#Access-segment-by-index","page":"Spacecraft Specification","title":"Access segment by index","text":"Base.getindex(h::SpacecraftHistory, i::Int) = h.segments[i] Base.getindex(h::SpacecraftHistory, r::UnitRange) = h.segments[r]","category":"section"},{"location":"dev/spacecraft_spec/#Iteration-support","page":"Spacecraft Specification","title":"Iteration support","text":"Base.iterate(h::SpacecraftHistory, state=1) =      state > length(h.segments) ? nothing : (h.segments[state], state+1)\n\nBase.length(h::SpacecraftHistory) = length(h.segments)\n\n\n**Segment lookup by name (Phase 2):**\n\njulia Base.getindex(h::SpacecraftHistory, name::String) =      findfirst(seg -> seg.name == name, h.segments)\n\n\n#### Memory Management\n\n**Preallocating segments:**\n- During propagation, segments grow incrementally\n- Consider sizehint! for expected trajectory length:\n\njulia function newsegment!(history, coordsys; expectedpoints=1000, kwargs...)     segment = HistorySegment(coordsys; kwargs...)     sizehint!(segment.times, expectedpoints)     sizehint!(segment.states, expectedpoints)     push!(history.segments, segment) end\n\n\n\n\n**Append performance:**\n\njulia function pushstate!(segment::HistorySegment, time::Time, state::CartesianState)     # Direct field access for performance     times = getfield(segment, :times)     states = getfield(segment, :states)     # Convert to Float64 (handles Dual, BigFloat, etc.)     statef64 = tofloat64(state)     push!(times, time)     push!(states, statef64)     return nothing end\n\n- Amortized O(1) append due to vector growth strategy\n- Critical path during integration - no allocations except vector resize\n- `to_float64` handles automatic conversion from AD types\n\n**Type conversion helper:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#Conversion-from-any-CartesianState{T}-to-CartesianState{Float64}","page":"Spacecraft Specification","title":"Conversion from any CartesianState{T} to CartesianState{Float64}","text":"tofloat64(state::CartesianState{Float64}) = state  # No-op for Float64 tofloat64(state::CartesianState) = CartesianState(Float64.(to_vector(state)))\n\n\n**Memory footprint estimate:**\n- Each Time: ~24 bytes\n- Each CartesianState{Float64}: ~48 bytes (6 Float64s)\n- Per point overhead: ~72 bytes\n- 10,000 points ≈ 700 KB\n- Segment metadata: negligible unless Dict is populated\n\n**Cleanup considerations:**\n- History is immutable from spacecraft perspective\n- Clear history by creating new empty history\n- Segments are garbage collected when history is replaced\n- No manual memory management needed\n\n#### Type Stability\n\n**Concrete Float64 storage:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#History-always-uses-concrete-Float64-type","page":"Spacecraft Specification","title":"History always uses concrete Float64 type","text":"history = SpacecraftHistory() segment = HistorySegment(coord_sys)","category":"section"},{"location":"dev/spacecraft_spec/#Automatic-conversion-from-any-numeric-type","page":"Spacecraft Specification","title":"Automatic conversion from any numeric type","text":"statedual = CartesianState{Dual}([...])  # From AD propagation pushstate!(segment, time, state_dual)     # Converts to Float64 internally","category":"section"},{"location":"dev/spacecraft_spec/#Result-is-always-type-stable-Float64","page":"Spacecraft Specification","title":"Result is always type-stable Float64","text":"stored_state = segment.states[1]  # CartesianState{Float64}\n\n\n**Type stability benefits:**\n- No type parameters eliminates parametric complexity\n- Vector{CartesianState{Float64}} is fully concrete\n- AD overhead isolated to propagation, not storage\n- metadata Dict is type-unstable by design (flexibility > performance here)\n- Use getfield() in hot loops to avoid getproperty overhead\n\n**P# Solver Iteration Recording (Optional Feature)\n\n**Requirement:** Support recording solver iterations for trajectory optimization diagnostics.\n\n**Use Case:** During trajectory optimization, the solver may evaluate thousands of candidate trajectories. By default, only the final converged solution is recorded in history. For debugging convergence issues or visualizing the optimization process, users can opt to record all iterations.\n\n**Design:**\n- Separate storage: `iterations` vector contains iteration segments, `segments` contains solution\n- Two independent flags control recording:\n  - `record_segments::Bool = true` - Controls solution segment recording\n  - `record_iterations::Bool = false` - Controls iteration segment recording\n- Routing logic in `push_segment!`:\n  ```julia\n  function push_segment!(history, segment)\n      if history.record_iterations\n          push!(history.iterations, segment)\n      elseif history.record_segments\n          push!(history.segments, segment)\n      end\n      # If both false: segment not recorded (no-op)\n  end\n  ```\n\n**Solver Integration (AstroSolve):**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#In-trajectory*solve(seq,-options;-record*iterationsfalse)","page":"Spacecraft Specification","title":"In trajectorysolve(seq, options; recorditerations=false)","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Default-mode:-record_iterationsfalse","page":"Spacecraft Specification","title":"Default mode: record_iterations=false","text":"sc.history.recordsegments = false      # Don't record during optimization sc.history.recorditerations = false","category":"section"},{"location":"dev/spacecraft_spec/#...-optimizer-runs,-history-not-populated-...","page":"Spacecraft Specification","title":"... optimizer runs, history not populated ...","text":"sc.history.record_segments = true       # Record final solution only","category":"section"},{"location":"dev/spacecraft_spec/#...-execute-sequence-one-final-time-...","page":"Spacecraft Specification","title":"... execute sequence one final time ...","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Diagnostic-mode:-record_iterationstrue","page":"Spacecraft Specification","title":"Diagnostic mode: record_iterations=true","text":"sc.history.recordsegments = false      # Don't record in segments sc.history.recorditerations = true     # Do record in iterations","category":"section"},{"location":"dev/spacecraft_spec/#...-optimizer-runs,-all-iterations-stored-in-history.iterations-...","page":"Spacecraft Specification","title":"... optimizer runs, all iterations stored in history.iterations ...","text":"sc.history.recorditerations = false    # Switch to solution mode sc.history.recordsegments = true","category":"section"},{"location":"dev/spacecraft_spec/#...-execute-sequence-final-time,-solution-in-history.segments-...","page":"Spacecraft Specification","title":"... execute sequence final time, solution in history.segments ...","text":"\n**Benefits:**\n- Clean separation: solution data vs diagnostic data\n- Memory efficient default: iterations not recorded unless requested\n- Opt-in diagnostics: power users can visualize convergence behavior\n- Natural access: `history.segments` always contains solution trajectory\n\n**Rationale:**\n- Alternative considered: Single `segments` vector with `is_iteration::Bool` field per segment\n  - Rejected: Mixing solution and diagnostic data complicates filtering for ephemeris, plots\n  - Rejected: Requires checking metadata/field for every operation\n- Separate vectors make intent clear: iterations are purely diagnostic, segments are mission data\n\n**Example Usage:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#Debug-mode-see-all-optimization-iterations","page":"Spacecraft Specification","title":"Debug mode - see all optimization iterations","text":"result = trajectorysolve(seq, options; recorditerations=true) view = View3D() add_spacecraft!(view, sat)","category":"section"},{"location":"dev/spacecraft_spec/#Visualize-shows-all-iteration-trajectories-overlaid-(diagnostic-view)","page":"Spacecraft Specification","title":"Visualize shows all iteration trajectories overlaid (diagnostic view)","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Production-mode-clean-final-solution-only-(default)","page":"Spacecraft Specification","title":"Production mode - clean final solution only (default)","text":"result = trajectorysolve(seq, options)  # recorditerations=false view = View3D()   add_spacecraft!(view, sat)","category":"section"},{"location":"dev/spacecraft_spec/#Visualize-shows-only-final-converged-trajectory","page":"Spacecraft Specification","title":"Visualize shows only final converged trajectory","text":"\n###erformance validation:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#Should-show-no-allocations-in-steady-state","page":"Spacecraft Specification","title":"Should show no allocations in steady state","text":"@btime push_state!($segment, $time, $state)\n\n\n### 7. Migration Strategy\n\n**No backwards compatibility required** - breaking change acceptable since API is pre-release.\n\n#### Package-Level Changes\n\n**1. AstroModels (Core definitions)**\n- Define `HistorySegment` and `SpacecraftHistory` structs\n- Implement API functions (constructors, push_state!, push_segment!, queries)\n- Update `Spacecraft` type: `history::Vector{...}` → `history::SpacecraftHistory`\n- Remove old history accessor functions\n- Export new types and functions\n\n**2. AstroCallbacks (History recording)**\n- Update callback functions to use `push_state!` instead of vector append\n- Replace: `push!(sc.history[end], (time, vec(state)))` \n- With: `push_state!(current_segment(sc.history), time, state)`\n- Add segment management if callbacks control propagation phases\n\n**3. AstroProp (Propagation)**\n- Call `new_segment!` at propagation start\n- Update state recording to use `push_state!`\n- Add segment naming/metadata for propagation phases\n- Ensure coordinate system passed to segment constructor\n\n**4. Epicycle (Visualization - View3D)**\n- Update history access to iterate over segments\n- Use `get_positions()` for 3D rendering per segment\n- Iterate over segments if rendering with different styles\n- Handle coordinate system transformations for multi-frame histories\n\n**5. Examples & Tests**\n- Update all example scripts using history\n- Replace manual history indexing with API calls\n- Add examples demonstrating segment-based workflows\n- Update plotting examples to use `to_matrix()` or `get_positions()`\n\n#### Implementation Order\n\n\nPhase 1: Core (AstroModels) ├─ Define structs ├─ Implement API functions   └─ Add tests\n\nPhase 2: Recording (AstroCallbacks + AstroProp) ├─ Update propagation to create segments ├─ Update callbacks to push states └─ Test basic propagation\n\nPhase 3: Consumers (Epicycle + Examples) ├─ Update View3D rendering ├─ Update plotting utilities ├─ Update examples and docs └─ Full integration tests\n\nPhase 4: Cleanup ├─ Remove commented-out old code ├─ Update package documentation └─ Verify all tests pass\n\n\n#### Code Changes Required\n\n**AstroModels/src/spacecraft.jl:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#OLD","page":"Spacecraft Specification","title":"OLD","text":"mutable struct Spacecraft{T}     # ...     history::Vector{Vector{Tuple{Time, Vector{Float64}}}} end","category":"section"},{"location":"dev/spacecraft_spec/#NEW","page":"Spacecraft Specification","title":"NEW","text":"mutable struct Spacecraft{T}     # ...     history::SpacecraftHistory end","category":"section"},{"location":"dev/spacecraft_spec/#Update-constructor","page":"Spacecraft Specification","title":"Update constructor","text":"Spacecraft(...) = Spacecraft(..., SpacecraftHistory(), ...)\n\n\n**AstroCallbacks recording:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#OLD-2","page":"Spacecraft Specification","title":"OLD","text":"function record_callback(time, state, ...)     push!(sc.history[end], (time, Vector{Float64}(vec(state)))) end","category":"section"},{"location":"dev/spacecraft_spec/#NEW-2","page":"Spacecraft Specification","title":"NEW","text":"function recordcallback(time, state, ...)     segment = last(sc.history.segments)     pushstate!(segment, time, CartesianState(state)) end\n\n✓ Solver iteration history: Separate iterations vector with opt-in recording (Section 6.5)\n✓ History recording control: enabled and record_iterations flags on SpacecraftHistory (Section 6.5)\n\n\n**AstroProp propagation start:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#OLD-3","page":"Spacecraft Specification","title":"OLD","text":"propagate!(sc, ...) = begin     push!(sc.history, Vector{Tuple{Time,Vector{Float64}}}())     # ... end","category":"section"},{"location":"dev/spacecraft_spec/#NEW-3","page":"Spacecraft Specification","title":"NEW","text":"propagate!(sc, ...) = begin     newsegment!(sc.history, sc.coordinatesystem,                   name=\"propagate_$(now())\")     # ... end\n\n\n**Epicycle View3D rendering:**\n\njulia","category":"section"},{"location":"dev/spacecraft_spec/#OLD-4","page":"Spacecraft Specification","title":"OLD","text":"positions = [hist[2] for seg in sc.history for hist in seg]","category":"section"},{"location":"dev/spacecraft_spec/#NEW-4","page":"Spacecraft Specification","title":"NEW","text":"","category":"section"},{"location":"dev/spacecraft_spec/#Iterate-per-segment,-handle-coordinate-systems","page":"Spacecraft Specification","title":"Iterate per segment, handle coordinate systems","text":"for segment in sc.history.segments     positions = get_positions(segment)  # Nx3 matrix per segment     # ... render with segment's coordinate system end ```","category":"section"},{"location":"dev/spacecraft_spec/#File-Locations","page":"Spacecraft Specification","title":"File Locations","text":"AstroModels/src/history.jl - New file with struct definitions and API\nAstroModels/src/spacecraft.jl - Update Spacecraft type\nAstroModels/src/AstroModels.jl - Add exports\nAstroCallbacks/src/recording.jl - Update recording callbacks\nAstroProp/src/propagate.jl - Update propagation functions\nEpicycle/src/view3d.jl - Update visualization\nexamples/ - Update all example scripts","category":"section"},{"location":"dev/spacecraft_spec/#Migration-Checklist","page":"Spacecraft Specification","title":"Migration Checklist","text":"Strategy:  Implement code, tests, and docs simultaneously as we go. \n\nUpdate AstroModels first, then address modules that integrate with AstroModels \n\nin this order AstroProp, Epicycle(View3D), AstroCallbacks\n\n[x] Implement HistorySegment, unit test, doc strings \n[x] Implement SpacecraftHistory, unit test, and docstrings\n[x] Update Spacecraft type definition and update AstroModels test and docs\n[x] AstroProp integration\n[x] AstroManeuvers integration\n[x] AstroCallbacks integration (no changes needed)\n[x] Update Epicycle View3D access patterns\n[x] Update/add examples\n[ ] Write Spacecraft user guide (quick reference?, other user material)\n[ ] Run full test suite across all packages\n[ ] Remove old commented code","category":"section"},{"location":"dev/spacecraft_spec/#8.-Testing-Plan","page":"Spacecraft Specification","title":"8. Testing Plan","text":"Tests will be developed alongside implementation (TDD approach):\n\nWrite unit test for each function as it's implemented\nVerify type stability, edge cases, and API contracts\nAdd integration tests after each phase (propagate → record → query workflows)\nBenchmark performance-critical operations (pushstate!, getpositions)\n\nSee Migration Checklist for test coverage strategy.","category":"section"},{"location":"dev/spacecraft_spec/#9.-Open-Questions","page":"Spacecraft Specification","title":"9. Open Questions","text":"Resolved:\n\n✓ Dual → Float64 conversion: Use Float64.(to_vector(state)) via to_float64() helper (Section 6)\n✓ Solver iteration history: Separate iterations vector with opt-in recording (Section 6.5)\n✓ History recording control: record_segments and record_iterations flags on SpacecraftHistory (Section 6.5)\n\nTo be addressed during implementation:\n\nError handling strategy (throw vs return codes)\nTime interpolation implementation (defer to Phase 2)","category":"section"},{"location":"spacecraft_state/#State","page":"State","title":"State","text":"The state field stores the spacecraft's orbital state (position and velocity) using the OrbitState type from AstroStates.","category":"section"},{"location":"spacecraft_state/#Creating-Spacecraft-with-State","page":"State","title":"Creating Spacecraft with State","text":"using AstroModels, AstroStates\n\n# Method 1: Using CartesianState (recommended)\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03])\n)\n\n# Method 2: Using KeplerianState\nsc = Spacecraft(\n    state = KeplerianState([7000.0, 0.01, 45.0, 0.0, 0.0, 0.0])\n)\n\n# Method 3: Direct OrbitState construction\nsc = Spacecraft(\n    state = OrbitState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03], Cartesian())\n)\n\nNote: The spacecraft uses OrbitState internally but accepts concrete state types (e.g., CartesianState, KeplerianState) at construction for convenience.","category":"section"},{"location":"spacecraft_state/#Accessing-State","page":"State","title":"Accessing State","text":"# Get current state in specific representation\ncart_state = get_state(sc, Cartesian())\nkep_state = get_state(sc, Keplerian())\n\n# Get position/velocity vector (6-element)\npv = to_posvel(sc)  # [x, y, z, vx, vy, vz]","category":"section"},{"location":"spacecraft_state/#Modifying-State","page":"State","title":"Modifying State","text":"# Update position and velocity\nnew_pv = [7050.0, 0.0, 0.0, 0.0, 7.6, 0.0]\nset_posvel!(sc, new_pv)  # Mutates spacecraft in place","category":"section"},{"location":"spacecraft_state/#Type-Promotion","page":"State","title":"Type Promotion","text":"State components automatically promote for automatic differentiation:\n\nusing ForwardDiff\n\n# Create with Dual mass\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    mass = ForwardDiff.Dual(1000.0, 1.0)\n)\n\n# All state components promoted to Dual\nsc.state  # OrbitState with Dual{Float64} elements","category":"section"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Spacecraft-Model","page":"Overview","title":"Spacecraft Model","text":"The Spacecraft type represents a spacecraft with:\n\nOrbital state (position and velocity)\nEpoch (time)\nPhysical properties (mass, reflectivity)\nTrajectory history\nCoordinate system\nOptional 3D model for visualization","category":"section"},{"location":"overview/#History-System","page":"Overview","title":"History System","text":"Trajectory history is automatically recorded during propagation and organized into segments. Segments delineate mission phases (coast, maneuver) and enable multi-phase mission analysis.\n\nSee History Guide for details on accessing and working with trajectory data.","category":"section"},{"location":"spacecraft_time/#Time","page":"Time","title":"Time","text":"The time field stores the spacecraft's epoch using the Time type from AstroEpochs.","category":"section"},{"location":"spacecraft_time/#Basic-Usage","page":"Time","title":"Basic Usage","text":"using AstroModels, AstroEpochs\n\n# Create spacecraft with specific epoch\nsc = Spacecraft(\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT())\n)\n\n# Access current epoch\ncurrent_time = sc.time","category":"section"},{"location":"spacecraft_time/#Time-Scales","page":"Time","title":"Time Scales","text":"Time can be specified in different time scales (TAI, UTC, TT, TDB):\n\n# TAI (International Atomic Time)\nsc = Spacecraft(\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT())\n)\n\n# UTC (Coordinated Universal Time)  \nsc = Spacecraft(\n    time = Time(\"2015-09-21T12:23:12\", UTC(), ISOT())\n)\n\n# TT (Terrestrial Time) - for Earth-centered dynamics\nsc = Spacecraft(\n    time = Time(\"2015-09-21T12:23:12\", TT(), ISOT())\n)","category":"section"},{"location":"spacecraft_time/#Type-Promotion","page":"Time","title":"Type Promotion","text":"When using automatic differentiation, the time's Julian day components promote to Dual numbers:\n\nusing ForwardDiff\n\nsc = Spacecraft(\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    mass = ForwardDiff.Dual(1000.0, 1.0)\n)\n\n# Time components promoted to Dual\nsc.time.jd1  # Dual number\nsc.time.jd2  # Dual number","category":"section"},{"location":"spacecraft_mass/#Mass","page":"Mass","title":"Mass","text":"The mass field stores the spacecraft's total mass in kilograms.","category":"section"},{"location":"spacecraft_mass/#Basic-Usage","page":"Mass","title":"Basic Usage","text":"# Specify mass at construction\nsc = Spacecraft(\n    mass = 1500.0  # kg\n)\n\n# Access mass\ncurrent_mass = sc.mass","category":"section"},{"location":"spacecraft_mass/#Type-Promotion","page":"Mass","title":"Type Promotion","text":"Mass participates in automatic differentiation type promotion:\n\nusing ForwardDiff\n\n# Mass with Dual number\nsc = Spacecraft(\n    mass = ForwardDiff.Dual(1000.0, 1.0)  # Value with derivative\n)\n\n# All numeric fields promote to Dual\nsc.mass   # Dual{Float64}\nsc.state  # OrbitState with Dual{Float64} elements\nsc.c_r    # Dual{Float64}\n\nThe spacecraft's numeric type T is: T = promote_type(eltype(state), typeof(time.jd1), typeof(mass), typeof(c_r))","category":"section"},{"location":"#AstroModels","page":"QuickStart","title":"AstroModels","text":"AstroModels provides physical models for astrodynamics applications, including spacecraft representations with orbital state, time, and physical properties. All models are designed for compatibility with automatic differentiation libraries.","category":"section"},{"location":"#Quick-Start","page":"QuickStart","title":"Quick Start","text":"using AstroModels, AstroStates, AstroEpochs, AstroFrames, AstroUniverse\n\n# Create spacecraft with all key properties\nsc = Spacecraft(\n    # Orbital state (position and velocity)\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    \n    # Epoch\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    \n    # Mass (kg)\n    mass = 1000.0,\n    \n    # Coordinate system\n    coord_sys = CoordinateSystem(earth, ICRFAxes()),\n    \n    # 3D model for visualization\n    cad_model = CADModel(\n        file_path = \"models/satellite.obj\",\n        scale = 100.0,\n        visible = true\n    ),\n    \n    # Name\n    name = \"MySat\"\n)\n\n# History is automatically populated during propagation\n# See Spacecraft > History for details\n\nwarning: Spacecraft state data type\nThe spacecraft uses the OrbitState struct internally but accepts concrete state types (e.g., CartesianState, KeplerianState) at construction. See the State section for complete details.","category":"section"},{"location":"#Learn-More","page":"QuickStart","title":"Learn More","text":"State - Orbital state representations\nTime - Epoch and time scales\nMass - Spacecraft mass\nCoordinate System - Reference frames\nCAD Model - 3D visualization\nHistory - Trajectory data\nReference - Complete API documentation","category":"section"}]
}
