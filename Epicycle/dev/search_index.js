var documenterSearchIndex = {"docs":
[{"location":"components/#Components","page":"Components","title":"Components","text":"The Epicycle ecosystem consists of eleven specialized packages organized in architectural layers. Each package provides focused functionality while maintaining clean interfaces for composition into mission analysis workflows.","category":"section"},{"location":"components/#Foundation-Packages","page":"Components","title":"Foundation Packages","text":"Core abstractions and fundamental representations that underpin all mission analysis capabilities.","category":"section"},{"location":"components/#[EpicycleBase](https://genastro.github.io/Epicycle/EpicycleBase/dev/)","page":"Components","title":"EpicycleBase","text":"Core abstractions, type hierarchy, and fundamental constants. Provides the foundational types and interfaces used throughout the ecosystem.","category":"section"},{"location":"components/#[AstroStates](https://genastro.github.io/Epicycle/AstroStates/dev/)","page":"Components","title":"AstroStates","text":"Spacecraft state representations and coordinate transformations. Handles Cartesian, Keplerian, and Modified Equinoctial element representations with conversion capabilities.","category":"section"},{"location":"components/#[AstroEpochs](https://genastro.github.io/Epicycle/AstroEpochs/dev/)","page":"Components","title":"AstroEpochs","text":"Time systems, epoch handling, and temporal conversions. Provides rigorous time standards including UTC, TAI, TT, and TDB with high-precision conversions.","category":"section"},{"location":"components/#Physical-Models","page":"Components","title":"Physical Models","text":"Environmental and spacecraft modeling capabilities for realistic mission simulation.","category":"section"},{"location":"components/#[AstroUniverse](https://genastro.github.io/Epicycle/AstroUniverse/dev/)","page":"Components","title":"AstroUniverse","text":"Celestial body models, ephemeris data, and gravitational parameters. Includes planetary data, gravitational constants, and ephemeris interfaces.","category":"section"},{"location":"components/#[AstroFrames](https://genastro.github.io/Epicycle/AstroFrames/dev/)","page":"Components","title":"AstroFrames","text":"Reference frames and coordinate system transformations. Handles inertial and rotating frames with precise transformation matrices.","category":"section"},{"location":"components/#[AstroModels](https://genastro.github.io/Epicycle/AstroModels/dev/)","page":"Components","title":"AstroModels","text":"Spacecraft and physical models for environmental interactions. Includes drag, solar radiation pressure, and other perturbation models.","category":"section"},{"location":"components/#Mission-Design","page":"Components","title":"Mission Design","text":"High-level capabilities for trajectory design, optimization, and mission analysis.","category":"section"},{"location":"components/#[AstroManeuvers](https://genastro.github.io/Epicycle/AstroManeuvers/dev/)","page":"Components","title":"AstroManeuvers","text":"Maneuver models and algorithms for trajectory modification. Provides impulsive and finite-burn maneuver representations.","category":"section"},{"location":"components/#[AstroCallbacks](https://genastro.github.io/Epicycle/AstroCallbacks/dev/)","page":"Components","title":"AstroCallbacks","text":"Mission analysis utilities for constraints, objectives, and events. Includes stopping conditions, cost functions, and constraint definitions.","category":"section"},{"location":"components/#[AstroProp](https://genastro.github.io/Epicycle/AstroProp/dev/)","page":"Components","title":"AstroProp","text":"Numerical integration and trajectory propagation methods. High-order Runge-Kutta integrators with adaptive stepping and event detection.","category":"section"},{"location":"components/#[AstroSolve](https://genastro.github.io/Epicycle/AstroSolve/dev/)","page":"Components","title":"AstroSolve","text":"Optimization algorithms and constraint solving capabilities. Interfaces with IPOPT and other solvers for trajectory optimization problems.","category":"section"},{"location":"running_examples/#Running-Examples","page":"Running Examples","title":"Running Examples","text":"[Content to be written]\n\nHow to run and understand the example files.","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"[Content to be written]\n\nInstallation instructions for Epicycle and dependencies.","category":"section"},{"location":"why_new_software/#Why-New-Software","page":"Why New Software","title":"Why New Software","text":"[This section needs to be written - comparison with existing tools like GMAT, STK, etc., rationale for new development in Julia, advantages of the modular approach, etc.]","category":"section"},{"location":"why_new_software/#Existing-Tools-Comparison","page":"Why New Software","title":"Existing Tools Comparison","text":"[Compare with GMAT, STK, Orekit, etc.]","category":"section"},{"location":"why_new_software/#Julia-Advantages","page":"Why New Software","title":"Julia Advantages","text":"[Performance, ecosystem, modern language features]","category":"section"},{"location":"why_new_software/#Modular-Architecture-Benefits","page":"Why New Software","title":"Modular Architecture Benefits","text":"[Flexibility, extensibility, focused development]","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#EpicycleGraphics-Design-Specification","page":"EpicycleGraphics Design Specification","title":"EpicycleGraphics Design Specification","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Table-of-Contents","page":"EpicycleGraphics Design Specification","title":"Table of Contents","text":"Features & Roadmap\nArchitecture Principles\nData Ownership\nCore API Design\nAttributes & Customization\nDefault Behaviors\nUse Cases & Examples\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Features-and-Roadmap","page":"EpicycleGraphics Design Specification","title":"Features & Roadmap","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Objects","page":"EpicycleGraphics Design Specification","title":"Objects","text":"Spacecraft (with 3D models)\nStars (from AstroUniverse)\nCelestial Bodies (Earth, Moon, Sun, planets)\nGround Stations\nLabels (for spacecraft and bodies)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Overlays","page":"EpicycleGraphics Design Specification","title":"Overlays","text":"Trajectory (multi-segment support)\nReference Planes (equatorial, ecliptic, orbital)\nSensor Cones (field of view)\nVisibility Masks\nReference Axes (inertial, body-fixed, LVLH)\nVectors (velocity, sun direction, custom)\nMilky Way skybox","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Attributes","page":"EpicycleGraphics Design Specification","title":"Attributes","text":"Colors (RGBA with alpha channel)\nPer-segment trajectory colors (for multi-phase missions, maneuvers)\nCoordinate systems (from AstroFrames: CoordinateSystem with origin and axes types)\nCoordinate frames (for axes display)\nLine widths, sizes, scales\nTransparency/alpha values\nLabels (text, color, size)\nIteration trajectory display (for solver diagnostics)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Animation","page":"EpicycleGraphics Design Specification","title":"Animation","text":"Real-time playback\nPlayback controls: play/pause/stop/step\nVariable speed (faster/slower than real-time)\nTime display and scrubbing\nFPS control","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Version-1.0-MVP-Minimal-Viable-Product","page":"EpicycleGraphics Design Specification","title":"Version 1.0 MVP - Minimal Viable Product","text":"Core Feature: Single Spacecraft Visualization (Use Case 0)\n\nSingle spacecraft with trajectory from history\nEarth with texture (always visible)\nStar field background (always visible)\nEquatorial plane with grid (always visible)\nSpacecraft 3D model (if present in spacecraft.model)\nSpacecraft marker (simple, always visible)\nSpacecraft label showing spacecraft.name (always visible)\nBasic camera controls (GLMakie defaults)\nGCRF coordinate system only (validated, errors on non-GCRF)\n\nExplicitly OUT of V1.0:\n\nMultiple spacecraft\nCustomization (colors, line widths, sizes, alpha, etc.)\nUser control of stars/plane visibility\nAnimation\nMultiple celestial bodies\nOverlays (vectors, axes, custom planes)\nSolver/optimization integration\n2D plotting (Use Case 7)\nMultiple coordinate systems (V1.1+)\nGround stations, sensor cones, custom vectors\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Architecture-Principles","page":"EpicycleGraphics Design Specification","title":"Architecture Principles","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#1.-Separation-of-Concerns","page":"EpicycleGraphics Design Specification","title":"1. Separation of Concerns","text":"Domain data lives in domain modules (AstroModels, AstroUniverse)\nVisualization metadata on domain objects where sensible (textures, models)\nEpicycleGraphics handles scene composition and rendering only","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#2.-Default-Driven-Design","page":"EpicycleGraphics Design Specification","title":"2. Default-Driven Design","text":"Zero configuration produces professional results - smart defaults\nCustomization is explicit and clear - setter functions\nConvention over configuration - sensible choices for common cases","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#3.-Composability","page":"EpicycleGraphics Design Specification","title":"3. Composability","text":"Builder pattern for scene construction\nImmutable domain objects\nMutable view configuration via setters","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#4.-Epicycle-Consistency","page":"EpicycleGraphics Design Specification","title":"4. Epicycle Consistency","text":"Kwargs for flexibility\nTime handling via Time structs\nHistory-based data extraction","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#5.-Appropriate-Abstraction-Levels","page":"EpicycleGraphics Design Specification","title":"5. Appropriate Abstraction Levels","text":"Custom APIs for domain-specific features - spacecraft data extraction, trajectory rendering, color handling\nStandard APIs for standard features - leverage Makie directly for axis labels, legends, grids, fonts, styling\nColorLike everywhere - unified color system across 3D and 2D\nLess code to maintain, better documentation leverage - don't reinvent wheels that Makie already provides\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Data-Ownership","page":"EpicycleGraphics Design Specification","title":"Data Ownership","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#AstroFrames","page":"EpicycleGraphics Design Specification","title":"AstroFrames","text":"Coordinate systems used by View3D:\n\n# CoordinateSystem from AstroFrames defines origin and axes\nstruct CoordinateSystem\n    origin::CelestialBody  # e.g., Earth, Sun, Moon\n    axes::AxesType         # e.g., GCRF(), ITRF(), etc.\nend\n\n# Common axes types:\n# - GCRF() - Geocentric Celestial Reference Frame (inertial)\n# - ITRF() - International Terrestrial Reference Frame (Earth-fixed)\n# - Other axes types as defined in AstroFrames","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#AstroModels","page":"EpicycleGraphics Design Specification","title":"AstroModels","text":"Additions to existing Spacecraft struct:\n\nstruct Spacecraft\n    # ... existing fields ...\n    history::Vector{Vector{Tuple{Time{Float64}, Vector{Float64}}}}\n    model::Union{SpacecraftModel, Nothing}  # NEW - 3D model metadata\nend\n\nstruct SpacecraftModel\n    mesh_path::String      # Path to .obj/.stl/.ply file\n    scale::Float64         # Default size scaling\n    offset::Vec3f          # Model origin offset (optional)\n    rotation::Quaternion   # Default orientation (optional)\nend","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#AstroUniverse","page":"EpicycleGraphics Design Specification","title":"AstroUniverse","text":"Additions to existing CelestialBody:\n\nstruct CelestialBody\n    # ... existing fields (name, radius, μ, etc.) ...\n    texture_path::Union{String, Nothing}  # NEW - texture image path\n    rotation_elements::Union{RotationElements, Nothing}  # For future animation\nend\n\nStar field data:\n\nstruct StarField\n    positions::Vector{Vec3f}     # Pre-computed positions on celestial sphere\n    magnitudes::Vector{Float64}  # Brightness values\n    colors::Vector{RGB}          # Star colors (white/yellow/blue based on type)\nend\n\nstruct Universe\n    # ... existing fields ...\n    stars::Union{StarField, Nothing}  # NEW - star catalog\nend","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#EpicycleGraphics","page":"EpicycleGraphics Design Specification","title":"EpicycleGraphics","text":"Visualization-only structures:\n\nstruct View3D\n    # Object references (domain data)\n    spacecraft::Vector{Spacecraft}\n    celestial_bodies::Vector{CelestialBody}\n    \n    # Visualization primitives (no domain data)\n    planes::Vector{Plane3D}\n    vectors::Vector{Vector3D}\n    axes::Vector{Axes3D}\n    \n    # Universe reference\n    universe::Universe\n    \n    # Display preferences (per-object customization)\n    options::Dict{Any, Dict{Symbol, Any}}\n    \n    # Scene-level settings\n    show_stars::Bool\n    background::Symbol  # :black, :space\n    coordinate_system::CoordinateSystem  # From AstroFrames (default: GCRF origin with GCRF axes)\n    \n    # Internal rendering state (private)\n    _scene::Union{Nothing, Scene}\nend\n\nstruct Plane3D\n    type::Symbol  # :equatorial, :ecliptic, :orbital, :custom\n    reference_body::Union{CelestialBody, Nothing}\n    color::RGBA\n    grid_spacing::Union{Tuple{Float64, Float64}, Nothing}  # (fine, coarse)\nend\n\nstruct Vector3D\n    name::String\n    source::Spacecraft  # Which object it's attached to\n    vector_type::Symbol  # :velocity, :sun, :nadir, :custom\n    color::RGBA\n    scale::Float64\n    vector_func::Union{Function, Nothing}  # (time) -> Vec3 for custom\nend\n\nstruct Axes3D\n    frame::Symbol  # :inertial, :body, :lvlh, :orbital\n    reference::Union{Spacecraft, CelestialBody}\n    colors::Tuple{RGBA, RGBA, RGBA}  # X, Y, Z axis colors\n    length::Float64\n    linewidth::Float64\nend\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Core-API-Design","page":"EpicycleGraphics Design Specification","title":"Core API Design","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Scene-Construction-(Builder-Pattern)","page":"EpicycleGraphics Design Specification","title":"Scene Construction (Builder Pattern)","text":"# Create view with universe reference\nview = View3D(universe)  # Default: GCRF origin with GCRF() axes\n# view = View3D(universe; coordinate_system=CoordinateSystem(Earth, ITRF()))  # ECEF\n\n# Add objects (plural functions accept multiple objects)\nadd_spacecraft!(view, mysat, yoursat)\nadd_bodies!(view, earth, moon)\nadd_planes!(view, (:equatorial, earth), (:ecliptic, sun))\nadd_vectors!(view, (mysat, :velocity), (yoursat, :sun))\nadd_axes!(view, (mysat, :body), (earth, :inertial))\n\n# Can also add single objects\nadd_spacecraft!(view, another_sat)\nadd_bodies!(view, mars)\n\n# Remove objects\nremove_spacecraft!(view, mysat)\nremove_bodies!(view, moon)\n\n# Update display (refresh after modifying object data)\nupdate_display!(view)\n\n# Display with rendering options\ndisplay(view; \n    size = (800, 600),\n    camera_position = :auto,  # or Vec3f(x,y,z)\n    background = :black,\n    time = nothing  # Optional: specific time to display, or nothing for latest/current\n)\n\n# Animate with playback options\nanimate(view;\n    start_time = nothing,  # Auto from earliest in history\n    end_time = nothing,    # Auto from latest in history\n    speed = 10.0,          # 10x real-time\n    show_time = true,      # Display time overlay\n    fps = 30\n)\n# If time extends beyond history, spacecraft simply won't be shown for those times","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Separation-of-\"What\"-from-\"How\"","page":"EpicycleGraphics Design Specification","title":"Separation of \"What\" from \"How\"","text":"Scene content (WHAT): Objects added to View3D\nRendering options (HOW): Kwargs to display() and animate()\nTime range: Auto-detected from spacecraft history\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Attributes-and-Customization","page":"EpicycleGraphics Design Specification","title":"Attributes & Customization","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Philosophy","page":"EpicycleGraphics Design Specification","title":"Philosophy","text":"Smart defaults make common cases beautiful\nKwargs-first for initial setup - declare attributes when adding objects\nSetters for later changes - update attributes after adding (solver iterations, interactive changes)\nFlexible color input, consistent internal representation (ColorLike → RGBA{Float32})\nFirst-class multi-segment support - scalar for uniform, vector for per-segment","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Kwargs-Pattern-(Primary)","page":"EpicycleGraphics Design Specification","title":"Kwargs Pattern (Primary)","text":"# Single spacecraft - simple attributes\nadd_spacecraft!(view, sat1;\n    color = :cyan,\n    linewidth = 2.5,\n    show_model = true,\n    model_scale = 1000.0,\n    show_label = true,  # Shows sat1.name\n    show_iterations = false)  # Default: hide solver iterations\n\n# Single spacecraft - per-segment attributes (multi-phase mission)\nadd_spacecraft!(view, transfer_sat;\n    color = [:red, :orange, :yellow, :green],      # Per-segment colors\n    linewidth = [3.0, 1.5, 1.5, 3.0],              # Thick for burns, thin for coasts\n    alpha = [1.0, 0.8, 0.6, 0.4],                  # Progressive fade\n    show_model = true,\n    show_label = true)  # Shows transfer_sat.name\n\n# Multiple spacecraft - different configurations\nadd_spacecraft!(view,\n    sat1,  # Uses defaults (auto color from palette)\n    sat2;  # Also uses defaults\n    linewidth = 2.0)  # Applied to both\n\nadd_spacecraft!(view, sat3;\n    color = :magenta,\n    linewidth = 3.5,\n    show_model = false,\n    label = \"Debris\")\n\n# Full example with all trajectory attributes\nadd_spacecraft!(view, mission_sat;\n    # Trajectory appearance\n    color = [:red, :orange, :green],     # Or single: :cyan\n    linewidth = [3.0, 2.0, 2.0],         # Or single: 2.5\n    alpha = [1.0, 0.8, 0.6],             # Or single: 1.0\n    \n    # Model display\n    show_model = true,\n    model_scale = 2000.0,\n    \n    # Marker (for distant views)\n    show_marker = true,                  # Or :auto for automatic\n    marker = :circle,\n    marker_size = 10.0,\n    marker_color = :cyan,                # Or :auto to match trajectory\n    \n    # Label\n    show_label = true,                   # Shows mission_sat.name\n    label_color = :white,\n    label_size = 14.0,\n    \n    # Advanced\n    show_attitude = false,\n    show_trajectory = true,\n    show_iterations = false)             # Solver iteration diagnostics","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Iteration-Display","page":"EpicycleGraphics Design Specification","title":"Iteration Display","text":"Purpose: Visualize solver convergence by showing iteration history from solve_trajectory!(...; record_iterations=true)\n\n# Default: show only final trajectory (from spacecraft.history.segments)\nadd_spacecraft!(view, sat;\n    color = :cyan,\n    linewidth = 2.5)\n\n# Enable iteration display (from spacecraft.history.iterations)\nadd_spacecraft!(view, sat;\n    color = :cyan,\n    linewidth = 2.5,\n    show_iterations = true)  # Shows solver iterations behind final trajectory\n\n# Typical diagnostic workflow:\n# 1. Run solve_trajectory! with record_iterations=true\nresult = solve_trajectory!(seq, options; record_iterations=true)\n\n# 2. Visualize convergence\nview = View3D(universe)\nadd_spacecraft!(view, sat; show_iterations=true)\ndisplay(view)  # See how solver converged to solution\n\nImplementation details:\n\nIterations rendered first (background layer) with default styling\nFinal trajectory rendered on top (foreground layer)\nDefault iteration style: gray, thin, semi-transparent (hard-coded for V1.0)\nOnly shown if spacecraft.history.iterations contains data\nIf show_iterations=true but no iteration data exists, silently ignored\n\nFuture enhancements (V1.1+):\n\niteration_color: Custom color for iteration trajectories\niteration_linewidth: Custom line width\niteration_alpha: Custom transparency\nshow_progression: Progressive styling showing convergence pattern","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Setter-Functions-(Secondary-for-changes-after-adding)","page":"EpicycleGraphics Design Specification","title":"Setter Functions (Secondary - for changes after adding)","text":"# Generic attribute setter\nset_attribute!(view, object, attribute::Symbol, value)\n\n# Color convenience setter  \nset_color!(view, object, color)  # For trajectory color\n\n# Use cases for setters:\n# 1. Changing attributes after initial setup\nset_attribute!(view, mysat, :linewidth, 5.0)\nset_color!(view, mysat, :red)  # Change trajectory color\n\n# 2. Solver iterations - update colors during optimization\nfor iteration in solver\n    set_color!(view, current_solution, :gray)  # Dim old solution\n    # ... compute new solution ...\n    set_color!(view, new_solution, :cyan)      # Highlight new\n    update_display!(view)\nend\n\n# 3. Per-segment colors for complex missions\nset_color!(view, mysat, [\n    RGBA(1, 0, 0, 1),     # Phase 1: red\n    RGBA(1, 0.5, 0, 1),   # Phase 2: orange  \n    RGBA(0, 1, 0, 1)      # Phase 3: green\n])","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Kwargs-Defaults","page":"EpicycleGraphics Design Specification","title":"Kwargs Defaults","text":"Smart defaults ensure zero-configuration produces professional results:\n\nSpacecraft:\n\nDEFAULT_SPACECRAFT_KWARGS = (\n    color = :auto,              # Auto-cycle from palette\n    linewidth = 2.0,\n    alpha = 1.0,\n    show_trajectory = :auto,    # true if history exists\n    show_model = :auto,         # true if spacecraft.model !== nothing\n    show_attitude = false,\n    show_marker = :auto,        # true when camera far from spacecraft (model too small)\n    marker = :circle,           # Shape: :circle, :rect, :diamond, :cross, :xcross, etc.\n    marker_size = 8.0,          # Marker size in pixels\n    marker_color = :auto,       # Same as trajectory color if not specified\n    show_label = false,         # Display spacecraft.name as label\n    label_color = :white,\n    label_size = 12.0\n)\n\nCelestial Bodies:\n\nDEFAULT_BODY_KWARGS = (\n    show_texture = :auto,       # true if body.texture_path !== nothing\n    show_axes = false,\n    show_grid = false,\n    grid_spacing = :auto,       # Based on body radius\n    show_label = false,         # Display body.name as label\n    label_color = :white,\n    label_size = 14.0\n)\n\nPlanes:\n\nDEFAULT_PLANE_KWARGS = (\n    color = :auto,              # Depends on plane type (equatorial=green, etc.)\n    alpha = 0.2,\n    grid_spacing = :auto,       # Based on orbit size\n    extent = :auto              # Auto to encompass trajectories\n)\n\nVectors:\n\nDEFAULT_VECTOR_KWARGS = (\n    color = :cyan,\n    scale = 1.0,\n    linewidth = 2.0,\n    arrowsize = :auto           # Based on vector length\n)\n\nAuto-cycling color palette for spacecraft:\n\nDEFAULT_TRAJECTORY_COLORS = [\n    :cyan,      # RGBA(0.0, 1.0, 1.0, 1.0)\n    :magenta,   # RGBA(1.0, 0.0, 1.0, 1.0)\n    :yellow,    # RGBA(1.0, 1.0, 0.0, 1.0)\n    :green,     # RGBA(0.0, 1.0, 0.0, 1.0)\n    :orange,    # RGBA(1.0, 0.5, 0.0, 1.0)\n    :red        # RGBA(1.0, 0.0, 0.0, 1.0)\n]\n# Cycles: sat1=cyan, sat2=magenta, sat3=yellow, sat4=green, sat5=orange, sat6=red, sat7=cyan, ...","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Available-Attributes-(Kwargs)","page":"EpicycleGraphics Design Specification","title":"Available Attributes (Kwargs)","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Spacecraft","page":"EpicycleGraphics Design Specification","title":"Spacecraft","text":"Trajectory appearance:\n\ncolor → ColorLike or Vector{ColorLike} (default: auto from palette, cycles through DEFAULTTRAJECTORYCOLORS)\nlinewidth → Float64 or Vector{Float64} (default: 2.0)\nalpha → Float64 or Vector{Float64} (default: 1.0)\nshow_trajectory → Bool (default: true if history exists)\n\nModel display:\n\nshow_model → Bool (default: true if spacecraft.model !== nothing)\nmodel_scale → Float64 (default: 1.0, multiplies spacecraft.model.scale)\nshow_attitude → Bool (default: false)\n\nMarker (for distant views):\n\nshow_marker → Bool (default: :auto - true when model too small to see)\nmarker → Symbol (default: :circle, options: :rect, :diamond, :cross, :xcross, :utriangle, :dtriangle, etc.)\nmarker_size → Float64 (default: 8.0 pixels)\nmarker_color → ColorLike (default: :auto - same as trajectory color)\n\nLabel:\n\nshow_label → Bool (default: false - displays spacecraft.name from domain object)\nlabel_color → ColorLike (default: :white)\nlabel_size → Float64 (default: 12.0)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Celestial-Body","page":"EpicycleGraphics Design Specification","title":"Celestial Body","text":"Appearance:\n\nshow_texture → Bool (default: true if body.texture_path !== nothing)\nshow_axes → Bool (default: false)\nshow_grid → Bool (default: false)\ngrid_spacing → Tuple{Float64, Float64} (default: auto based on body radius)\n\nLabel:\n\nshow_label → Bool (default: false - displays body.name from domain object)\nlabel_color → ColorLike (default: :white)\nlabel_size → Float64 (default: 14.0)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Plane","page":"EpicycleGraphics Design Specification","title":"Plane","text":"color → ColorLike (default: depends on type - see Reference Planes defaults)\nalpha → Float64 (default: 0.2)\ngrid_spacing → Tuple{Float64, Float64} (default: auto based on orbit size)\nextent → Float64 (default: auto to encompass trajectories)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Vector","page":"EpicycleGraphics Design Specification","title":"Vector","text":"color → ColorLike (default: :cyan)\nscale → Float64 (default: 1.0)\nlinewidth → Float64 (default: 2.0)\narrowsize → Float64 (default: auto based on vector length)\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Default-Behaviors","page":"EpicycleGraphics Design Specification","title":"Default Behaviors","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Kwargs-First-Philosophy","page":"EpicycleGraphics Design Specification","title":"Kwargs-First Philosophy","text":"Primary configuration: kwargs at add_*!() time (declarative)\nSecondary updates: setters after adding (imperative, for solver iterations)\nSmart defaults: zero configuration produces professional results\nPer-segment support: scalar for uniform, vector for per-segment","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Color-Palette-(Auto-Cycling)","page":"EpicycleGraphics Design Specification","title":"Color Palette (Auto-Cycling)","text":"When spacecraft are added without explicit color kwarg, colors auto-cycle from:\n\nDEFAULT_TRAJECTORY_COLORS = [:cyan, :magenta, :yellow, :green, :orange, :red]\n\nFirst spacecraft gets cyan, second gets magenta, etc. Cycles back to cyan after red.","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Visibility-Defaults","page":"EpicycleGraphics Design Specification","title":"Visibility Defaults","text":"Show trajectory if spacecraft has history (show_trajectory = true)\nShow model if spacecraft.model !== nothing (show_model = true)\nShow marker when show_marker = :auto and model appears too small (camera far from spacecraft)\nThreshold: model projected size < ~10 pixels → show marker instead\nCan force with show_marker = true or disable with show_marker = false\nShow texture if body.texture_path !== nothing (show_texture = true)\nShow stars by default (view.show_stars = true)\nDon't show attitude/axes by default (reduces clutter: show_attitude = false)\nDon't show labels by default (add via label kwarg)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Attribute-Polymorphism-(Scalar-vs-Vector)","page":"EpicycleGraphics Design Specification","title":"Attribute Polymorphism (Scalar vs Vector)","text":"Scalar value: applies to all segments uniformly\nadd_spacecraft!(view, sat; color = :cyan, linewidth = 2.0)\nVector value: per-segment (must match number of history segments)\nadd_spacecraft!(view, sat; \n    color = [:red, :orange, :yellow],\n    linewidth = [3.0, 2.0, 2.0])","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Coordinate-System-Defaults","page":"EpicycleGraphics Design Specification","title":"Coordinate System Defaults","text":"Default coordinate system: CoordinateSystem(Earth, GCRF()) (Earth-centered inertial)\nFrom AstroFrames: CoordinateSystem has origin (e.g., Earth, Sun) and axes type (e.g., GCRF(), ITRF())\nAll position/velocity data in spacecraft history assumed to be in this frame\nAlternative: CoordinateSystem(Earth, ITRF()) - Earth-fixed, rotating with Earth\nCoordinate system affects:\nHow trajectories are displayed\nReference plane orientations\nStar field rotation (for ITRF)\nGround station positions","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Scale-Defaults","page":"EpicycleGraphics Design Specification","title":"Scale Defaults","text":"Camera auto-scales to fit the trajectories (not all object like far way planets)\nTrajectory linewidth: 2.0\nModel scale: 1.0 (assumes models are pre-scaled)\nPlane grid spacing: auto based on orbit size\nStar field radius: 10,000,000 km (large enough to appear infinite)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Reference-Planes","page":"EpicycleGraphics Design Specification","title":"Reference Planes","text":"Equatorial: Green, RGBA(0, 1, 0, 0.2)\nEcliptic: Blue, RGBA(0, 0.5, 1, 0.2)\nOrbital: Gray, RGBA(0.5, 0.5, 0.5, 0.2)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Time-Handling","page":"EpicycleGraphics Design Specification","title":"Time Handling","text":"Time range specified in animate() kwargs (starttime, endtime)\nDefault: use union of all spacecraft history time ranges\nIf display time is outside spacecraft history, spacecraft not rendered\nInterpolation between history points as needed\nBodies and stars always rendered (independent of time)\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#2D-Plotting-Integration","page":"EpicycleGraphics Design Specification","title":"2D Plotting Integration","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Time-Series-API-with-AstroCallbacks","page":"EpicycleGraphics Design Specification","title":"Time-Series API with AstroCallbacks","text":"EpicycleGraphics integrates with AstroCallbacks to provide type-safe extraction of time-series data from spacecraft history and celestial bodies.\n\nPrimary API - Full Calc Struct:\n\nplot_timeseries!(ax::Axis, calc::AbstractCalc; color, linewidth, label, kwargs...)\n\nAccepts any Calc type from AstroCallbacks. This is the most flexible form and supports:\n\nOrbitCalc(spacecraft, var_tag; dependency=nothing, coordinate_system=nothing)\nBodyCalc(body, var_tag)\nManeuverCalc(maneuver, spacecraft, var_tag)\n\nConvenience Dispatch - Simple OrbitCalc:\n\nplot_timeseries!(ax::Axis, spacecraft::Spacecraft, var::AbstractOrbitVar; kwargs...)\n\nAutomatically constructs OrbitCalc(spacecraft, var) for simple cases without optional kwargs.\n\nHow it works:\n\nExtracts time values from spacecraft history (or appropriate source)\nEvaluates get_calc(calc) at each time point\nPlots using Makie's lines!() or scatter!() with provided attributes\nReturns plot object for legend integration\n\nSupported kwargs:\n\ncolor → ColorLike (default: :blue)\nlinewidth → Float64 (default: 2.0)\nlinestyle → Symbol (default: :solid, options: :dash, :dot, :dashdot)\nlabel → String (default: nothing, for legend)\nalpha → Float64 (default: 1.0)\nPlus any standard Makie line attributes\n\nTime extraction:\n\nFor OrbitCalc: Extract times from spacecraft.history\nFor BodyCalc: Use provided time range or match other plots\nFor ManeuverCalc: Extract from maneuver and spacecraft context\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Cases-and-Examples","page":"EpicycleGraphics Design Specification","title":"Use Cases & Examples","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-0:-Minimal-MVP-Single-Spacecraft-(V1.0)","page":"EpicycleGraphics Design Specification","title":"Use Case 0: Minimal MVP - Single Spacecraft (V1.0)","text":"# V1.0 MVP: Minimal viable visualization\n# Shows single spacecraft orbit around Earth with stars\n# All visual elements always on, no customization\n\nusing GLMakie\nusing EpicycleGraphics\n\n# Spacecraft must be in GCRF (validated, errors otherwise)\n# Spacecraft must have history for trajectory display\nview = View3D(universe)\nadd_spacecraft!(view, mission_sat)  # Adds Earth automatically\n\n# Simple display - uses all defaults\n# - Stars: always visible\n# - Equatorial plane: always visible\n# - Earth texture: always visible (if available)\n# - Spacecraft model: visible if spacecraft.model exists\n# - Spacecraft marker: always visible\n# - Spacecraft label: always visible (shows mission_sat.name)\ndisplay(view)\n\n# That's it for V1.0 MVP!\n# No customization options in this release\n# Coordinate system assumed/validated as Earth GCRF","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-1:-Simple-Mission-Visualization-(V1.1)","page":"EpicycleGraphics Design Specification","title":"Use Case 1: Simple Mission Visualization (V1.1+)","text":"# Just works - zero configuration, smart defaults\nview = View3D(universe)\nadd_spacecraft!(view, mission_sat)  # Auto: cyan color, linewidth=2.0, shows model if present\nadd_bodies!(view, earth)             # Auto: shows texture if present\ndisplay(view)\n\n# Or with minimal customization\nview = View3D(universe)\nadd_spacecraft!(view, mission_sat; show_label = true)  # Shows mission_sat.name, other defaults apply\nadd_bodies!(view, earth)\ndisplay(view)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-2:-Scene-Attributes-(Stars,-Planes,-Camera)-(V1.1)","page":"EpicycleGraphics Design Specification","title":"Use Case 2: Scene Attributes (Stars, Planes, Camera) (V1.1+)","text":"# Control scene-level display options\nview = View3D(universe)\nadd_spacecraft!(view, sat)\nadd_bodies!(view, earth, moon)\nadd_planes!(view, (:equatorial, earth))\n\n# Scene attributes set at construction or via setters\nview.show_stars = true  # or set in View3D constructor\nview.coordinate_system = earth_icrf  # Earth-Centered Inertial (default)\nview.show_plane = true\n\n# Display with camera and rendering options\ndisplay(view; \n    background = :black,\n    size = (1200, 800),\n    camera_position = Vec3f(50000, 0, 20000),  # Custom view position\n    camera_lookat = Vec3f(0, 0, 0),            # Look at origin\n    camera_up = Vec3f(0, 0, 1)                 # Z-up orientation\n)\n\n# Or use predefined camera views\ndisplay(view; camera_position = :earth_centered)\ndisplay(view; camera_position = :spacecraft_following)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-3:-Overlays-(Vectors,-Axes,-Planes)-(V1.1)","page":"EpicycleGraphics Design Specification","title":"Use Case 3: Overlays (Vectors, Axes, Planes) (V1.1+)","text":"# Add various overlay elements\nview = View3D(universe)\nadd_spacecraft!(view, sat)\nadd_bodies!(view, earth)\n\n# Add reference planes\nadd_planes!(view, (:equatorial, earth), (:ecliptic, sun))\n\n# Add vectors\nadd_vectors!(view, (sat, :velocity), (sat, :sun))\n\n# Add coordinate axes\nadd_axes!(view, (sat, :body), (earth, :inertial))\n\ndisplay(view)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-4:-Models-and-Textures-(V1.1)","page":"EpicycleGraphics Design Specification","title":"Use Case 4: Models and Textures (V1.1+)","text":"# Spacecraft models are defined on the Spacecraft struct in AstroModels\n# Model is automatically displayed if present\nsc_with_model = Spacecraft(\n    # ... spacecraft parameters ...\n    model = SpacecraftModel(\n        mesh_path = \"path/to/spacecraft.obj\",\n        scale = 1000.0,  # Scale factor for model size\n        offset = Vec3f(0, 0, 0),\n        rotation = Quaternion(1, 0, 0, 0)  # Identity rotation\n    )\n)\n\nview = View3D(universe)\nadd_spacecraft!(view, sc_with_model)\nadd_bodies!(view, earth)\n\n# Model is shown by default, can be controlled via attributes\nset_attribute!(view, sc_with_model, :show_model, true)\nset_attribute!(view, sc_with_model, :model_scale, 2000.0)  # Override scale\nset_attribute!(view, sc_with_model, :show_label, true)     # Show spacecraft name\n\n# Celestial body textures are defined in AstroUniverse\n# Earth texture is automatically applied if texture_path is set\nearth = CelestialBody(\n    # ... body parameters ...\n    texture_path = \"path/to/earth_texture.jpg\"\n)\n\n# Texture is shown by default\nadd_bodies!(view, earth)\n\n# Can control texture display\nset_attribute!(view, earth, :show_texture, true)\nset_attribute!(view, earth, :show_axes, false)\n\ndisplay(view)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-5:-Custom-Colors-and-Attributes-(V1.1)","page":"EpicycleGraphics Design Specification","title":"Use Case 5: Custom Colors and Attributes (V1.1+)","text":"# Customize trajectory colors and visual attributes\nview = View3D(universe)\nadd_bodies!(view, earth)\nadd_planes!(view, (:equatorial, earth))\n\n# Single spacecraft - simple uniform attributes\nadd_spacecraft!(view, sat1;\n    color = :white,\n    linewidth = 3.0,\n    alpha = 0.8,\n    show_label = true)  # Shows sat1.name\n\n# Single spacecraft - per-segment attributes (multi-phase mission)\nadd_spacecraft!(view, sat2;\n    color = [:red, :orange, :yellow, :green],    # Launch, transfer, approach, orbit\n    linewidth = [3.0, 2.0, 2.0, 2.5],            # Thicker during burns\n    alpha = [1.0, 0.9, 0.8, 0.7],                # Slight fade over time\n    show_model = true,\n    model_scale = 1500.0,\n    show_label = true,                           # Shows sat2.name\n    label_color = :cyan,\n    label_size = 12.0)\n\n# Multiple spacecraft - mix of default and custom\nadd_spacecraft!(view, \n    sat3,  # Default: auto color from palette, standard linewidth\n    sat4;  # Default: next color from palette\n    show_model = false)  # Both don't show models\n\nadd_spacecraft!(view, sat5;\n    color = RGBColor(255, 128, 0),  # Custom RGB\n    linewidth = 4.0,\n    marker = :diamond,              # Different marker shape\n    marker_size = 12.0,             # Larger marker\n    show_label = true)              # Shows sat5.name\n\ndisplay(view)\n\n# Later: change attributes using setters (e.g., during solver iteration)\nset_color!(view, sat2, :gray)  # Dim previous solution\nset_attribute!(view, sat2, :alpha, 0.3)\nupdate_display!(view)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-6:-Solver/Optimization-Workflow-(V1.2)","page":"EpicycleGraphics Design Specification","title":"Use Case 6: Solver/Optimization Workflow (V1.2+)","text":"# TBD - Showing solver iterations in real-time\n# - Display current iteration with subdued color\n# - Update display as solver progresses\n# - Replace with final solution in bright color\n# Details to be refined based on solver integration needs","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-7:-2D-Data-Plots-(V1.1)","page":"EpicycleGraphics Design Specification","title":"Use Case 7: 2D Data Plots (V1.1+)","text":"# Plot time-series data from spacecraft history using AstroCallbacks\n# Use Makie's Figure/Axis directly for standard plotting features\n# Use Epicycle's plot_timeseries! for domain-specific data extraction with Calc framework\n# ColorLike system works seamlessly with Makie\n# Note: GLMakie handles both 3D and 2D plotting\n\nusing GLMakie\nusing AstroCallbacks\n\nview = View3D(universe)\nadd_spacecraft!(view, sat1, sat2, sat3)\nadd_bodies!(view, earth, moon)\n\n# Create Makie figure and axis directly - no wrappers needed\nfig = Figure(size=(1000, 600))\nax = Axis(fig[1, 1],\n    xlabel = \"Time (MJD)\",\n    ylabel = \"Velocity (km/s)\",\n    title = \"Velocity Comparison\")\n\n# PRIMARY API: Full Calc struct (supports all Calc types and optional kwargs)\n# OrbitCalc with simple variable tag\nplot_timeseries!(ax, OrbitCalc(sat1, VelMag()); \n    color = :cyan,\n    label = \"Sat 1\")\n\n# OrbitCalc with dependency (for relative calculations)\nplot_timeseries!(ax, OrbitCalc(sat2, OutgoingRLA(); dependency=sat1);\n    color = RGBColor(255, 0, 255),   # RGB integer\n    label = \"Sat 2 relative to Sat 1\")\n\n# OrbitCalc with coordinate system (future feature)\n# plot_timeseries!(ax, OrbitCalc(sat3, SMA(); coordinate_system=earth_itrf);\n#     color = HexColor(\"#FFFF00\"),\n#     label = \"Sat 3 SMA in ITRF\")\n\n# BodyCalc for celestial body properties\nplot_timeseries!(ax, BodyCalc(earth, GravParam());\n    color = :green,\n    label = \"Earth μ\")\n\n# CONVENIENCE DISPATCH: Simple OrbitCalc cases (no optional kwargs)\n# Automatically constructs OrbitCalc(spacecraft, var_tag)\nplot_timeseries!(ax, sat1, VelMag();\n    color = :cyan,\n    label = \"Sat 1 (convenience)\")\n\nplot_timeseries!(ax, sat2, SMA();\n    color = :magenta,\n    label = \"Sat 2 SMA\")\n\n# ManeuverCalc requires full struct (no convenience dispatch)\nplot_timeseries!(ax, ManeuverCalc(toi_maneuver, sat3, DeltaVMag());\n    color = :orange,\n    label = \"TOI ΔV magnitude\")\n\n# Makie API: standard plotting features\naxislegend(ax; position=:rt)\nax.xgridvisible = true\nax.ygridvisible = true\n\ndisplay(fig)\n\n# Or display 3D view and 2D plot side-by-side using Makie's layout\nfig2 = Figure(size=(1600, 600))\n# 3D view in left panel (Epicycle renders into Makie axis)\ndisplay(view; figure=fig2[1, 1])\n# 2D plot in right panel\nax2 = Axis(fig2[1, 2], \n    xlabel = \"Time (MJD)\", \n    ylabel = \"Semi-Major Axis (km)\")\n\n# Mix of full Calc and convenience dispatch\nplot_timeseries!(ax2, OrbitCalc(sat1, SMA()); color=:cyan, label=\"Sat 1\")\nplot_timeseries!(ax2, sat2, SMA(); color=:magenta, label=\"Sat 2\")  # Convenience\n\naxislegend(ax2)\ndisplay(fig2)\n\n# ColorLike system is consistent across 3D and 2D\n# All accept: Symbol, RGBA, RGBColor(), HexColor(), NamedColor()\n# Makie handles these natively or via simple conversion","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Use-Case-8:-Animation-(V1.2)","page":"EpicycleGraphics Design Specification","title":"Use Case 8: Animation (V1.2+)","text":"# Animate trajectory over time\nview = View3D(universe)\nadd_spacecraft!(view, probe)\nadd_bodies!(view, earth, mars)\nadd_planes!(view, (:ecliptic, sun))\n\n# Playback controls\nanimate(view;\n    speed = 10.0,        # 10x real-time\n    show_time = true,    # Display time overlay\n    fps = 30,\n    start_time = nothing,  # Auto from history\n    end_time = nothing\n)\n\n# Future: Interactive controls\n# - play/pause/stop/step\n# - time scrubbing\n# - speed adjustment during playback\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Implementation-Notes","page":"EpicycleGraphics Design Specification","title":"Implementation Notes","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Rendering-Pipeline","page":"EpicycleGraphics Design Specification","title":"Rendering Pipeline","text":"Scene setup: Create Makie scene with background\nAdd celestial bodies: Textured spheres from Universe (always rendered)\nAdd stars: Scatter plot from Universe.stars (always rendered)\nAdd trajectories: Multi-segment lines with per-segment colors\nAdd spacecraft models: Load and transform meshes at specified time\nAdd overlays: Planes, vectors, axes\nCamera setup: Auto-scale or user-specified\nFor animation: Update time, interpolate spacecraft states, refresh\nIf time outside history range, spacecraft not rendered for that frame\nCelestial bodies and static elements remain visible","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Multi-Segment-Trajectory-Rendering","page":"EpicycleGraphics Design Specification","title":"Multi-Segment Trajectory Rendering","text":"function render_trajectory!(scene, view, sc)\n    segments = extract_trajectory_segments(sc)\n    segment_colors = get_attribute(view, sc, :trajectory_colors)\n    \n    if segment_colors !== nothing\n        # Per-segment colors\n        for (i, (x, y, z)) in enumerate(segments)\n            color = i <= length(segment_colors) ? segment_colors[i] : segment_colors[end]\n            lines!(scene, x, y, z, color=color, linewidth=...)\n        end\n    else\n        # Single color\n        color = get_attribute(view, sc, :trajectory_color)\n        for (x, y, z) in segments\n            lines!(scene, x, y, z, color=color, linewidth=...)\n        end\n    end\nend","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Camera-Control","page":"EpicycleGraphics Design Specification","title":"Camera Control","text":"Free rotation (default from prototype)\nPredefined views: :earth_centered, :spacecraft_following, :inertial\nManual position: Vec3f(x, y, z)\nZoom control without shifting lookat point\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Open-Questions-for-Review","page":"EpicycleGraphics Design Specification","title":"Open Questions for Review","text":"Animation in V1? Currently stretch goal - should it be core?\nGround stations in V1? Or defer to V1.1?\nColor specification: RGBA only, or allow named colors that convert?\nPlane grid auto-sizing: Algorithm for determining good grid spacing?\nMultiple viewports: Single scene only for V1?\nExport capabilities: Save images/videos in V1 or later?\nInteractive controls: Mouse picking objects, interactive time scrubbing?\n\n","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Version-Roadmap","page":"EpicycleGraphics Design Specification","title":"Version Roadmap","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#V1.0-Minimal-MVP-(Current-Focus-Business-Launch)","page":"EpicycleGraphics Design Specification","title":"V1.0 - Minimal MVP (Current Focus - Business Launch)","text":"Goal: Ship fast, get market feedback, create \"wow factor\"\n\nSingle spacecraft visualization (Use Case 0)\nEarth with texture (always on)\nStar field (always on)\nEquatorial plane (always on)\nSpacecraft model, marker, label (always on)\nGCRF coordinate system only\nNo customization options\nNo animation\nStatic display only\n\nImplementation Priority:\n\nBasic View3D struct\nSingle spacecraft trajectory rendering\nEarth sphere with texture\nStar field scatter plot\nEquatorial plane grid\nSimple display() function","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#V1.1-Customization-and-Multi-Object","page":"EpicycleGraphics Design Specification","title":"V1.1 - Customization & Multi-Object","text":"Goal: Production-ready with flexibility\n\nMultiple spacecraft (Use Case 1)\nAttribute customization (colors, sizes, visibility) (Use Cases 2, 5)\nMultiple celestial bodies\nMultiple reference planes\nUser control of stars/plane visibility\nBuilder API with kwargs\nSetter functions for updates\n2D plotting integration (Use Case 7)\nMulti-segment trajectory colors\nCoordinate system selection (GCRF, ITRF, etc.)","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#V1.2-Overlays-and-Interaction","page":"EpicycleGraphics Design Specification","title":"V1.2 - Overlays & Interaction","text":"Goal: Advanced visualization\n\nVectors and axes overlays (Use Case 3)\nGround stations\nSensor cones (FOV)\nAnimation controls (Use Case 8)\nTime scrubbing\nInteractive camera presets\nSolver/optimization integration (Use Case 6)\nObject picking","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#V2.0-Advanced-Features","page":"EpicycleGraphics Design Specification","title":"V2.0 - Advanced Features","text":"Goal: Professional grade\n\nMultiple viewports\nVideo export\nReal-time updates\nCustom shaders\nVR support (?)\nPerformance optimization","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Uitlities","page":"EpicycleGraphics Design Specification","title":"Uitlities","text":"","category":"section"},{"location":"dev/EpicycleGraphics_Spec/#Color","page":"EpicycleGraphics Design Specification","title":"Color","text":"module EpicycleColor\n\nusing ColorTypes\nusing Colors\n\nexport ColorLike, RGBColor, HexColor, NamedColor\n\n\"Types accepted as colors across Epicycle graphics.\"\nconst ColorLike = Union{Symbol, Colorant}\n\n\"0–1 float RGB(A).\"\nRGBColor(r::Real, g::Real, b::Real; a::Real = 1.0) =\n    RGBA{Float32}(r, g, b, a)\n\n\"0–255 integer RGB(A).\"\nRGBColor(r::Integer, g::Integer, b::Integer; a::Integer = 255) =\n    RGBA{Float32}(r/255, g/255, b/255, a/255)\n\n\"Hex string '#RRGGBB' or '#RRGGBBAA' (with or without leading '#').\"\nfunction HexColor(s::AbstractString)::Colorant\n    s = strip(s)\n    s = startswith(s, \"#\") ? s : \"#\" * s\n    parse(Colorant, s)   # Colors.jl\nend\n\n\"Semantic or named color symbol (Makie-compatible).\"\nNamedColor(name::Symbol) = name\nNamedColor(name::AbstractString) = Symbol(name)\n\nend # module","category":"section"},{"location":"sample_missions/#Sample-Missions","page":"Sample Missions","title":"Sample Missions","text":"[Content to be written]\n\nSample mission workflows and scenarios.","category":"section"},{"location":"getting_help/#Getting-Help","page":"Getting Help","title":"Getting Help","text":"[Content to be written]\n\nWhere to find help, documentation links, community resources.","category":"section"},{"location":"dev/spec_template/#PackageName-–-Spec-(v0.1)","page":"PackageName – Spec (v0.1)","title":"PackageName – Spec (v0.1)","text":"","category":"section"},{"location":"dev/spec_template/#1.-Overview-and-Scope-(What-are-we-building?)","page":"PackageName – Spec (v0.1)","title":"1. Overview and Scope (What are we building?)","text":"Purpose:\n\nIn-scope:\nOut-of-scope:","category":"section"},{"location":"dev/spec_template/#2.-Requirements-(What-we-are-building.)","page":"PackageName – Spec (v0.1)","title":"2. Requirements (What we are building.)","text":"List of abstract, testable requirements describing capabilities:\n\nR1: Must provide [capability]...\nR2: Must support [feature]...\nFocus on WHAT, not HOW\nNo implementation details here","category":"section"},{"location":"dev/spec_template/#3.-Design-(How-we-are-building-it.)","page":"PackageName – Spec (v0.1)","title":"3. Design (How we are building it.)","text":"","category":"section"},{"location":"dev/spec_template/#Core-Components","page":"PackageName – Spec (v0.1)","title":"Core Components","text":"Types:\n\nList key structs/types with brief purpose\nNote mutability where relevant\nExample: Spacecraft - mutable, holds state/time/properties\n\nFunctions:\n\nList key functions/methods with brief purpose\nGroup by category if helpful\nExample: propagate() - integrates equations of motion\n\nPatterns:\n\nCommon usage patterns (constructor patterns, access patterns, etc.)\nExample: OrbitCalc(subject, variable_type) - bind subject to quantity","category":"section"},{"location":"dev/spec_template/#Usage-Examples","page":"PackageName – Spec (v0.1)","title":"Usage Examples","text":"Concrete code examples demonstrating key design patterns and how they satisfy requirements. Each example should:\n\nShow realistic usage\nReference which requirement(s) it addresses\nHighlight key design decisions\n\nExample format:\n\n**UC-1: [Brief Title] (Addresses R1, R3)**\n\nDescription: What this demonstrates\n\nCode:\n[actual code example]\n\nKey Points:\n- Why this pattern\n- What requirement it satisfies\n- Important details","category":"section"},{"location":"dev/spec_template/#Design-Decisions-and-Rationale","page":"PackageName – Spec (v0.1)","title":"Design Decisions and Rationale","text":"Why we chose this approach\nTrade-offs made\nAlternatives considered and rejected\nExample: \"Use closures for event functions because...\"","category":"section"},{"location":"dev/spec_template/#Conventions-and-Constraints","page":"PackageName – Spec (v0.1)","title":"Conventions & Constraints","text":"Naming:\n\nAny package-specific naming patterns\nExample: \"Calc types named by subject: OrbitCalc, ManeuverCalc\"\n\nNumeric Types:\n\nFloat64 default\nAD compatibility requirements\nAny special handling\n\nMutability:\n\nWhat's mutable, what's not\nWhy (e.g., \"Spacecraft mutable for in-place propagation\")\n\nError Handling:\n\nWhen to throw errors vs return sentinels\nValidation points\nError message conventions","category":"section"},{"location":"dev/spec_template/#4.-Package-Interactions-(Where-it-fits)","page":"PackageName – Spec (v0.1)","title":"4. Package Interactions (Where it fits)","text":"Package Dependecies:\nUsed by:\nExample interactions and use cases","category":"section"},{"location":"dev/spec_template/#5.-Testing-(How-we-verify-it)","page":"PackageName – Spec (v0.1)","title":"5. Testing (How we verify it)","text":"","category":"section"},{"location":"dev/spec_template/#Test-categories:","page":"PackageName – Spec (v0.1)","title":"Test categories:","text":"Input Validation\n\nInvalid types rejected\nOut-of-range values caught\nInconsistent combinations detected\nClear error messages provided\n\nCorrectness\n\nCore functionality produces expected results\nAPI contracts honored (e.g., mutability guarantees)\nType stability maintained\nReturn values have correct dimensions/units\n\nNumeric Accuracy\n\nResults match reference values within specified tolerance\nTypical tolerance: 1e-12 for dimensionless, appropriate for units\nReference sources documented (analytical, published data, validated tools)\nKnown numeric edge cases handled (singularities, near-zero, etc.)\n\nIntegration\n\nWorks correctly with dependent packages\nUsed correctly by consuming packages\nCross-package data flows validated\nConversion/compatibility tested\n\nRegression\n\nKnown bugs have test coverage\nIssue number referenced in test\nPrevents reintroduction of fixed bugs","category":"section"},{"location":"dev/spec_template/#Notes:","page":"PackageName – Spec (v0.1)","title":"Notes:","text":"Feature-specific edge cases documented in feature tests, not here\nPerformance benchmarks optional, documented separately if needed","category":"section"},{"location":"package_overview/#Package-Overview","page":"Package Overview","title":"Package Overview","text":"[Content to be written]","category":"section"},{"location":"package_overview/#AstroStates","page":"Package Overview","title":"AstroStates","text":"State representations and conversions.","category":"section"},{"location":"package_overview/#AstroProp","page":"Package Overview","title":"AstroProp","text":"High-fidelity trajectory propagation.","category":"section"},{"location":"package_overview/#AstroSolve","page":"Package Overview","title":"AstroSolve","text":"Trajectory optimization and mission design.","category":"section"},{"location":"package_overview/#AstroCallbacks","page":"Package Overview","title":"AstroCallbacks","text":"Mission analysis calculations and constraints.","category":"section"},{"location":"package_overview/#AstroEpochs","page":"Package Overview","title":"AstroEpochs","text":"High-precision astronomical time systems.","category":"section"},{"location":"package_overview/#AstroUniverse","page":"Package Overview","title":"AstroUniverse","text":"Celestial body models and ephemeris.","category":"section"},{"location":"package_overview/#AstroFrames","page":"Package Overview","title":"AstroFrames","text":"Coordinate systems and transformations.","category":"section"},{"location":"package_overview/#AstroManeuvers","page":"Package Overview","title":"AstroManeuvers","text":"Maneuver planning and execution.","category":"section"},{"location":"package_overview/#AstroModels","page":"Package Overview","title":"AstroModels","text":"Spacecraft and mission modeling.","category":"section"},{"location":"welcome/#Welcome-to-Epicycle","page":"Welcome to Epicycle","title":"Welcome to Epicycle","text":"[Content to be written]\n\nProject overview, aerospace focus, ecosystem introduction.","category":"section"},{"location":"installing_julia/#Installing-Julia?","page":"Installing Julia?","title":"Installing Julia?","text":"[Content to be written]","category":"section"},{"location":"resources_for_julia/#Installing-Julia?","page":"Installing Julia?","title":"Installing Julia?","text":"[Content to be written]","category":"section"},{"location":"complete_examples/#Complete-Examples","page":"End-to-End Examples","title":"Complete Examples","text":"Representative examples are shown below. For the complete set of examples, see the examples folder in the Epicycle package directory.\n\nIntegrated mission simulations and workflows","category":"section"},{"location":"complete_examples/#Propagation-Basics","page":"End-to-End Examples","title":"Propagation Basics","text":"using Epicycle\n\n# Spacecraft\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    #name=\"SC-StopAt\",\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)\n\n# Forces + integrator\ngravity = PointMassGravity(earth,(moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate to periapsis\npropagate!(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=+1))\nprintln(get_state(sat, Keplerian()))\n\n# Propagate to apoapsis\npropagate!(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))\nprintln(get_state(sat, Keplerian()))\n\n# Stop when |r| reaches 7000 km \npropagate!(prop, sat, StopAt(sat, PosMag(), 7000.0))\nprintln(get_state(sat, SphericalRADEC()))       \n\n# Propagate to x-position crossing (increasing)\nsol = propagate!(prop, sat, StopAt(sat, PosX(), 7.5; direction=+1))\nprintln(get_state(sat, Cartesian()))\n\n# Propagate multiple spacecraft with multiple stopping conditions\nsc1 = Spacecraft(); sc2 = Spacecraft() \nstop_sc1_node = StopAt(sc1, PosZ(), 0.0)\nstop_sc2_periapsis = StopAt(sc2, PosDotVel(), 0.0; direction=+1)\npropagate!(prop, [sc1,sc2], stop_sc1_node, stop_sc2_periapsis)","category":"section"},{"location":"complete_examples/#Impulsive-Maneuvers","page":"End-to-End Examples","title":"Impulsive Maneuvers","text":"using Epicycle\n\n# Create a default spacecraft\nsat1 = Spacecraft()\n\n# Create an impulsive maneuver in the Inertial frame\ndeltav2 = ImpulsiveManeuver(\n      axes = Inertial(),\n      g0 = 9.80665,\n      Isp = 250.0,\n      element1 = 0.04,\n      element2 = -0.3,\n      element3 = 0.1\n     )\n\n# Apply the maneuver to the spacecraft\nprintln(\"Initial mass: \", sat1.mass)\nmaneuver!(sat1, deltav2)\nprintln(\"Mass after Inertial maneuver: \", sat1.mass)\nprintln(\"State after Inertial maneuver: \\n\", get_state(sat1, Cartesian()))\n\n# Create an impulsive maneuver in the VNB frame\ndeltav1 = ImpulsiveManeuver(\n      axes = VNB(),\n      g0 = 9.80665,\n      Isp = 250.0,\n      element1 = 0.2,\n      element2 = 0.1,\n      element3 = -0.2\n      )\n\n# Apply the maneuver to the spacecraft\nmaneuver!(sat1, deltav1)\nprintln(\"Mass after VNB maneuver: \", sat1.mass)\nprintln(\"State after VNB maneuver: \\n\", get_state(sat1, Cartesian()))","category":"section"},{"location":"complete_examples/#Hohmann-Transfer","page":"End-to-End Examples","title":"Hohmann Transfer","text":"using Epicycle\n\n# ============================================================================\n# Shared Resources\n# ============================================================================\n\n# Create spacecraft\nsat = Spacecraft(\n            state = KeplerianState(7000.0, 0.001, 0.0, 0.0, 7.5, 1.0), \n            time = Time(\"2020-09-21T12:23:12\", TAI(), ISOT()),\n            name = \"Sat\",\n            )\n\n# Create force models, integrator, and dynamics system\ngravity = PointMassGravity(earth, (moon,sun))  \nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(DP8(); abstol=1e-9, reltol=1e-9, dt=300.0)\nprop    = OrbitPropagator(forces, integ)\n\n# ============================================================================\n# TOI Event - Transfer Orbit Insertion\n# ============================================================================\n\n# Define TOI maneuver\ntoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.1,\n    element2 = 0.2,\n    element3 = 0.3\n)\n\n# Define solver variable for TOI delta-V\ntoi_var = SolverVariable(\n    calc = ManeuverCalc(toi, sat, DeltaVVector()),\n    name = \"toi\",\n    lower_bound = [0.0, 0.0, 0.0],\n    upper_bound = [2.5, 0.0, 0.0],\n)\n\n# Define TOI event struct with event function, solver variables, and constraints\ntoi_fun() = maneuver!(sat, toi) \ntoi_event = Event(\n    name = \"TOI\", \n    event = toi_fun, \n    vars = [toi_var],\n    funcs = []\n)\n\n# ============================================================================\n# Propagation Event - Coast to Apoapsis\n# ============================================================================\n\nprop_fun() = propagate!(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))\nprop_event = Event(\n    name = \"Prop to Apoapsis\", \n    event = prop_fun\n)\n\n# ============================================================================\n# MOI Event - Mission Orbit Insertion\n# ============================================================================\n\n# Define MOI maneuver \nmoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.4,\n    element2 = 0.5,\n    element3 = 0.6\n)\n\n# Define solver variable for MOI delta-V\nmoi_var = SolverVariable(\n    calc = ManeuverCalc(moi, sat, DeltaVVector()),\n    name = \"moi\",\n    lower_bound = [0.0, 0.0, 0.0],\n    upper_bound = [3.0, 0.0, 0.0]\n)\n\n# Define constraints for MOI event\npos_target = 45000.0\npos_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [pos_target],\n    upper_bounds = [pos_target],\n    scale = [1.0],\n)\n\necc_con = Constraint(\n    calc = OrbitCalc(sat, Ecc()),\n    lower_bounds = [0.0],\n    upper_bounds = [0.0], \n    scale = [1.0],\n)\n\n# Define MOI event struct with event function, solver variables, and constraints\nmoi_fun() = maneuver!(sat, moi)\nmoi_event = Event(\n    name = \"MOI\", \n    event = moi_fun,\n    vars = [moi_var],\n    funcs = [pos_con, ecc_con]\n)\n\n# ============================================================================\n# Trajectory Optimization\n# ============================================================================\n\n# Build sequence and solve\nseq = Sequence()\nadd_sequence!(seq, toi_event, prop_event, moi_event)\n\n# Solve the sequence and report the solution\nresult = solve_trajectory!(seq; record_iterations=true)\nreport_sequence(seq)\nreport_solution(seq, result)\n\n# Plot the trajectory 3D\nview = View3D()\nadd_spacecraft!(view, sat; show_iterations=true)\ndisplay_view(view)\n\nThe output of this run:\n\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:        4\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:        2\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        2\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:        2\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  0.0000000e+00 3.74e+04 0.00e+00   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  0.0000000e+00 1.77e+04 1.40e+02  -5.0 1.12e+01    -  4.69e-01 2.18e-01h  3\n   2  0.0000000e+00 3.67e+03 1.25e-01  -0.6 1.55e-01    -  1.00e+00 1.00e+00h  1\n   3  0.0000000e+00 2.35e+02 2.62e-02  -2.6 5.60e-02    -  1.00e+00 1.00e+00h  1\n   4  0.0000000e+00 1.09e+00 3.48e-04  -4.5 4.41e-03    -  9.99e-01 1.00e+00h  1\n   5  0.0000000e+00 2.40e-05 0.00e+00  -6.3 2.21e-05    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 5\n\n                                   (scaled)                 (unscaled)\nObjective...............:   0.0000000000000000e+00    0.0000000000000000e+00\nDual infeasibility......:   0.0000000000000000e+00    0.0000000000000000e+00\nConstraint violation....:   7.2005827011268791e-07    2.3959924874361604e-05\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   4.7560577722374565e-07    4.7560577722374565e-07\nOverall NLP error.......:   7.2005827011268791e-07    2.3959924874361604e-05\n\n\nNumber of objective function evaluations             = 7\nNumber of objective gradient evaluations             = 6\nNumber of equality constraint evaluations            = 10\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 6\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 3.144\n\nEXIT: Optimal Solution Found.\n\nTRAJECTORY SEQUENCE SUMMARY\n==================================================\n\nSequence Overview:\n- Total Events: 3\n- Variable Objects: 2 (6 optimization variables)\n- Constraint Objects: 2 (2 constraint functions)\n- Execution Order: [\"TOI\" → \"Prop to Apoapsis\" → \"MOI\"]\n\nEVENT DETAILS:\n--------------------\n\nEvent 1: \"TOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  └─ toi: DeltaVVector() (ManeuverCalc) (3 components)\n│     ├─  Component 1: ∈ [-10.0, 10.0]\n│     ├─  Component 2: = 0.0\n│     └─  Component 3: = 0.0\n└─ Constraint Objects (0): None\n\nEvent 2: \"Prop to Apoapsis\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 3: \"MOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  ├─ moi: DeltaVVector() (ManeuverCalc) (3 components)\n│  │  ├─  Component 1: ∈ [-10.0, 10.0]\n│  │  ├─  Component 2: = 0.0\n│  │  └─  Component 3: = 0.0\n└─ Constraint Objects (2): 2 constraint functions\n   ├─ PosMag() (OrbitCalc) = 45000.0\n   └─ Ecc() (OrbitCalc) = 0.0\n\nSTATEFUL OBJECTS:\n--------------------\n- ImpulsiveManeuver (×2)\n- Spacecraft\n\n==================================================\n\nTRAJECTORY SOLUTION REPORT\n==================================================\n\nOPTIMIZATION STATUS:\n- Converged: Solve_Succeeded\n- Variable Objects: 2 (6 optimization variables)\n- Constraint Objects: 2 (2 constraint functions)\n\nOPTIMIZATION VARIABLES:\n-------------------------\ntoi (DeltaVVector() (ManeuverCalc)):\n  Component 1: 2.355732 (bounds: [-10.0, 10.0])\n  Component 2: 0.0 (fixed at 0.0)\n  Component 3: 0.0 (fixed at 0.0)\n  Total ΔV: 2.355732\n\nmoi (DeltaVVector() (ManeuverCalc)):\n  Component 1: 1.432696 (bounds: [-10.0, 10.0])\n  Component 2: 0.0 (fixed at 0.0)\n  Component 3: 0.0 (fixed at 0.0)\n  Total ΔV: 1.432696\n\nCONSTRAINT SATISFACTION:\n-------------------------\nEvent \"MOI\":\n  PosMag() (OrbitCalc): 45000.000024 (target: 45000.0)\n  Ecc() (OrbitCalc): 0.0 (target: 0.0)\n\n==================================================","category":"section"},{"location":"complete_examples/#GEO-Transfer","page":"End-to-End Examples","title":"GEO Transfer","text":"using Epicycle\n\n# ============================================================================\n# Shared Resources\n# ============================================================================\n\n# Create spacecraft\nsat = Spacecraft(\n    state = CartesianState([3737.792, -4607.692, -2845.644, 5.411, 5.367, -1.566]),\n    time = Time(\"2000-01-01T11:59:28.000\", UTC(), ISOT()), \n    name = \"GeoSat-1\"\n)\n\n# Create force models, integrator, and propagator\ngravity = PointMassGravity(earth, ())  # Only Earth gravity\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(DP8(); abstol=1e-12, reltol=1e-12, dt=60.0)\nprop    = OrbitPropagator(forces, integ)\n\n# ============================================================================\n# Event 1: Propagate to Equatorial Plane Crossing\n# ============================================================================\n\n# Define propagation event to equatorial plane crossing\nprop_to_z_crossing_1_fun() = propagate!(prop, sat, StopAt(sat, PosZ(), 0.0))\nprop_to_z_crossing_1_event = Event(\n    name = \"Prop to Z 1\",\n    event = prop_to_z_crossing_1_fun,\n)\n\n# ============================================================================\n# Event 2: TOI - Transfer Orbit Insertion\n# ============================================================================\n\n# Define TOI maneuver\ntoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 2.518,\n    element2 = 0.0,\n    element3 = 0.0,\n)\n\n# Define solver variable for TOI delta-V\ntoi_var = SolverVariable(\n    calc = ManeuverCalc(toi, sat, DeltaVVector()),\n    name = \"toi_v\",\n    lower_bound = [0.0, 0.0, 0.0],\n    upper_bound = [8.0, 0.0, 0.0],\n)\n\n# Define TOI event struct with event function, solver variables, and constraints\ntoi_fun() = maneuver!(sat, toi)\ntoi_event = Event(\n    name = \"TOI\",\n    event = toi_fun,\n    vars = [toi_var],\n)\n\n# ============================================================================\n# Event 3: Propagate to Apoapsis\n# ============================================================================\n\n# Define constraint on radius at apoapsis\napogee_radius_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [85000.0],\n    upper_bounds = [85000.0],\n    scale = [1.0],\n)\n\n# Define propagation event to apoapsis with radius constraint\nprop_to_apogee_fun() = propagate!(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))\nprop_to_apogee_event = Event(\n    name = \"Prop to Apoapsis\",\n    event = prop_to_apogee_fun,\n    funcs = [apogee_radius_con],\n)\n\n# ============================================================================\n# Event 4: Propagate to Perigee\n# ============================================================================\n\nprop_to_perigee_1_fun() = propagate!(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))\nprop_to_perigee_1_event = Event(\n    name = \"Prop to Perigee 1\",\n    event = prop_to_perigee_1_fun,\n)\n\n# ============================================================================\n# Event 5: Propagate to Equatorial Plane Crossing Again\n# ============================================================================\n\nprop_to_z_crossing_2_fun() = propagate!(prop, sat, StopAt(sat, PosZ(), 0.0))\nprop_to_z_crossing_2_event = Event(\n    name = \"Prop to Z 2\",\n    event = prop_to_z_crossing_2_fun,\n)\n\n# ============================================================================\n# Event 6: MCC - Mid-Course Correction\n# ============================================================================\n\n# Define MCC maneuver\nmcc = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.559,\n    element2 = 0.588,\n    element3 = 0.0,\n)\n\n# Define solver variable for MCC delta-V\nmcc_var = SolverVariable(\n    calc = ManeuverCalc(mcc, sat, DeltaVVector()),\n    name = \"mcc_vn\",\n    lower_bound = [-1.0, -1.0, -0.001],\n    upper_bound = [4.0, 1.0, 0.001],\n)\n\n# Define MCC event struct with event function and solver variables\nmcc_fun() = maneuver!(sat, mcc)\nmcc_event = Event(\n    name = \"MCC\",\n    event = mcc_fun,\n    vars = [mcc_var],\n)\n\n# ============================================================================\n# Event 7: Propagate to Perigee and Check Constraints\n# ============================================================================\n\n# Define constraints on inclination and perigee radius\ninclination_con = Constraint(\n    calc = OrbitCalc(sat, Inc()),\n    lower_bounds = [deg2rad(2.0)],\n    upper_bounds = [deg2rad(2.0)],\n    scale = [1.0],\n)\n\nperigee_radius_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [42195.0],\n    upper_bounds = [42195.0],\n    scale = [1.0],\n)\n\n# Define propagation event to perigee with inclination and perigee radius constraints\nprop_to_perigee_2_fun() = propagate!(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))\nprop_to_perigee_2_event = Event(\n    name = \"Prop to Perigee 2\",\n    event = prop_to_perigee_2_fun,\n    funcs = [inclination_con, perigee_radius_con],\n)\n\n# ============================================================================\n# Event 8: MOI - GEO Orbit Insertion\n# ============================================================================\n\n# Define MOI maneuver\nmoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.282,\n    element2 = 0.0,\n    element3 = 0.0,\n)\n\n# Define solver variable for MOI delta-V\nmoi_var = SolverVariable(\n    calc = ManeuverCalc(moi, sat, DeltaVVector()),\n    name = \"moi_v\",\n    lower_bound = [-1.0, -0.001, -0.001],\n    upper_bound = [4.0, 0.001, 0.001],\n)\n\n# Define constraint on semi-major axis at GEO\nfinal_sma_con = Constraint(\n    calc = OrbitCalc(sat, SMA()),\n    lower_bounds = [42166.90],\n    upper_bounds = [42166.90],\n    scale = [1.0],\n)\n\n# Define MOI event struct with event function, solver variables, and constraints\nmoi_fun() = maneuver!(sat, moi)\nmoi_event = Event(\n    name = \"MOI\",\n    event = moi_fun,\n    vars = [moi_var],\n    funcs = [final_sma_con],\n)\n\n# ============================================================================\n# Trajectory Optimization\n# ============================================================================\n\nseq = Sequence()\nadd_sequence!(seq, prop_to_z_crossing_1_event, toi_event, prop_to_apogee_event,\n              prop_to_perigee_1_event, prop_to_z_crossing_2_event, mcc_event,\n              prop_to_perigee_2_event, moi_event)\n\n# Set up IPOPT options\nipopt_options = Dict(\n    \"max_iter\" => 1000,\n    \"tol\" => 1e-6,\n    \"output_file\" => \"ipopt_geo_transfer$(rand(UInt)).out\",\n    \"file_print_level\" => 5,\n    \"print_level\" => 5,\n)\nsnow_options = Options(derivatives=ForwardFD(), solver=IPOPT(ipopt_options))\n\n# Solve trajectory optimization with iteration recording enabled\nresult = solve_trajectory!(seq, snow_options; record_iterations=true)\nreport_sequence(seq)\nreport_solution(seq, result)\n\n# Propagate about one day to see final orbit\npropagate!(prop, sat, StopAt(sat, PropDurationDays(), 1.1)) \n\n# Visualize with iterations\nview = View3D()\nadd_spacecraft!(view, sat; show_iterations=true)\ndisplay_view(view)\n\nThe output for this configuration is\n\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:       28\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:        7\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        7\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:        4\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  0.0000000e+00 6.86e+04 0.00e+00   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  0.0000000e+00 5.34e+04 3.38e+00  -1.1 5.54e+00    -  4.81e-01 1.28e-01h  3\n   2  0.0000000e+00 3.23e+04 1.09e+01  -0.8 1.46e+00    -  9.75e-01 2.50e-01h  3\n   3  0.0000000e+00 4.01e+04 1.04e+00  -1.1 3.53e-01    -  7.31e-01 1.00e+00H  1\n   4  0.0000000e+00 7.86e+03 2.52e+00  -1.0 9.37e-01    -  1.00e+00 5.00e-01h  2\n   5  0.0000000e+00 5.46e+02 1.61e-01  -2.0 1.41e-01    -  1.00e+00 1.00e+00h  1\n   6  0.0000000e+00 4.68e+00 2.37e-03  -3.7 2.42e-03    -  1.00e+00 1.00e+00h  1\n   7  0.0000000e+00 3.82e-04 3.54e-05  -5.6 3.54e-05    -  1.00e+00 1.00e+00h  1\n   8  0.0000000e+00 1.18e-07 3.02e-12 -11.0 3.92e-09    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 8\n\n                                   (scaled)                 (unscaled)\nObjective...............:   0.0000000000000000e+00    0.0000000000000000e+00\nDual infeasibility......:   3.0156910335045697e-12    3.0156910335045697e-12\nConstraint violation....:   1.5534043499097701e-09    1.1797237675637005e-07\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   8.2697560462276952e-11    8.2697560462276952e-11\nOverall NLP error.......:   1.5534043499097701e-09    1.1797237675637005e-07\n\n\nNumber of objective function evaluations             = 18\nNumber of objective gradient evaluations             = 9\nNumber of equality constraint evaluations            = 22\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 9\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 2.412\n\nEXIT: Optimal Solution Found.\n\nTRAJECTORY SEQUENCE SUMMARY\n==================================================\n\nSequence Overview:\n- Total Events: 8\n- Variable Objects: 3 (9 optimization variables)\n- Constraint Objects: 4 (4 constraint functions)\n- Execution Order: [\"Prop to Z 1\" → \"TOI\" → ... → \"MOI\"]\n\nEVENT DETAILS:\n--------------------\n\nEvent 1: \"Prop to Z 1\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 2: \"TOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  └─ toi_v: DeltaVVector() (ManeuverCalc) (3 components)\n│     ├─  Component 1: ∈ [-5.0, 5.0]\n│     ├─  Component 2: = 0.0\n│     └─  Component 3: = 0.0\n└─ Constraint Objects (0): None\n\nEvent 3: \"Prop to Apoapsis\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (1): 1 constraint functions\n   └─ PosMag() (OrbitCalc) = 85000.0\n\nEvent 4: \"Prop to Perigee 1\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 5: \"Prop to Z 2\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 6: \"MCC\"\n├─ Variable Objects (1): 3 optimization variables\n│  └─ mcc_vn: DeltaVVector() (ManeuverCalc) (3 components)\n│     ├─  Component 1: ∈ [-2.0, 2.0]\n│     ├─  Component 2: ∈ [-2.0, 2.0]\n│     └─  Component 3: ∈ [-0.001, 0.001]\n└─ Constraint Objects (0): None\n\nEvent 7: \"Prop to Perigee 2\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (2): 2 constraint functions\n   ├─ Inc() (OrbitCalc) = 0.034907\n   └─ PosMag() (OrbitCalc) = 42195.0\n\nEvent 8: \"MOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  ├─ moi_v: DeltaVVector() (ManeuverCalc) (3 components)\n│  │  ├─  Component 1: ∈ [-2.0, 2.0]\n│  │  ├─  Component 2: ∈ [-0.001, 0.001]\n│  │  └─  Component 3: ∈ [-0.001, 0.001]\n└─ Constraint Objects (1): 1 constraint functions\n   └─ SMA() (OrbitCalc) = 42166.9\n\nSTATEFUL OBJECTS:\n--------------------\n- ImpulsiveManeuver (×3)\n- Spacecraft\n\n==================================================\n\nTRAJECTORY SOLUTION REPORT\n==================================================\n\nOPTIMIZATION STATUS:\n- Converged: Solve_Succeeded\n- Variable Objects: 3 (9 optimization variables)\n- Constraint Objects: 4 (4 constraint functions)\n\nOPTIMIZATION VARIABLES:\n-------------------------\ntoi_v (DeltaVVector() (ManeuverCalc)):\n  Component 1: 2.819829 (bounds: [-5.0, 5.0])\n  Component 2: 0.0 (fixed at 0.0)\n  Component 3: 0.0 (fixed at 0.0)\n  Total ΔV: 2.819829\n\nmcc_vn (DeltaVVector() (ManeuverCalc)):\n  Component 1: 0.699575 (bounds: [-2.0, 2.0])\n  Component 2: 0.895256 (bounds: [-2.0, 2.0])\n  Component 3: 0.0 (bounds: [-0.001, 0.001])\n  Total ΔV: 1.136173\n\nmoi_v (DeltaVVector() (ManeuverCalc)):\n  Component 1: -0.480757 (bounds: [-2.0, 2.0])\n  Component 2: -0.0 (bounds: [-0.001, 0.001])\n  Component 3: -0.0 (bounds: [-0.001, 0.001])\n  Total ΔV: 0.480757\n\nCONSTRAINT SATISFACTION:\n-------------------------\nEvent \"Prop to Apoapsis\":\n  PosMag() (OrbitCalc): 85000.0 (target: 85000.0)\n\nEvent \"Prop to Perigee 2\":\n  Inc() (OrbitCalc): 0.034907 (target: 0.034907)\n  PosMag() (OrbitCalc): 42195.0 (target: 42195.0)\n\nEvent \"MOI\":\n  SMA() (OrbitCalc): 42166.9 (target: 42166.9)\n\n==================================================","category":"section"},{"location":"why_julia/#Why-Julia?","page":"Why Julia?","title":"Why Julia?","text":"[Content to be written]","category":"section"},{"location":"graphics/#Graphics-and-Visualization","page":"Graphics","title":"Graphics and Visualization","text":"","category":"section"},{"location":"graphics/#Overview","page":"Graphics","title":"Overview","text":"Epicycle provides 3D visualization capabilities through its graphics module. The graphics system is built on GLMakie for GPU-accelerated rendering and includes:\n\nTrajectory rendering - Automatic rendering from spacecraft history segments\nCAD model loading - Display spacecraft using custom 3D models (.obj files)\nCelestial body rendering - Render Earth, Moon, and other bodies with texture mapping\nIteration history visualization - View optimization solver progress across iterations\nMultiple spacecraft support - Visualize constellations and multi-spacecraft scenarios\n\n(Image: GEO Transfer Trajectory)\n\nExample: GEO transfer trajectory with plane change correction, showing 8-event optimization sequence.","category":"section"},{"location":"graphics/#Installation-and-Requirements","page":"Graphics","title":"Installation & Requirements","text":"The graphics module requires additional dependencies beyond the core Epicycle package:\n\nusing Pkg\nPkg.add([\"GLMakie\", \"FileIO\", \"MeshIO\"])","category":"section"},{"location":"graphics/#Quick-Start","page":"Graphics","title":"Quick Start","text":"The basic workflow consists of three steps: create a view, add spacecraft, and display:\n\nusing Epicycle\n\n# Spacecraft\nsat = Spacecraft(\n    state=KeplerianState(8000.0,0.15,pi/4,pi/2,0.0,pi/2),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n    name = \"sat\",\n)\n\n# Forces + integrator\ngravity = PointMassGravity(earth,(moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate to periapsis\npropagate!(prop, sat, StopAt(sat, PropDurationSeconds(), 5000.0))\nprintln(get_state(sat, Keplerian()))\n\nview = View3D()\nadd_spacecraft!(view,sat)\ndisplay_view(view , size=(1200, 800))\n\nThis creates an interactive 3D view with the spacecraft trajectory rendered over Earth.","category":"section"},{"location":"graphics/#Examples","page":"Graphics","title":"Examples","text":"","category":"section"},{"location":"graphics/#Hohmann-Transfer-with-Solver-Iterations","page":"Graphics","title":"Hohmann Transfer with Solver Iterations","text":"Visualize optimization progress during trajectory design:\n\nusing Epicycle\n\n# [Setup spacecraft, propagator, events as in Ex_HohmannTransfer.jl]\n# ...\n\n# Solve with iteration recording enabled\nresult = solve_trajectory!(seq; record_iterations=true)\n\n# Visualize final solution plus all solver iterations\nview = View3D()\nadd_spacecraft!(view, sat; show_iterations=true)\ndisplay_view(view)\n\nThe show_iterations=true flag renders semi-transparent trajectory segments for each solver iteration, showing how the optimizer converged to the final solution.","category":"section"},{"location":"graphics/#Multiple-Spacecraft-Visualization","page":"Graphics","title":"Multiple Spacecraft Visualization","text":"Visualize constellations or multi-spacecraft missions:\n\nusing Epicycle\n\n# Create three spacecraft in different orbital planes\nsat1 = Spacecraft(\n    state = KeplerianState(7000.0, 0.0, deg2rad(0.0), 0.0, 0.0, 0.0),\n    name = \"Equatorial\"\n)\n\nsat2 = Spacecraft(\n    state = KeplerianState(7000.0, 0.0, deg2rad(45.0), 0.0, 0.0, 0.0),\n    name = \"Inclined-45\"\n)\n\nsat3 = Spacecraft(\n    state = KeplerianState(7000.0, 0.0, deg2rad(90.0), 0.0, 0.0, 0.0),\n    name = \"Polar\"\n)\n\n# Propagate all spacecraft\nfor sat in [sat1, sat2, sat3]\n    propagate!(prop, sat, StopAt(sat, PropDurationDays(), 1.0))\nend\n\n# Visualize all three\nview = View3D()\nadd_spacecraft!(view, sat1)\nadd_spacecraft!(view, sat2)\nadd_spacecraft!(view, sat3)\ndisplay_view(view)","category":"section"},{"location":"graphics/#Using-Custom-CAD-Models","page":"Graphics","title":"Using Custom CAD Models","text":"Display spacecraft with custom 3D models:\n\nusing Epicycle\n\n# Create spacecraft with CAD model\nsat = Spacecraft(\n    state = CartesianState([3737.792, -4607.692, -2845.644, 5.411, 5.367, -1.566]),\n    name = \"Deep Space 1\", \n    cad_model = CADModel(\n        file_path = joinpath(pkgdir(Epicycle), \"assets\", \"DeepSpace1.obj\"),\n        scale = 100.0,\n        visible = true\n    )\n)\n\n# Propagate and visualize\npropagate!(prop, sat, StopAt(sat, PropDurationDays(), 1.0))\n\nview = View3D()\nadd_spacecraft!(view, sat)\ndisplay_view(view)\n\nThe spacecraft CAD model will be rendered at each point along the trajectory. If the model file cannot be loaded, a fallback sphere is rendered instead.","category":"section"},{"location":"graphics/#Coordinate-Systems","page":"Graphics","title":"Coordinate Systems","text":"warning: Coordinate System Matching Required\nThe spacecraft's coordinate system must match the view's coordinate system. Coordinate transformations are not currently supported in the graphics module. If spacecraft and view coordinate systems do not match, a validation error will be raised when calling add_spacecraft!.","category":"section"},{"location":"graphics/#Limitations-and-Planned-Enhancements","page":"Graphics","title":"Limitations and Planned Enhancements","text":"The current release provides core visualization capabilities with smart defaults. Planned enhancements for future releases include:\n\nAnimation Support - Time-dynamic playback with play/pause controls, variable speed, and time scrubbing\nTrajectory Customization - Per-segment colors, line widths, and transparency for multi-phase missions\nMultiple Celestial Bodies - Show multiple celestial bodies in a single view\nOverlay Elements - Velocity vectors, coordinate axes, reference planes (equatorial, ecliptic, orbital), and sensor field-of-view cones\nCoordinate Transformations - Automatic conversion between reference frames (ICRF, ITRF, EME2000, etc.)\n\nCurrent Limitations:\n\nGPU required (no software rendering fallback)\nCentral-body only celestial body rendering\nNo time-dynamic visualization (all trajectories shown simultaneously)\nCAD models must be in .obj format\nCoordinate systems must match between view and spacecraft","category":"section"},{"location":"graphics/#API-Reference","page":"Graphics","title":"API Reference","text":"","category":"section"},{"location":"graphics/#Epicycle.View3D","page":"Graphics","title":"Epicycle.View3D","text":"View3D\n\nContainer for 3D visualization of spacecraft orbits and celestial bodies.\n\nFields\n\ncoord_sys::CoordinateSystem - Coordinate system for the view (default: Earth GCRF)\nspacecraft::Vector{Spacecraft} - Spacecraft to visualize\n_scene::Union{Nothing, Scene} - Internal Makie scene (private)\n\nV1.0 Limitations\n\nSingle spacecraft only\nAll visual elements always on (no customization)\n\nExamples\n\n# Use default Earth GCRF coordinate system\nview = View3D()\nadd_spacecraft!(view, my_spacecraft)\ndisplay(view)\n\n# Specify different coordinate system\nview = View3D(coord_sys=CoordinateSystem(moon, ICRFAxes()))\nadd_spacecraft!(view, lunar_spacecraft)\ndisplay(view)\n\n\n\n\n\n","category":"type"},{"location":"graphics/#Epicycle.add_spacecraft!","page":"Graphics","title":"Epicycle.add_spacecraft!","text":"add_spacecraft!(view::View3D, sc::Spacecraft)\n\nAdd a spacecraft to the 3D view.\n\nArguments\n\nview::View3D - View to add spacecraft to\nsc::Spacecraft - Spacecraft with history to visualize\n\nV1.0 Limitations\n\nOnly supports single spacecraft (replacing existing if called multiple times)\nSpacecraft must have history populated\n\nThrows\n\nArgumentError if spacecraft history is empty\n\nField-Level Validation\n\nThis function validates that the spacecraft has data to visualize. Coordinate system matching is validated at display time.\n\nExamples\n\nview = View3D()\nadd_spacecraft!(view, mission_sat)\n\n\n\n\n\n","category":"function"},{"location":"graphics/#Epicycle.display_view","page":"Graphics","title":"Epicycle.display_view","text":"Base.display(view::View3D; size=(800, 600))\n\nDisplay the 3D visualization.\n\nArguments\n\nview::View3D - View to display\n\nKeyword Arguments\n\nsize::Tuple{Int,Int} - Window size in pixels (default: (800, 600))\n\nV1.0 Features\n\nBlack background with space theme\nCamera controls (rotation, zoom)\nAll elements always visible:\nSpacecraft trajectory\nCentral body with texture (Earth, Moon, or Mars based on coord_sys)\nStar field\nEquatorial plane\nSpacecraft model (if available)\nSpacecraft label\n\nCoupling Validation\n\nValidates that spacecraft coordinate system matches the view coordinate system.\n\nExamples\n\nview = View3D()\nadd_spacecraft!(view, my_spacecraft)\ndisplay_view(view)\n\n\n\n\n\n","category":"function"},{"location":"system_architecture/#System-Architecture","page":"System Architecture","title":"System Architecture","text":"[Content to be written]\n\nHow the Epicycle packages connect and work together.","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Quick-Start","page":"Getting Started","title":"Quick Start","text":"Get up and running with Epicycle in just a few lines of code:\n\nusing Pkg\nPkg.add(\"Epicycle\")\n\nusing Epicycle\n\n# Create spacecraft and define time and state\nsat = Spacecraft(\n    state=KeplerianState(8000.0,0.15,pi/4,pi/2,0.0,pi/2),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    name = \"sat\",\n)\n\n# Define a propagator\ngravity = PointMassGravity(earth,(moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate for 5000 seconds\npropagate!(prop, sat, StopAt(sat, PropDurationSeconds(), 5000.0))\nprintln(get_state(sat, Keplerian()))\n\n# Visualize the orbit\nview = View3D()\nadd_spacecraft!(view,sat)\ndisplay_view(view)\n\nThis example creates an orbit and propagates to periapis","category":"section"},{"location":"getting_started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"Epicycle requires Julia 1.10 or later. \n\nFor installation instructions, see the Julia Downloads page. Platform-specific guides are available for Windows, macOS, and Linux.","category":"section"},{"location":"getting_started/#Installing-VS-Code","page":"Getting Started","title":"Installing VS Code","text":"Visual Studio Code is the recommended editor for using Epicycle. It provides excellent support for Julia through the Julia Language Server, including syntax highlighting, intelligent code completion, debugging, and integrated REPL.\n\nFor complete installation and setup instructions, see the VS Code Julia Tutorial. This guide covers:\n\nInstalling VS Code\nInstalling the Julia extension\nConfiguring the Julia Language Server\nUsing the integrated REPL\nDebugging Julia code  ","category":"section"},{"location":"getting_started/#Installing-Epicycle","page":"Getting Started","title":"Installing Epicycle","text":"","category":"section"},{"location":"getting_started/#From-the-Julia-Package-Registry","page":"Getting Started","title":"From the Julia Package Registry","text":"The easiest way to install Epicycle is through Julia's built-in package manager:\n\nusing Pkg\nPkg.add(\"Epicycle\")\n\nThis will automatically install Epicycle and all its dependencies.","category":"section"},{"location":"getting_started/#Development-Installation","page":"Getting Started","title":"Development Installation","text":"If you want to contribute to Epicycle or need the latest development version:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/GenAstro/Epicycle.jl\")","category":"section"},{"location":"getting_started/#Verification","page":"Getting Started","title":"Verification","text":"Test your installation by running:\n\nusing Epicycle\n\n# Basic functionality test\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)","category":"section"},{"location":"getting_started/#Common-Installation-Issues","page":"Getting Started","title":"Common Installation Issues","text":"Package not found:\n\nEnsure you're using Julia 1.9 or later: julia --version\nUpdate your package registry: Pkg.Registry.update()\n\nDependency conflicts:\n\nStart with a fresh environment: Pkg.activate(temp=true)\nTry installing in isolated environment first\n\nNetwork issues:\n\nIf behind a corporate firewall, configure Julia's package server\nCheck proxy settings in your Julia startup file","category":"section"},{"location":"getting_started/#Getting-Help","page":"Getting Started","title":"Getting Help","text":"If you encounter installation issues:\n\nCheck the GitHub Issues for known problems\nSearch Julia Discourse for installation help\nOpen a new issue with your Julia version and error message","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Once installed, explore the documentation:\n\nUnit Examples - Learn specific concepts\nComplete Examples - See full mission simulations\nComponents - Understand the package structure","category":"section"},{"location":"unit_examples/#Component-Cheat-Sheets","page":"Component Cheat Sheets","title":"Component Cheat Sheets","text":"","category":"section"},{"location":"unit_examples/#A-Julia-Language-Cheat-Sheet","page":"Component Cheat Sheets","title":"A Julia Language Cheat Sheet","text":"A Julia Language Cheat Sheet.","category":"section"},{"location":"unit_examples/#Time-Systems-(AstroEpochs)","page":"Component Cheat Sheets","title":"Time Systems (AstroEpochs)","text":"AstroEpochs provides comprehensive time system handling for astrodynamics applications. It supports multiple time scales (UTC, TAI, TT, TDB) and formats (Julian Date, Modified Julian Date, ISO 8601) with high-precision conversions between them.\n\nusing AstroEpochs\n\n# Create from Julian Date\nt1 = Time(2451545.0, TT(), JD())\n\n# Create from Modified Julian Date  \nt2 = Time(51544.5, UTC(), MJD())\n\n# Create from ISO string\nt3 = Time(\"2000-01-01T12:00:00.000\", TAI(), ISOT())\n\n# Access different representations\nt1.jd        # Julian Date value\nt1.mjd       # Modified Julian Date value  \nt1.isot      # ISO 8601 string\n\n# Convert between scales (creates new Time object)\nt_utc = t1.utc\nt_tdb = t1.tdb\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Orbital-States-(AstroStates)","page":"Component Cheat Sheets","title":"Orbital States (AstroStates)","text":"AstroStates handles spacecraft orbital state representations and conversions between state representations. It supports 10 representations include Cartesian, Keplerian, B-plane and other representations.\n\nusing AstroStates\n\n# Define a Cartesian state\ncart = CartesianState([7000.0, 0.0, 100.0, 0.0, 7.5, 2.5])\n\n# Convert to Keplerian then back to Cartesian\nmu = 398600.4418 \nkep   = KeplerianState(cart, mu)     \ncart2 = CartesianState(kep, mu)     \n\n# Display some state elements\nkep.sma\nkep.raan\n\n# Generate a vector containing the state struct data\nto_vector(kep)\n\n# See a list of all supported representations\nsubtypes(AbstractOrbitState)\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Spacecraft-Modeling-(AstroModels)","page":"Component Cheat Sheets","title":"Spacecraft Modeling (AstroModels)","text":"AstroModels provides the spacecraft model defining properties such as time, state, and mass.\n\nusing AstroModels, AstroStates, AstroEpochs\n\n# Method 1: Using a CartesianState struct\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    mass = 1000.0\n)\n\n# Method 2: Direct construction with OrbitState\nsc2 = Spacecraft(\n    state = OrbitState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03], Cartesian()),\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    mass = 1000.0\n)\n\nSee the full Reference Material for more details. ","category":"section"},{"location":"unit_examples/#Celestial-Bodies-(AstroUniverse)","page":"Component Cheat Sheets","title":"Celestial Bodies (AstroUniverse)","text":"AstroUniverse provides access to celestial body data including gravitational parameters, physical properties, and NAIF identification codes. It includes predefined bodies and supports creation of custom celestial objects for specialized applications and performs translations between coordinate origins. \n\nusing AstroUniverse\n\n# Access predefined celestial bodies\nearth.mu\nvenus.naifid\n\n# Create a custom body\nphobos = CelestialBody(\n    name = \"Phobos\",\n    naifid = 401,                    # NAIF ID for Phobos\n    mu = 7.0875e-4,       # km³/s² (gravitational parameter)\n    equatorial_radius = 11.1,                   # km (mean radius)\n)\n\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Maneuvers-(AstroManeuvers)","page":"Component Cheat Sheets","title":"Maneuvers (AstroManeuvers)","text":"AstroManeuvers provides maneuver modeling capabilities for trajectory modifications. It supports impulsive maneuvers with various coordinate frame options and specific impulse specifications for realistic propulsion modeling.\n\nusing Epicycle\nm = ImpulsiveManeuver(axes=Inertial(), \n                      Isp=300.0, \n                      element1=0.01, \n                      element2=0.0, \n                      element3=0.0)\n\nsc = Spacecraft()\nmaneuver!(sc, m)\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Calculations-Framework-(AstroCallbacks)","page":"Component Cheat Sheets","title":"Calculations Framework (AstroCallbacks)","text":"AstroCallbacks provides a unified calculation framework for extracting and setting orbital parameters, celestial body properties, and maneuver characteristics. It offers a consistent interface for accessing computed quantities across the Epicycle ecosystem.\n\nusing AstroCallbacks, AstroStates, AstroModels\n\n# Create a spacecraft with orbital state\nsc = Spacecraft(state = CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]), \n                time = Time(\"2024-01-01T12:00:00\", UTC(), ISOT()), \n                mass = 1000.0)\n\n# Get semi-major axis from current state\nsma_calc = OrbitCalc(sc, SMA())\na = get_calc(sma_calc)           \nset_calc!(sma_calc, 10000.0)  \n\n# Set target incoming asymptote (rp = 6900, C3 = 14.0)\nhyp = OrbitCalc(sc, IncomingAsymptote())\nset_calc!(hyp, [6900.0, 14.0, 0.0, 0.0, 0.0, 0.0])  \n    \n# Set and get Earth's mu\nmu_calc = BodyCalc(earth, GravParam())\nμ = get_calc(mu_calc)            \nset_calc!(mu_calc, 3.986e5)      \n\n# Set and get maneuver elements\ntoi = ImpulsiveManeuver()\ndvvec_calc = ManeuverCalc(toi, sc, DeltaVVector())\nΔv = get_calc(dvvec_calc)   \nset_calc!(dvvec_calc, [0.2, 0.3, 0.4])\n\nSee the full Reference Material for more details.","category":"section"},{"location":"styleguide/#For-basic-language-usage-style-use-the-idiomatic-julia-style-guidelines-here","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"For basic language usage style use the idiomatic julia style guidelines here","text":"https://docs.julialang.org/en/v1/manual/style-guide/\n\njulia/base/rational.jl at 788b2c77c10c2160f4794a4d4b6b81a95a90940c · JuliaLang/julia\n\nSome important ones  make low level model code look like a math spec (see carttokep.jl) Avoid writing overly-specific types Append ! to names of functions that modify their arguments Avoid confusion about whether something is an instance or a type","category":"section"},{"location":"styleguide/#Function-Style-Guide-and-Example","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Function Style Guide and Example","text":"https://docs.julialang.org/en/v1/manual/style-guide/\nuse mathematical symbols as appropriate inside functions, but not in the interface \nFor inputs that must be differentiable, annotate them using a derived type from Real.  For example state::Vector{<:Real} so ForwardDiff (and other AD tools) can supply Vector{Dual<:Real} seamlessly. Avoid types that are too specific in specific in function interfaces unless they will never change.  The use of Real ensures some type checking, but uses dispatch for fast execution.  \n\n\n\"\"\"\n    kep_to_cart(state::Vector{<:Real}, μ::Real; tol::Float64=1e-12)\n\nConvert a Keplerian state vector to a Cartesian state vector.\n\n# Arguments\n- `state::Vector{<:Real}`: Keplerian elements `[a, e, i, Ω, ω, ν]`\n- `μ`: Gravitational parameter\n- `tol`: Tolerance for singularities like p ≈ 0 (default: 1e-12)\n- `a`: semi-major axis\n- `e`: eccentricity\n- `i`: inclination\n- `Ω`: right ascension of ascending node\n- `ω`: argument of periapsis\n- `ν`: true anomaly\n\n# Returns\nA 6-element vector `[x, y, z, vx, vy, vz]` representing Cartesian position and velocity.\n\n# Example\ncart = kep_to_cart([7000.0, 0.01, pi/4,0.0,0.0,pi/3], 398600.4418)\n\n# Notes\n- Angles must be in radians.\n- Dimensional quantities must be consistent units with μ.\n- Returns a vector of `NaN`s if conversion is undefined.\n\"\"\"\nfunction kep_to_cart(state::Vector{<:Real}, μ::Real; tol::Float64=1e-12)\n    if length(state) != 6\n        error(\"Input vector must have exactly six elements: a, e, i, Ω, ω, ν.\")\n    end\n\n    if μ < tol\n        @warn \"Conversion Failed: μ < tolerance.\"\n        return fill(NaN, 6)\n    end\n\n    # Unpack the elements\n    a, e, i, Ω, ω, ν = state\n\n    # Compute semi-latus rectum: p = a * (1 - e²)\n    p = a * (1.0 - e^2)\n\n    # Check for degenerate orbit (e.g., parabolic or collapsed)\n    if p < tol || abs(1-e) < tol\n        @warn \"Conversion Failed: Orbit is parabolic or singular.\"\n        return fill(NaN, 6)\n    end\n\n    # Compute radial distance: r = p / (1 + e * cos(ν))\n    r = p / (1.0 + e * cos(ν))\n\n    # Position and velocity in perifocal frame \n    factor = sqrt(μ / p)\n    r̄ₚ = [r * cos(ν), r * sin(ν), 0.0]\n    v̄ₚ = [-factor * sin(ν), factor * (e + cos(ν)), 0.0]\n\n    # Precompute sines and cosines for rotation matrix\n    cos_Ω, sin_Ω = cos(Ω), sin(Ω)\n    cos_ω, sin_ω = cos(ω), sin(ω)\n    cos_i, sin_i = cos(i), sin(i)\n\n    # Rotation matrix from perifocal to inertial\n    R = [\n        cos_ω * cos_Ω - sin_ω * cos_i * sin_Ω   -sin_ω * cos_Ω - cos_ω * cos_i * sin_Ω   sin_i * sin_Ω;\n        cos_ω * sin_Ω + sin_ω * cos_i * cos_Ω   -sin_ω * sin_Ω + cos_ω * cos_i * cos_Ω  -sin_i * cos_Ω;\n        sin_ω * sin_i                                    cos_ω * sin_i                   cos_i\n    ]\n\n    # Rotate position and velocity from perifocal to inertial frame\n    pos = R * r̄ₚ\n    vel = R * v̄ₚ \n\n    return vcat(pos, vel)\nend\n\n\n\nNote that the type definition state::Vector{<:Real} is what allows the use of forward mode differentiation here. \n\nusing LinearAlgebra\nusing ForwardDiff\nusing FiniteDiff\nusing AstroStates  # adjust if module name differs\n\nμ = 398600.4418  # km^3/s^2 (example Earth μ)\ndeg2rad(θ) = θ * (pi / 180)\n\n# Keplerian test vector: [a, e, i, Ω, ω, ν]\n# Moderate inclination, small eccentricity, all angles away from singularities\nkep = [\n    7000.0,                 # a (km)\n    0.01,                   # e\n    deg2rad(28.0),          # i\n    deg2rad(40.0),          # Ω\n    deg2rad(15.0),          # ω\n    deg2rad(60.0)           # ν\n]\n\n# Function mapping Keplerian → Cartesian (6 → 6)\nf(x) = AstroStates.kep_to_cart(x, μ)\n\n# ForwardDiff Jacobian (6x6)\nJ_ad = ForwardDiff.jacobian(f, kep)","category":"section"},{"location":"styleguide/#Struct-and-API-Design-Principles-for-Julia-Scientific/Optimization-Code","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Struct and API Design Principles for Julia Scientific/Optimization Code","text":"","category":"section"},{"location":"styleguide/#Summary-Table","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Summary Table","text":"Principle Description\nParametric types Use for performance, type stability, and AD support\nGeneric numeric fields Use F<:Real for AD compatibility\nKeyword constructors All fields as kwargs with defaults for user-facing structs\nDocstrings Describe all fields, kwargs, and provide examples\nCustom show methods Implement for clean REPL output\nAbstract/parametric fields Use for extensibility and flexibility\nValidation Check field values and","category":"section"},{"location":"styleguide/#1.-Performance-and-Type-Stability","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"1. Performance and Type Stability","text":"Use parametric types for numeric fields (e.g., {F<:Real}) when performance, type stability, or AD support is important.\nEnsure all related numeric fields use the same type parameter for consistency and efficiency.","category":"section"},{"location":"styleguide/#2.-Automatic-Differentiation-(AD)-Compatibility","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"2. Automatic Differentiation (AD) Compatibility","text":"Use generic numeric types (F<:Real) for fields that may participate in differentiation.\nAvoid hardcoding types like Float64 for fields that may be used with dual numbers or other AD types.","category":"section"},{"location":"styleguide/#3.-User-Facing-Constructors","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"3. User-Facing Constructors","text":"Provide an outer constructor that accepts all fields as keyword arguments (kwargs), with sensible defaults for each user facing struct. \nThis enables expressive, order-independent struct creation and makes APIs easier to use and maintain.","category":"section"},{"location":"styleguide/#4.-Documentation","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"4. Documentation","text":"Write clear, idiomatic docstrings for all structs and constructors.\nList and describe all fields and keyword arguments.\nInclude at least one usage example.\nAll fields must have range spec or description\nDocument which fields are required and which are optional (with defaults).\nWhen constructors are overloaded, document the core constructor in full detail, then only document the difference in overloaded outer constructors","category":"section"},{"location":"styleguide/#4.1-Validation","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"4.1 Validation","text":"Constructors must validate user inputs against the range spec in the doc string","category":"section"},{"location":"styleguide/#5.-REPL-and-Display-Integration","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"5. REPL and Display Integration","text":"Implement Base.show methods for custom structs to provide concise, readable REPL output.\nOptionally, provide a verbose show(io, ::MIME\"text/plain\", obj) for detailed inspection.","category":"section"},{"location":"styleguide/#6.-Extensibility-and-Flexibility","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"6. Extensibility and Flexibility","text":"Use abstract types for fields that may be extended by users (e.g., AbstractSRPModel).\nPrefer AbstractVector{F} or parametric vectors for fields that may hold different numeric types.","category":"section"},{"location":"styleguide/#7.-Error-Checking-and-Validation","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"7. Error Checking and Validation","text":"Validate individual field constraints when fields are set (e.g., check for correct vector lengths, positive-definite parameters, etc.)\nValidate field coupling and relationships at execution time (e.g., in display(), propagate(), solve())\nProvide informative error messages for invalid input","category":"section"},{"location":"styleguide/#8.-Constructor-Patterns-for-Composition-Structs","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"8. Constructor Patterns for Composition Structs","text":"Different struct types require different constructor patterns based on their usage:","category":"section"},{"location":"styleguide/#Rule-1:-Required-Positional-Arguments","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Rule 1: Required Positional Arguments","text":"Use positional constructors when all inputs are required and there are no reasonable defaults.\n\nAll arguments are required for valid construction\nNo sensible default values exist\nOptional: May provide keyword argument interface for UI consistency\n\nExample:\n\n# Forces require specific configuration\ngravity = PointMassGravity(earth, (moon, sun))\nforces = ForceModel(gravity)\ninteg = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9)\nprop = OrbitPropagator(forces, integ)","category":"section"},{"location":"styleguide/#Rule-2:-Keyword-Arguments-with-Defaults","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Rule 2: Keyword Arguments with Defaults","text":"For structs with many fields that have reasonable defaults, provide defaults in the constructor to allow users to set only what they need.\n\nMost or all fields have sensible defaults\nUsers customize only what they need\nEnables quick prototyping and clear intent\n\nExample:\n\n# Most maneuver parameters have standard defaults\nman = ImpulsiveManeuver(; axes=VNB(), g0=9.81, Isp=300.0, element1=0.0, element2=0.0, element3=0.0)\n\n# User sets only what differs from defaults\nman = ImpulsiveManeuver(element1=1.3, axes=VNB())","category":"section"},{"location":"styleguide/#Rule-3:-Defaults-with-Incremental-Composition-(add!-methods)","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Rule 3: Defaults with Incremental Composition (add! methods)","text":"For user-composed structs, use a constructor with reasonable defaults (possibly with kwargs) to create the base struct, then use add! methods for users to incrementally compose the struct.\n\nStruct is built incrementally over multiple steps\nAll fields have reasonable defaults (like GUI-based tools: GMAT, STK, FreeFlyer)\nComplex validation between parts happens at execution time\nMay have ordering or dependency requirements between composed elements\n\nExample:\n\n# Sequence starts with reasonable defaults\nseq = Sequence()  \nadd_events!(seq, event1, Event[])\nadd_events!(seq, event2, [event1])\n\n# View3D provides default coordinate system\nview = View3D()  # Uses Earth GCRF by default\n# Or user can override\nview = View3D(coord_sys=moon_gcrf)\n# Then compose incrementally\nadd_spacecraft!(view, sc)\ndisplay(view)  # Final validation happens here\n\nKey Principles:\n\nField-level validation in setters/add! methods (e.g., empty checks, bounds)\nCoupling validation at execution time (e.g., coord_sys matching between view and spacecraft)\nMutable structs allow modification after construction\n\n","category":"section"},{"location":"styleguide/#Example:-ImpulsiveManeuver-Struct","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Example: ImpulsiveManeuver Struct","text":"\"\"\"\n    ImpulsiveManeuver(; axes=:VNB, g0=9.81, Isp=300.0, element1=0.0, element2=0.0, element3=0.0)\n\nRepresents an impulsive maneuver in a specified reference frame.\n\n# Keyword Arguments\n- `axes::Symbol = :VNB`: Reference frame for the maneuver (e.g., :VNB, :LVLH, :ICRF).\n- `g0::Real = 9.81`: Standard gravity [m/s²].\n- `Isp::Real = 300.0`: Specific impulse [s].\n- `element1::Real = 0.0`: First maneuver component (e.g., ΔV₁).\n- `element2::Real = 0.0`: Second maneuver component (e.g., ΔV₂).\n- `element3::Real = 0.0`: Third maneuver component (e.g., ΔV₃).\n\n# Example\n\njulia\n\nmutable struct ImpulsiveManeuver{F<:Real}     axes::Symbol     g0::F     Isp::F     element1::F     element2::F     element3::F\n\nfunction ImpulsiveManeuver(axes::Symbol, g0::F, Isp::F, element1::F, element2::F, element3::F) where {F<:Real}\n    new{F}(axes, g0, Isp, element1, element2, element3)\nend\n\nend\n\nfunction ImpulsiveManeuver(;     axes::Symbol = :VNB,     g0::Real = 9.81,     Isp::Real = 300.0,     element1::Real = 0.0,     element2::Real = 0.0,     element3::Real = 0.0 )     F = promote_type(typeof(g0), typeof(Isp), typeof(element1), typeof(element2), typeof(element3))     new{F}(axes, F(g0), F(Isp), F(element1), F(element2), F(element3)) end\n\nfunction Base.show(io::IO, m::ImpulsiveManeuver)     println(io, \"ImpulsiveManeuver(\")     println(io, \"  axes = \", m.axes)     println(io, \"  g0 = \", m.g0)     println(io, \"  Isp = \", m.Isp)     println(io, \"  element1 = \", m.element1)     println(io, \"  element2 = \", m.element2)     println(io, \"  element3 = \", m.element3, \")\") end\n\nman = ImpulsiveManeuver(element1=1.3, axes=:VNB)","category":"section"},{"location":"styleguide/#Differentiable-Array-Constructors-in-Julia","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Differentiable Array Constructors in Julia","text":"When writing code that must be compatible with automatic differentiation (AD) in Julia (e.g., ForwardDiff), always construct arrays (such as identity matrices, zeros, or ones) using the element type of your input data. This ensures that arrays will work with dual numbers or other AD types.\n\n","category":"section"},{"location":"styleguide/#Identity-Matrix","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Identity Matrix","text":"I3 = Matrix{eltype(x)}(I, 3, 3)\nz = zeros(eltype(x), n)\no = ones(eltype(x), n)\n\nfunction foo(x)\n    I3 = Matrix{eltype(x)}(I, 3, 3)\n    z = zeros(eltype(x), 3)\n    o = ones(eltype(x), 3)\n    # ... use I3, z, o in AD-safe computations\nend\n---\n\nFor generic numeric code: write formulas with plain literals (2π, 0.5, 3/2) and rely on promotion; only use zero(T) / one(T) to seed accumulators or typed containers, and allocate results as Vector{T}. Avoid wrapping every constant in T(...)—clarity beats ceremonial generality.\n\nUse state::Vector{<:Real} and μ::Float64 for differentiable conversion/math functions (e.g., orbital element ↔ Cartesian) to keep the signature explicit, simple, and AD‑compatible (ForwardDiff supplies Vector{Dual<:Real} which matches). Don’t generalize to AbstractVector or μ::Real until a concrete need (views, StaticArrays, μ differentiation) arises—add overloads later instead of widening the original. Preserve the element type in outputs by building a literal vector whose entries derive from the inputs. Treat physical degeneracies (parabolic/singular) with a warning and a NaN vector; treat shape/argument misuse with an error. Avoid unnecessary casts; plain literals (1.0, 2π) promote correctly with Duals and BigFloat. Only broaden the interface in response to an observed requirement, not preemptively.\n\n# Docstring format\n\n\"\"\"\n    FUNCTION SIGNATURE\n\nDECLARATIVE ON SENTENCE SUMMARY\n\n\"Arguments\" (for a function) or \"Fields\" for a struct\n- List of items\n\n# Notes:\n   # Do not include how, that may change, just document the contract. \n# Returns (for a function)\n\n# Examples\n\njldoctest Code here (no julia prompts, want to be able to copy and past the whole chunk!!)","category":"section"},{"location":"styleguide/#output","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"output","text":"REPL output goes here\n\n\"\"\"\n\n# Show methods should overload to support future JSON, HTML etc. \n\nfunction show(io::IO, ::MIME\"text/plain\", body::CelestialBody)\n    println(io, \"CelestialBody: \")\n    println(io, \"  name               = \", body.name)\n    println(io, \"  μ                  = \", body.mu)\n    println(io, \"  Equatorial Radius  = \", body.equatorial_radius)\n    println(io, \"  Flattening         = \", body.flattening)\n    println(io, \"  NAIF ID            = \", body.naifid)\nend\n\n# Delegate the generic show to the text/plain variant for print/println.\nfunction show(io::IO, body::CelestialBody)\n    show(io, MIME\"text/plain\"(), body)\nend\n\n---\n\n# Struct Development Checklist\n\nUse this checklist when creating new structs to ensure production-ready, well-tested code. This assumes the struct has been prototyped and the design has been reviewed.\n\n## 1. Design Phase\n- [ ] **Struct name** - PascalCase, descriptive, follows Epicycle conventions (see Naming Conventions)\n- [ ] **Field names** - snake_case for multi-word, consistent with ecosystem patterns\n- [ ] **Field types** - Use parametric types (`F<:Real`) for numeric fields that may be differentiated\n- [ ] **Constructor pattern** - Choose appropriate pattern (positional, kwargs with defaults, or incremental composition)\n- [ ] **Mutability** - Choose `struct` (immutable) or `mutable struct` based on usage pattern\n\n## 2. Documentation Phase\n- [ ] **Struct docstring** - Describes purpose and usage with signature showing constructor\n- [ ] **Field documentation** - Each field documented with type and valid range/constraints\n- [ ] **Examples** - At least one working example in docstring (use `jldoctest` when appropriate)\n- [ ] **Constructor variants** - Document all public constructor signatures\n- [ ] **Range specifications** - All numeric fields have documented valid ranges (e.g., \"must be positive\", \"0.0 to 1.0\")\n\n## 3. Implementation Phase\n- [ ] **Struct definition** - Inner constructor if needed for validation or type promotion\n- [ ] **Outer constructors** - Keyword constructor with defaults for user-facing structs\n- [ ] **Validation logic** - Constructor validates inputs against documented range specifications\n- [ ] **Error messages** - Clear, actionable `ArgumentError` messages cite field name and constraint\n- [ ] **Base.show method** - Implements clean REPL display (use `MIME\"text/plain\"` variant)\n- [ ] **Base.deepcopy** - Implement if struct contains mutable fields or is itself mutable\n- [ ] **Exports** - Add to package module exports list\n\n## 4. Testing Phase\n- [ ] **Happy path tests** - Verify default constructor and valid field combinations work\n- [ ] **Validation tests** - Test each constraint with `@test_throws ArgumentError`\n- [ ] **Edge cases** - Test boundary values (zero, negative, empty strings, etc.)\n- [ ] **Error messages** - Verify error messages contain expected substrings\n- [ ] **Type promotion** - Test with different numeric types if parametric (Float64, Int, ForwardDiff.Dual)\n- [ ] **Show method** - Test REPL output format matches expected structure\n- [ ] **Integration tests** - Test struct usage in broader package context (if applicable)\n\n## 5. Integration Phase\n- [ ] **Package documentation** - Add to package README or docs with system-level examples\n- [ ] **Epicycle docs** - Add examples to main Epicycle documentation if appropriate\n- [ ] **Update related code** - Modify dependent code that uses or composes this struct\n- [ ] **Update tests** - Update integration tests in dependent packages\n- [ ] **Code review** - Have design and implementation reviewed by another developer\n\n## 6. Quality Checks\n- [ ] **Naming consistency** - Compare field names with similar structs in ecosystem\n- [ ] **No typos** - Run spell check on docstrings and comments\n- [ ] **Type stability** - Verify `@code_warntype` shows no type instabilities (for performance-critical code)\n- [ ] **Test coverage** - All code paths exercised by tests\n- [ ] **Documentation builds** - Verify package docs build without warnings\n\n## Quick Reference: Constructor Patterns\n\n**Pattern 1 - Required Positional:**\n\njulia","category":"section"},{"location":"styleguide/#All-fields-required,-no-defaults","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"All fields required, no defaults","text":"ForceModel(gravity::Gravity, drag::Drag)\n\n\n**Pattern 2 - Keyword with Defaults:**\n\njulia","category":"section"},{"location":"styleguide/#Most-fields-have-defaults,-users-customize-as-needed","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Most fields have defaults, users customize as needed","text":"ImpulsiveManeuver(; axes=VNB(), g0=9.81, Isp=300.0, element1=0.0)\n\n\n**Pattern 3 - Defaults + Incremental Composition:**\n\njulia","category":"section"},{"location":"styleguide/#Start-with-defaults,-build-incrementally-with-add!-methods","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Start with defaults, build incrementally with add! methods","text":"seq = Sequence() add_events!(seq, event1, Event[])\n\n\nSee \"Constructor Patterns for Composition Structs\" section for detailed guidance.\n\n# Naming Conventions\n\nConsistent naming conventions improve code readability, maintainability, and reduce cognitive load across the Epicycle ecosystem.\n\n## General Principles\n\n1. **Clarity over brevity** - Use full words rather than abbreviations unless the abbreviation is universally understood in the domain (e.g., `mu` for gravitational parameter, `SRP` for solar radiation pressure)\n2. **snake_case for multi-word fields** - Use underscores to separate words in field names for readability\n3. **Lowercase for simple field names** - Single-word fields use lowercase (e.g., `state`, `time`, `mass`, `name`)\n4. **Consistent terminology** - Use the same term for the same concept across all structs\n\n## Field Naming Patterns\n\n### Multi-word Fields\nUse `snake_case` (underscores) to separate words:\n\njulia coordsys          # Not coordSys or coordsys lowerbound        # Not lowerBound or lowerbound upperbound        # Not upperBound or upperbound filepath          # Not filePath or filepath model_scale        # Not modelScale\n\n\n### Common Field Names\nStandardize on these names for consistency across structs:\n\n| Concept | Field Name | Example | Notes |\n|---------|-----------|---------|-------|\n| Name/identifier | `name` | `\"MySpacecraft\"` | String identifier for user reference |\n| File path | `file_path` | `\"assets/model.obj\"` | Full or relative path to a file |\n| Coordinate system | `coord_sys` | `CoordinateSystem(earth, ICRFAxes())` | Abbreviated but widely used |\n| Scale factor | `scale` | `1.0` | Dimensionless scaling parameter |\n| Visibility flag | `visible` | `true` | Boolean for display control |\n| Time/epoch | `time` | `Time(...)` | Temporal point or epoch |\n| State vector | `state` | `CartesianState(...)` | Orbital or physical state |\n| Mass | `mass` | `1000.0` | Total mass in kg |\n| Lower bound | `lower_bound` | `[-5.0, -2.0, 0.0]` | Optimization lower bounds |\n| Upper bound | `upper_bound` | `[5.0, 2.0, 0.0]` | Optimization upper bounds |\n\n### Boolean Fields\n- Prefer simple descriptive names: `visible`, `active`, `enabled`\n- Use `is_` prefix only when clarity requires it: `is_converged`, `is_valid`\n- Avoid negative booleans: use `enabled` not `disabled`\n\nExamples:\n\njulia visible::Bool      # Clear without prefix active::Bool       # Clear without prefix is_converged::Bool # Prefix adds clarity for state checks\n\n\n### Abbreviations\nAcceptable abbreviations (use sparingly and consistently):\n- `coord_sys` - coordinate system (widely used)\n- `mu` or `μ` - gravitational parameter (standard in astrodynamics)\n- `Isp` - specific impulse (standard)\n- `SRP` - solar radiation pressure (standard)\n- `num` prefix - for counts (e.g., `numvars`, but prefer `num_vars` for new code)\n\nAvoid abbreviations unless words have many characters:\n- `path` (not `pth`)\n- `model` (not `mdl`)\n- `scale` (not `scl`)\n- `visible` (not `vis`)\n\nAvoid: `file`, `filename`, `path` alone (ambiguous)\n\n### Numeric Suffixes\nWhen fields represent ordered elements or components:\n\njulia element1, element2, element3  # Maneuver components\n\n\nFor multiple similar items, prefer vectors or collections:\n\njulia tanks::Vector{Tank}           # Not tank1, tank2, tank3 thrusters::Vector{Thruster}   # Not thruster1, thruster2\n\n\n## Struct Naming\n\n- Use **PascalCase** for struct names: `Spacecraft`, `ImpulsiveManeuver`, `CoordinateSystem`\n- Be descriptive: `CartesianState` not `CartState`, `OrbitPropagator` not `Propagator`\n- Use full words: `Integrator` not `Integ` (exceptions: widely understood abbreviations)\n\n## Function Naming\n\nFollow Julia conventions:\n- **lowercase with underscores**: `kep_to_cart`, `add_spacecraft!`, `to_posvel`\n- **Append `!` for mutating functions**: `set_posvel!`, `add_events!`, `push_segment!`\n- **Verb-noun order**: Use `verb_noun` pattern for clarity and consistency\n  - ✓ **Correct**: `solve_trajectory`, `display_view`, `propagate_orbit`, `compute_state`\n  - ✗ **Avoid**: `trajectory_solve`, `view_display`, `orbit_propagate`\n  - The action (verb) should come first, followed by the object (noun)\n  - Exception: conversion functions use `to_` prefix: `kep_to_cart`, `cart_to_kep`\n\n### Legacy Naming\n\nSome existing functions use noun_verb order and will be updated in future refactors:\n- `trajectory_solve` → should be `solve_trajectory` (TODO: refactor with alias for backward compatibility)\n\n## Internal/Private Fields\n\nPrefix with underscore to indicate internal use:\n\njulia _scene::Union{Nothing, Scene}  # Internal graphics state _cache::Dict                    # Internal cached data\n\n\n## Inspecting Existing Naming Patterns\n\nBefore creating new structs or fields, review existing naming patterns for consistency. Use this snippet to inspect field names:\n\n\njulia using Epicycle","category":"section"},{"location":"styleguide/#Add-structs-you-want-to-inspect","page":"For basic language usage style use the idiomatic julia style guidelines here","title":"Add structs you want to inspect","text":"structstoinspect = [     Spacecraft, ImpulsiveManeuver, Event, SolverVariable,      Sequence, CoordinateSystem, CelestialBody, ForceModel ]\n\nfor T in structstoinspect     println(\"\\n\", T, \":\")     if !isabstracttype(T) && fieldcount(T) > 0         for fname in fieldnames(T)             println(\"  \", fname)         end     end end\n\n\nThis helps you identify existing patterns and maintain consistency across the codebase.\n\n## Migration Notes\n\nExisting inconsistencies to address in future refactors:\n- `numvars` → consider `num_vars` for consistency with `lower_bound`, `upper_bound`\n- Review any abbreviated field names against the clarity principle\n\n## Examples\n\n### Good Field Names\n\njulia struct Spacecraft     state::OrbitState     time::Time     mass::Float64     name::String     coord_sys::CoordinateSystem     history::Vector{Segment} end\n\nstruct CADModel     file_path::String     scale::Float64     visible::Bool end\n\nstruct SRPModel     area::Float64     reflectivity::Float64     file_path::String  # For plate model file end\n\n\n### Avoid\n\njulia struct BadExample     st::OrbitState          # Too abbreviated     coordSys::CoordSys      # camelCase inconsistent     fileName::String        # camelCase     vis::Bool               # Too abbreviated     lowerbound::Vector      # Missing underscore end ```","category":"section"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"Welcome to Epicycle, an application for space mission analysis, trajectory optimization, and navigation. \n\nEpicycle provides an integrated application for astrodynamics analysis with focus on breadth and extensible interfaces. The system covers orbital state representations, coordinate transformations, trajectory propagation, and optimization.\n\nThe system handles Cartesian, Keplerian, and Modified Equinoctial orbital elements. Trajectory propagation uses Julia's differential equation solvers. Optimization connects SNOW algorithms with IPOPT.\n\nCurrent implementation emphasizes application integration over individual model depth. Interfaces are designed for systematic expansion of the model library.","category":"section"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"Epicycle is a comprehensive Julia package ecosystem for astrodynamics and space mission design. Built with a modular architecture, it provides a complete suite of tools for orbital mechanics, spacecraft trajectory analysis, and mission planning workflows.\n\nThe ecosystem consists of 11 specialized packages that work together to provide everything from fundamental astronomical calculations to advanced trajectory optimization:\n\nFoundation Layer: EpicycleBase (frames & constants), AstroStates (spacecraft states), AstroEpochs (time systems)\nDynamics Layer: AstroDynamics (propagation), AstroForces (force modeling), AstroSimulation (mission simulation)  \nAnalysis Layer: AstroTrajectories (orbital analysis), AstroManeuvers (spacecraft maneuvers), AstroEvents (mission events)\nMission Layer: AstroMissions (mission design), AstroOptimization (trajectory optimization)\nIntegration Layer: Epicycle (unified interface and workflows)","category":"section"},{"location":"overview/#Why-New-Software?","page":"Overview","title":"Why New Software?","text":"The astrodynamics field has historically relied on legacy Fortran codebases and proprietary tools that create barriers to innovation and collaboration. Existing open-source solutions often suffer from fragmentation, limited extensibility, or performance constraints.","category":"section"},{"location":"overview/#Modern-Architecture-Needs","page":"Overview","title":"Modern Architecture Needs","text":"Contemporary space missions require:\n\nScalable Performance: Handle everything from CubeSat missions to interplanetary trajectories\nModular Design: Compose mission-specific analysis workflows from reusable components  \nOpen Collaboration: Enable researchers and engineers to build upon shared foundations\nRapid Prototyping: Quickly test new algorithms and mission concepts\nIntegration Flexibility: Work seamlessly with modern data science and optimization tools","category":"section"},{"location":"overview/#Julia-Ecosystem-Advantages","page":"Overview","title":"Julia Ecosystem Advantages","text":"Julia provides unique benefits for astrodynamics applications:\n\nPerformance: Near-C/Fortran speeds with high-level expressiveness\nComposability: Multiple dispatch enables seamless package integration\nScientific Computing: Native differential equations, optimization, and automatic differentiation\nGrowing Ecosystem: Active scientific computing community with modern tooling\n\nEpicycle bridges the gap between specialized astrodynamics knowledge and modern computational capabilities.","category":"section"},{"location":"overview/#Design-Philosophy","page":"Overview","title":"Design Philosophy","text":"Epicycle is built around three core principles:","category":"section"},{"location":"overview/#Modularity-and-Composability","page":"Overview","title":"Modularity & Composability","text":"Each package focuses on a specific domain while maintaining clean interfaces. Users can combine components to build custom workflows without unnecessary complexity.","category":"section"},{"location":"overview/#Performance-and-Scalability","page":"Overview","title":"Performance & Scalability","text":"From preliminary mission design to high-fidelity simulation, Epicycle scales efficiently across problem sizes while maintaining numerical accuracy.","category":"section"},{"location":"overview/#Extensibility-and-Interoperability","page":"Overview","title":"Extensibility & Interoperability","text":"Open architecture allows researchers to extend capabilities and integrate with existing tools and datasets seamlessly.","category":"section"},{"location":"overview/#Software-Architecture","page":"Overview","title":"Software Architecture","text":"","category":"section"},{"location":"overview/#Package-Hierarchy","page":"Overview","title":"Package Hierarchy","text":"Package Purpose\nEpicycleBase Core abstractions and type hierarchy\nAstroStates Orbital state representations and conversions\nAstroEpochs Time systems and epoch handling\nAstroUniverse Celestial body models and ephemeris\nAstroFrames Coordinate systems and transformations\nAstroModels Spacecraft and physical models\nAstroManeuvers Maneuver models and algorithms\nAstroCallbacks Quantities used in I/O, stopping conditions, cost, constraints\nAstroProp Trajectory propagation algorithms\nAstroSolve Optimization and constraint solving\nEpicycle The application.  using Epicycle loads everything.","category":"section"},{"location":"overview/#Dependency-Structure","page":"Overview","title":"Dependency Structure","text":"The packages are organized in layers to ensure clean separation of concerns:\n\nFoundation: Core types and constants that all other packages depend on\nDomain Specific: Specialized functionality for states, time, coordinates, etc.\nAnalysis Tools: Higher-level capabilities built on foundation components\nIntegration: User-facing interfaces and complete workflows","category":"section"},{"location":"overview/#Key-Features","page":"Overview","title":"Key Features","text":"","category":"section"},{"location":"overview/#Comprehensive-Force-Modeling","page":"Overview","title":"Comprehensive Force Modeling","text":"Gravitational perturbations (J2-J6, third-body, solid tides)\nAtmospheric drag with exponential and NRLMSISE-00 models\nSolar radiation pressure with cylindrical and spherical Earth shadow models\nRelativistic effects for high-precision applications","category":"section"},{"location":"overview/#Advanced-Propagation-Methods","page":"Overview","title":"Advanced Propagation Methods","text":"High-order Runge-Kutta integrators with adaptive stepping\nSpecialized methods for different orbit regimes\nEvent detection and handling during propagation\nParallel processing for large trajectory sets","category":"section"},{"location":"overview/#Mission-Design-Tools","page":"Overview","title":"Mission Design Tools","text":"Lambert problem solvers for transfer trajectory design\nManeuver planning and optimization\nLaunch window analysis\nGround track and coverage analysis","category":"section"},{"location":"overview/#Modern-Development-Practices","page":"Overview","title":"Modern Development Practices","text":"Comprehensive test coverage across all packages\nContinuous integration and automated testing\nClear documentation with worked examples\nType-stable implementations for optimal performance","category":"section"},{"location":"overview/#Licensing-Model","page":"Overview","title":"Licensing Model","text":"We believe in the power of open source to foster innovation and community-driven  development and also recognize the need for a sustainable business model and a model that can handle export-controlled aerospace content. \n\nFor these reasons, Epicycle is offered under a tri-licensing model. The license allows users to choose between the following three options:\n\nLGPL v3.0\nEvaluation and Education use Only\nCommercial License","category":"section"},{"location":"overview/#Acknowledgments","page":"Overview","title":"Acknowledgments","text":"Epicycle builds upon the foundational work of many contributors to the aerospace and scientific computing communities:\n\nAstrodynamics Standards\n\nNASA GMAT Development Team for orbital mechanics algorithms and validation test cases\nDavid Vallado for \"Fundamentals of Astrodynamics and Applications\" formulations\nThe Astropy Project for rigorous time system standards and implementations\n\nJulia Scientific Computing Ecosystem\n\nSciML Organization for OrdinaryDiffEq.jl and the broader differential equations ecosystem\nJulia Astro community for SPICE.jl and astronomical coordinate systems\nBYU FLOW Lab for SNOW.jl optimization framework\nWächter & Biegler for the IPOPT nonlinear programming solver\n\nOpen Source Foundations\n\nJulia Computing and contributors for the Julia language\nThe Documenter.jl team for documentation generation\nGitHub Actions and the CI/CD community for automated testing infrastructure\n\nWe gratefully acknowledge these projects and their maintainers, whose work makes Epicycle possible.","category":"section"},{"location":"overview/#Contributing","page":"Overview","title":"Contributing","text":"To protect both contributors and our company, we use the Linux Kernel's Developer's  Certificate of Origin (DCO) as detailed in CONTRIBUTING.txt.","category":"section"},{"location":"overview/#Getting-Started","page":"Overview","title":"Getting Started","text":"New users should begin with the Getting Started guide, which walks through installation and basic usage patterns. The Tutorials section provides hands-on examples for common astrodynamics tasks.\n\nFor developers interested in extending Epicycle, each package maintains its own documentation with implementation details and contribution guidelines.","category":"section"},{"location":"overview/#Software-Architecture-2","page":"Overview","title":"Software Architecture","text":"","category":"section"},{"location":"overview/#Package-Hierarchy-2","page":"Overview","title":"Package Hierarchy","text":"Package Purpose\nEpicycleBase Core abstractions and type hierarchy\nAstroStates Orbital state representations and conversions\nAstroEpochs Time systems and epoch handling\nAstroUniverse Celestial body models and ephemeris\nAstroFrames Coordinate systems and transformations\nAstroModels Spacecraft and physical models\nAstroManeuvers Maneuver models and algorithms\nAstroCallbacks Quantities used in I/O, stopping conditions, cost, constraints\nAstroProp Trajectory propagation algorithms\nAstroSolve Optimization and constraint solving\nEpicycle The application.  using Epicycle loads everything.","category":"section"},{"location":"overview/#Dependency-Structure-2","page":"Overview","title":"Dependency Structure","text":"The packages are organized in layers to ensure clean separation of concerns:\n\nFoundation: Core types and constants that all other packages depend on\nDomain Specific: Specialized functionality for states, time, coordinates, etc.\nAnalysis Tools: Higher-level capabilities built on foundation components\nIntegration: User-facing interfaces and complete workflows","category":"section"},{"location":"overview/#Key-Features-2","page":"Overview","title":"Key Features","text":"","category":"section"},{"location":"overview/#Comprehensive-Force-Modeling-2","page":"Overview","title":"Comprehensive Force Modeling","text":"Gravitational perturbations (J2-J6, third-body, solid tides)\nAtmospheric drag with exponential and NRLMSISE-00 models\nSolar radiation pressure with cylindrical and spherical Earth shadow models\nRelativistic effects for high-precision applications","category":"section"},{"location":"overview/#Advanced-Propagation-Methods-2","page":"Overview","title":"Advanced Propagation Methods","text":"High-order Runge-Kutta integrators with adaptive stepping\nSpecialized methods for different orbit regimes\nEvent detection and handling during propagation\nParallel processing for large trajectory sets","category":"section"},{"location":"overview/#Mission-Design-Tools-2","page":"Overview","title":"Mission Design Tools","text":"Lambert problem solvers for transfer trajectory design\nManeuver planning and optimization\nLaunch window analysis\nGround track and coverage analysis","category":"section"},{"location":"overview/#Modern-Development-Practices-2","page":"Overview","title":"Modern Development Practices","text":"Comprehensive test coverage across all packages\nContinuous integration and automated testing\nClear documentation with worked examples\nType-stable implementations for optimal performance","category":"section"},{"location":"overview/#Licensing-Model-2","page":"Overview","title":"Licensing Model","text":"We believe in the power of open source to foster innovation and community-driven  development and also recognize the need for a sustainable business model and a model that can handle export-controlled aerospace content. \n\nFor these reasons, Epicycle is offered under a tri-licensing model. The license allows users to choose between the following three options:\n\nLGPL v3.0\nEvaluation and Education use Only\nCommercial License","category":"section"},{"location":"overview/#Acknowledgments-2","page":"Overview","title":"Acknowledgments","text":"Epicycle builds upon the foundational work of many contributors to the aerospace and scientific computing communities:\n\nAstrodynamics Standards\n\nNASA GMAT Development Team for orbital mechanics algorithms and validation test cases\nDavid Vallado for \"Fundamentals of Astrodynamics and Applications\" formulations\nThe Astropy Project for rigorous time system standards and implementations\n\nJulia Scientific Computing Ecosystem\n\nSciML Organization for OrdinaryDiffEq.jl and the broader differential equations ecosystem\nJulia Astro community for SPICE.jl and astronomical coordinate systems\nBYU FLOW Lab for SNOW.jl optimization framework\nWächter & Biegler for the IPOPT nonlinear programming solver\n\nOpen Source Foundations\n\nJulia Computing and contributors for the Julia language\nThe Documenter.jl team for documentation generation\nGitHub Actions and the CI/CD community for automated testing infrastructure\n\nWe gratefully acknowledge these projects and their maintainers, whose work makes Epicycle possible.","category":"section"},{"location":"overview/#Contributing-2","page":"Overview","title":"Contributing","text":"To protect both contributors and our company, we use the Linux Kernel's Developer's  Certificate of Origin (DCO) as detailed in CONTRIBUTING.txt.","category":"section"},{"location":"overview/#Getting-Started-2","page":"Overview","title":"Getting Started","text":"New users should begin with the Getting Started guide, which walks through installation and basic usage patterns. The Tutorials section provides hands-on examples for common astrodynamics tasks.\n\nFor developers interested in extending Epicycle, each package maintains its own documentation with implementation details and contribution guidelines.","category":"section"},{"location":"#Epicycle:-An-Application-for-Space-Mission-Design-and-(eventually)-Navigation","page":"Home","title":"Epicycle: An Application for Space Mission Design and (eventually) Navigation","text":"Epicycle is a Julia package ecosystem for astrodynamics and space mission design, built with a modular architecture that spans mission analysis workflows from preliminary design through trajectory optimization. The current implementation - which is the initial release - focuses on establishing a robust architecture with key components—coordinate systems, time standards, spacecraft state representations, basic propagation, targeting and optimization—while providing extensible interfaces for systematic expansion toward operational mission design and navigation capabilities.\n\nThe ecosystem consists of eleven specialized packages organized in architectural layers, from core abstractions (EpicycleBase) through utilities (AstroEpochs, AstroStates, and AstroUniverse) to  integrated workflows (AstroManeuvers, AstroProp, and AstroSolve). The structure enables users to use low level utilities independently of the full system, or compose mission-specific analyses using interfaces designed to solve complex design problems, fast. The architecture in the first release is well tested and documented, and provides a clear pathway for extending capabilities toward high-fidelity force modeling, advanced optimization algorithms, and operational navigation applications as the framework matures.\n\n<div style=\"text-align: center;\">\n  <img src=\"assets/GEOTransfer.png\" width=\"50%\" alt=\"GEO Transfer Trajectory\">\n  <p><em>Example: GEO transfer trajectory with plane change correction, showing 8-event optimization sequence.</em></p>\n</div>","category":"section"},{"location":"#Architecture-and-Components","page":"Home","title":"Architecture and Components","text":"","category":"section"},{"location":"#Development-Environment","page":"Home","title":"Development Environment","text":"Epicycle is designed to work seamlessly with modern development tools:\n\nVisual Studio Code with Julia Language Server provides comprehensive IDE features\nCode Intelligence through language-based completion and GitHub Copilot integration\nInteractive Development with integrated debugger and REPL workflow\nWorkspace Management for organizing multi-package projects","category":"section"},{"location":"#Package-Architecture","page":"Home","title":"Package Architecture","text":"The Epicycle ecosystem implements a layered architecture where each package provides focused functionality while maintaining clean interfaces for composition in workflows. Users can access the complete system through using Epicycle in Julia, or leverage individual components independently for specialized applications. The packages are organized from the integration layer down through foundational components: \n\nPackage Purpose\nEpicycle Integration layer providing unified interface and common workflows\nEpicycleBase Core abstractions, type hierarchy, and fundamental constants\nAstroStates Spacecraft state representations and state transformations\nAstroEpochs Time systems, epoch handling, and temporal conversions\nAstroUniverse Celestial body models, ephemeris data, and gravitational parameters\nAstroFrames Reference frames and coordinate system transformations\nAstroModels Spacecraft and physical models\nAstroManeuvers Maneuver models and algorithms\nAstroCallbacks Utilities for constraints, objectives, and events\nAstroProp Numerical integration and trajectory propagation methods\nAstroSolve Optimization algorithms and constraint solving capabilities","category":"section"},{"location":"#Current-Status","page":"Home","title":"Current Status","text":"The initial release of Epicycle provides a core architecture that integrates fundamental algorithms and models into an intuitive application for solving engineering problems. The model packages establish essential functionality while the architecture is designed for systematic expansion. The implementation maintains loose coupling between packages so lower-level components can be used independently of the full Epicycle application.\n\nThe system includes comprehensive test suites and documentation across all packages, with 95% code coverage and continuous integration on GitHub.  The software has been tested and validated on macOS, Linux, and Windows environments, with the architectural foundation established and core functionality implemented, making Epicycle ready for mission analysis workflows while maintaining an extensible design for advanced capabilities. \n\nAstrodynamics computations are tested against the General Mission Analysis Tool (GMAT) R2022a. Time conversion calculations are tested against Astropy.Time.","category":"section"},{"location":"#Why-New-Software","page":"Home","title":"Why New Software","text":"Julia is a modern, high-performance language designed for technical computing. It combines the ease of use found in MATLAB and Python with the performance of C/C++.\n\nMost aerospace tools require custom scripting interfaces or domain-specific languages. Julia serves as both the implementation language and the user interface, providing direct access to the full computational ecosystem. The language's design emphasizes scientific computing and automatic differentiation, both essential for aerospace optimization and navigation applications.\n\nHigh-Performance Numerical Analysis - Julia is designed for high-performance numerical analysis, making it suitable for complex scientific computations.\nEfficient Linear Algebra - Julia excels in linear algebra with efficient matrix operations and optimized algorithms.\nDifferential Equations - Julia provides advanced features for solving differential equations, making it suitable for complex scientific and engineering problems.\nSciML Machine Learning - Julia seamlessly integrates with SciML for machine learning, enhancing the capabilities for scientific machine learning applications.\nOptimization Tools - Julia interfaces seamlessly with optimization tools like SNOPT and IPOPT, facilitating the handling of complex tasks in technical computing.","category":"section"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"Epicycle builds upon the foundational work of many contributors to the aerospace and scientific computing communities:\n\nAstrodynamics Standards\n\nNASA GMAT Development Team for orbital mechanics specifications and validation test cases\nDavid Vallado, \"Fundamentals of Astrodynamics and Applications, 4th Edition\" (2013), Microcosm Press, for mathematical formulations and algorithmic references\nThe Astropy Project for rigorous time system standards and implementations\n\nJulia Scientific Computing Ecosystem\n\nSciML Organization for OrdinaryDiffEq.jl used in AstroProp\nJulia Astro community for SPICE.jl used in AstroUniverse\nBYU FLOW Lab for SNOW.jl used in AstroSolve\nJulia Space Mission Design for the TEMPO.jl library used in AstroEpochs \nWächter & Biegler for the IPOPT nonlinear programming solver\n\nOpen Source Foundations\n\nJulia Computing and contributors to the Julia language\nThe Documenter.jl team for documentation generation\nGitHub Actions and the CI/CD community for automated testing infrastructure\nVisual Studio Code, used to develop Epicycle and the recommended user interface\n\nWe gratefully acknowledge these projects and their maintainers, whose work makes Epicycle possible.","category":"section"},{"location":"#Core-Contributors","page":"Home","title":"Core Contributors","text":"Steve Hughes (steven.hughes at genastro.org), architect and lead developer.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"We believe in the power of open source to foster innovation and community-driven  development and also recognize the need for a sustainable business model and a model that can handle export-controlled aerospace content. \n\nFor these reasons, Epicycle is offered under a tri-licensing model. The license allows users to choose between the following three options:\n\nLGPL V3.0\nEvaluation and Education use Only\nCommercial License\n\nSee LICENSE.txt for the terms of each license option. For licensing questions contact licensing [at] genastro.org","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"To protect both contributors and our company, we use the Linux Kernel's Developer's  Certificate of Origin (DCO) as detailed in CONTRIBUTING.txt.","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"For support, including technical support and services to apply Epicycle to your application, contact support [at] genastro.org","category":"section"},{"location":"#What-is-an-Epicycle?","page":"Home","title":"What is an Epicycle?","text":"Humankind has been studying planetary motion for millennia. An epicycle is a geometric theory developed by Ptolemy to explain why planets appear to reverse direction and perform small loops in their celestial paths. While this model represented a significant advancement over earlier theories, it was ultimately incorrect—and it would be nearly 1500 years before Kepler developed a more accurate framework for understanding orbital mechanics.\n\nWe've come remarkably far in our understanding, yet fundamental questions remain. Either our theories of relativity, quantum mechanics, or both may be incomplete—reminding us that scientific discovery is an ongoing journey.\n\nThe Epicycle software is a tribute to the brilliant minds who came before us, celebrating how far we've advanced while embracing the excitement of continuing to push the boundaries of knowledge and make new discoveries. ","category":"section"},{"location":"#Epicycle-vs-Julia-Space-Mission-Design","page":"Home","title":"Epicycle vs Julia Space Mission Design","text":"Julia Space Mission Design (JSMD) provides a collection of high-quality foundational libraries for astrodynamics computations, including reference frames, ephemerides, time systems, and gravitational modeling. These packages serve as building blocks that can be composed into custom applications.\n\nEpicycle takes a complementary approach by providing an integrated application built specifically from the top down. Where JSMD offers libraries for constructing astrodynamics tools, Epicycle delivers an application architected around trajectory optimization, targeting, and visualization and mission design workflows. Indeed, Epicycle uses parts of JSMD (specifically Tempo.jl). The initial release of Epicycle focuses on establishing a robust architecture with academic-level force modeling and plans include integrating with additional JSMD components as the framework matures.","category":"section"},{"location":"#Epicycle-vs-JuliaAstro","page":"Home","title":"Epicycle vs JuliaAstro","text":"JuliaAstro is a comprehensive ecosystem for astronomical computing, covering observational astronomy, telescope data processing, and astrophysical modeling.\n\nWhile there is some overlap—Epicycle's utility packages like AstroEpochs, AstroFrames, and AstroUniverse handle time systems, coordinate frames, and celestial bodies that are relevant to both domains—the ecosystems serve different purposes. JuliaAstro focuses on observing and understanding the universe and targets astronomy and astrophysics users, Epicycle focuses on space system design and analysis, and focuses on aerospace engineering users. The distinction is analogous to the difference between studying planetary motion and designing a mission to visit those planets. ","category":"section"},{"location":"#Epicycle-vs-Satellite-Toolbox","page":"Home","title":"Epicycle vs Satellite Toolbox","text":"SatelliteToolbox.jl is a comprehensive library of satellite-focused models and utilities built from the ground up. Among other capabilities, it supports TLE propagation (SGP4/SDP4), gravity models, environmental models (atmospheric density, geomagnetic fields), and coordinate transformations and reference frames.\n\nEpicycle is an integrated application for mission design and trajectory optimization, built from the top down. It focuses on multi-event trajectory optimization and simulation, graph-based mission architecture (phase-to-phase workflows), and interactive visualization for design iteration. The first release of Epicycle is light on detailed physics models, and heavier on the system architecture and optimization workflows.\n\nThese packages are complementary. SatelliteToolbox provides detailed models and transformations valuable for higher fidelity modelling and for various flight regimes. Epicycle provides the workflow architecture and optimization tools for designing missions. As Epicycle matures, we're considering integration with both SatelliteToolbox and Julia Space Mission Design to leverage their sophisticated models—similar to how we currently use TEMPO.jl and SPICE.jl for ephemeris and time systems.","category":"section"}]
}
