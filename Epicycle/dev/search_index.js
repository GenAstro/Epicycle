var documenterSearchIndex = {"docs":
[{"location":"components/#Components","page":"Components","title":"Components","text":"The Epicycle ecosystem consists of eleven specialized packages organized in architectural layers. Each package provides focused functionality while maintaining clean interfaces for composition into mission analysis workflows.","category":"section"},{"location":"components/#Foundation-Packages","page":"Components","title":"Foundation Packages","text":"Core abstractions and fundamental representations that underpin all mission analysis capabilities.","category":"section"},{"location":"components/#[AstroBase](https://genastro.github.io/Epicycle/AstroBase/dev/)","page":"Components","title":"AstroBase","text":"Core abstractions, type hierarchy, and fundamental constants. Provides the foundational types and interfaces used throughout the ecosystem.","category":"section"},{"location":"components/#[AstroStates](https://genastro.github.io/Epicycle/AstroStates/dev/)","page":"Components","title":"AstroStates","text":"Spacecraft state representations and coordinate transformations. Handles Cartesian, Keplerian, and Modified Equinoctial element representations with conversion capabilities.","category":"section"},{"location":"components/#[AstroEpochs](https://genastro.github.io/Epicycle/AstroEpochs/dev/)","page":"Components","title":"AstroEpochs","text":"Time systems, epoch handling, and temporal conversions. Provides rigorous time standards including UTC, TAI, TT, and TDB with high-precision conversions.","category":"section"},{"location":"components/#Physical-Models","page":"Components","title":"Physical Models","text":"Environmental and spacecraft modeling capabilities for realistic mission simulation.","category":"section"},{"location":"components/#[AstroUniverse](https://genastro.github.io/Epicycle/AstroUniverse/dev/)","page":"Components","title":"AstroUniverse","text":"Celestial body models, ephemeris data, and gravitational parameters. Includes planetary data, gravitational constants, and ephemeris interfaces.","category":"section"},{"location":"components/#[AstroFrames](https://genastro.github.io/Epicycle/AstroFrames/dev/)","page":"Components","title":"AstroFrames","text":"Reference frames and coordinate system transformations. Handles inertial and rotating frames with precise transformation matrices.","category":"section"},{"location":"components/#[AstroModels](https://genastro.github.io/Epicycle/AstroModels/dev/)","page":"Components","title":"AstroModels","text":"Spacecraft and physical models for environmental interactions. Includes drag, solar radiation pressure, and other perturbation models.","category":"section"},{"location":"components/#Mission-Design","page":"Components","title":"Mission Design","text":"High-level capabilities for trajectory design, optimization, and mission analysis.","category":"section"},{"location":"components/#[AstroManeuvers](https://genastro.github.io/Epicycle/AstroManeuvers/dev/)","page":"Components","title":"AstroManeuvers","text":"Maneuver models and algorithms for trajectory modification. Provides impulsive and finite-burn maneuver representations.","category":"section"},{"location":"components/#[AstroCallbacks](https://genastro.github.io/Epicycle/AstroCallbacks/dev/)","page":"Components","title":"AstroCallbacks","text":"Mission analysis utilities for constraints, objectives, and events. Includes stopping conditions, cost functions, and constraint definitions.","category":"section"},{"location":"components/#[AstroProp](https://genastro.github.io/Epicycle/AstroProp/dev/)","page":"Components","title":"AstroProp","text":"Numerical integration and trajectory propagation methods. High-order Runge-Kutta integrators with adaptive stepping and event detection.","category":"section"},{"location":"components/#[AstroSolve](https://genastro.github.io/Epicycle/AstroSolve/dev/)","page":"Components","title":"AstroSolve","text":"Optimization algorithms and constraint solving capabilities. Interfaces with IPOPT and other solvers for trajectory optimization problems.","category":"section"},{"location":"running_examples/#Running-Examples","page":"Running Examples","title":"Running Examples","text":"[Content to be written]\n\nHow to run and understand the example files.","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"[Content to be written]\n\nInstallation instructions for Epicycle and dependencies.","category":"section"},{"location":"why_new_software/#Why-New-Software","page":"Why New Software","title":"Why New Software","text":"[This section needs to be written - comparison with existing tools like GMAT, STK, etc., rationale for new development in Julia, advantages of the modular approach, etc.]","category":"section"},{"location":"why_new_software/#Existing-Tools-Comparison","page":"Why New Software","title":"Existing Tools Comparison","text":"[Compare with GMAT, STK, Orekit, etc.]","category":"section"},{"location":"why_new_software/#Julia-Advantages","page":"Why New Software","title":"Julia Advantages","text":"[Performance, ecosystem, modern language features]","category":"section"},{"location":"why_new_software/#Modular-Architecture-Benefits","page":"Why New Software","title":"Modular Architecture Benefits","text":"[Flexibility, extensibility, focused development]","category":"section"},{"location":"sample_missions/#Sample-Missions","page":"Sample Missions","title":"Sample Missions","text":"[Content to be written]\n\nSample mission workflows and scenarios.","category":"section"},{"location":"getting_help/#Getting-Help","page":"Getting Help","title":"Getting Help","text":"[Content to be written]\n\nWhere to find help, documentation links, community resources.","category":"section"},{"location":"package_overview/#Package-Overview","page":"Package Overview","title":"Package Overview","text":"[Content to be written]","category":"section"},{"location":"package_overview/#AstroStates","page":"Package Overview","title":"AstroStates","text":"State representations and conversions.","category":"section"},{"location":"package_overview/#AstroProp","page":"Package Overview","title":"AstroProp","text":"High-fidelity trajectory propagation.","category":"section"},{"location":"package_overview/#AstroSolve","page":"Package Overview","title":"AstroSolve","text":"Trajectory optimization and mission design.","category":"section"},{"location":"package_overview/#AstroCallbacks","page":"Package Overview","title":"AstroCallbacks","text":"Mission analysis calculations and constraints.","category":"section"},{"location":"package_overview/#AstroEpochs","page":"Package Overview","title":"AstroEpochs","text":"High-precision astronomical time systems.","category":"section"},{"location":"package_overview/#AstroUniverse","page":"Package Overview","title":"AstroUniverse","text":"Celestial body models and ephemeris.","category":"section"},{"location":"package_overview/#AstroFrames","page":"Package Overview","title":"AstroFrames","text":"Coordinate systems and transformations.","category":"section"},{"location":"package_overview/#AstroManeuvers","page":"Package Overview","title":"AstroManeuvers","text":"Maneuver planning and execution.","category":"section"},{"location":"package_overview/#AstroModels","page":"Package Overview","title":"AstroModels","text":"Spacecraft and mission modeling.","category":"section"},{"location":"welcome/#Welcome-to-Epicycle","page":"Welcome to Epicycle","title":"Welcome to Epicycle","text":"[Content to be written]\n\nProject overview, aerospace focus, ecosystem introduction.","category":"section"},{"location":"installing_julia/#Installing-Julia?","page":"Installing Julia?","title":"Installing Julia?","text":"[Content to be written]","category":"section"},{"location":"resources_for_julia/#Installing-Julia?","page":"Installing Julia?","title":"Installing Julia?","text":"[Content to be written]","category":"section"},{"location":"complete_examples/#Complete-Examples","page":"End-to-End Examples","title":"Complete Examples","text":"Integrated mission simulations and workflows","category":"section"},{"location":"complete_examples/#Propagation-Basics","page":"End-to-End Examples","title":"Propagation Basics","text":"using Epicycle\n\n# Spacecraft\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    #name=\"SC-StopAt\",\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)\n\n# Forces + integrator\ngravity = PointMassGravity(earth,(moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate to periapsis\npropagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=+1))\nprintln(get_state(sat, Keplerian()))\n\n# Propagate to apoapsis\npropagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))\nprintln(get_state(sat, Keplerian()))\n\n# Stop when |r| reaches 7000 km \npropagate(prop, sat, StopAt(sat, PosMag(), 7000.0))\nprintln(get_state(sat, SphericalRADEC()))       \n\n# Propagate to x-position crossing (increasing)\nsol = propagate(prop, sat, StopAt(sat, PosX(), 7.5; direction=+1))\nprintln(get_state(sat, Cartesian()))\n\n# Propagate multiple spacecraft with multiple stopping conditions\nsc1 = Spacecraft(); sc2 = Spacecraft() \nstop_sc1_node = StopAt(sc1, PosZ(), 0.0)\nstop_sc2_periapsis = StopAt(sc2, PosDotVel(), 0.0; direction=+1)\npropagate(prop, [sc1,sc2], stop_sc1_node, stop_sc2_periapsis)","category":"section"},{"location":"complete_examples/#Impulsive-Maneuvers","page":"End-to-End Examples","title":"Impulsive Maneuvers","text":"using Epicycle\n\n# Create a default spacecraft\nsat1 = Spacecraft()\n\n# Create an impulsive maneuver in the Inertial frame\ndeltav2 = ImpulsiveManeuver(\n      axes = Inertial(),\n      g0 = 9.80665,\n      Isp = 250.0,\n      element1 = 0.04,\n      element2 = -0.3,\n      element3 = 0.1\n     )\n\n# Apply the maneuver to the spacecraft\nprintln(\"Initial mass: \", sat1.mass)\nmaneuver(sat1, deltav2)\nprintln(\"Mass after Inertial maneuver: \", sat1.mass)\nprintln(\"State after Inertial maneuver: \\n\", get_state(sat1, Cartesian()))\n\n# Create an impulsive maneuver in the VNB frame\ndeltav1 = ImpulsiveManeuver(\n      axes = VNB(),\n      g0 = 9.80665,\n      Isp = 250.0,\n      element1 = 0.2,\n      element2 = 0.1,\n      element3 = -0.2\n      )\n\n# Apply the maneuver to the spacecraft\nmaneuver(sat1, deltav1)\nprintln(\"Mass after VNB maneuver: \", sat1.mass)\nprintln(\"State after VNB maneuver: \\n\", get_state(sat1, Cartesian()))","category":"section"},{"location":"complete_examples/#Hohmann-Transfer","page":"End-to-End Examples","title":"Hohmann Transfer","text":"\n\nusing Epicycle\n\n# Create spacecraft\nsat = Spacecraft(\n            state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 1.0]), \n            time = Time(\"2020-09-21T12:23:12\", TAI(), ISOT())\n            )\n\n# Create force models, integrator, and dynamics system\npm_grav = PointMassGravity(earth,(moon,sun))\nforces = ForceModel(pm_grav)\ninteg = IntegratorConfig(DP8(); abstol = 1e-11, reltol = 1e-11, dt = 4000)\n\n# Define which spacecraft to propagate and which force model to use\ndynsys = DynSys(\n          forces = forces, \n          spacecraft = [sat]\n          )\n\n# Create maneuver models for the hohmann transfer\ntoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.1,\n    element2 = 0.2,\n    element3 = 0.3\n)\n\nmoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.4,\n    element2 = 0.5,\n    element3 = 0.6\n)\n\n# Define toi as a solver variable\nvar_toi = SolverVariable(\n    calc = ManeuverCalc(toi, sat, DeltaVVector()),\n    name = \"toi\",\n    lower_bound = [-10.0, 0.0, 0.0],\n    upper_bound = [10.0, 0.0, 0.0],\n)\n\n# Define moi as a solver variable\nvar_moi = SolverVariable(\n    calc = ManeuverCalc(moi, sat, DeltaVVector()),\n    name = \"moi\",\n    lower_bound = [-10.0, 0.0, 0.0],\n    upper_bound = [10.0, 0.0, 0.0]\n)\n\npos_target = 45000.0\npos_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [pos_target],\n    upper_bounds = [pos_target],\n    scale = [1.0],\n)\n\necc_con = Constraint(\n    calc = OrbitCalc(sat, Ecc()),\n    lower_bounds = [0.0],\n    upper_bounds = [0.0], \n    scale = [1.0],\n)\n\n# Create the TOI Event\ntoi_fun() = maneuver(sat, toi) \ntoi_event = Event(name = \"TOI\", \n                  event = toi_fun, \n                  vars = [var_toi],\n                  funcs = [])\n\n# Create the prop to apopasis event\n\nprop_apo_fun() = propagate(dynsys, integ, StopAtApoapsis(sat))\nprop_event = Event(name = \"Prop to Apoapsis\", event = prop_apo_fun)\n\n# Create the TOI event. \nmoi_fun() = maneuver(sat, moi)\nmoi_event = Event(name = \"MOI\", \n                  event = moi_fun,\n                  vars = [var_moi],\n                  funcs = [pos_con, ecc_con])\n\n# Build sequence and solve\nseq = Sequence()\nadd_events!(seq, prop_event, [toi_event]) \nadd_events!(seq, moi_event, [prop_event])\n\n# Solve the trajectory and report results\nresult = trajectory_solve(seq)\nsequence_report(seq)\nsolution_report(seq, result)\n\nThe output of this run:\n\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:        4\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:        2\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        2\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:        2\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  0.0000000e+00 3.74e+04 0.00e+00   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  0.0000000e+00 1.77e+04 1.40e+02  -5.0 1.12e+01    -  4.69e-01 2.18e-01h  3\n   2  0.0000000e+00 3.67e+03 1.25e-01  -0.6 1.55e-01    -  1.00e+00 1.00e+00h  1\n   3  0.0000000e+00 2.35e+02 2.62e-02  -2.6 5.60e-02    -  1.00e+00 1.00e+00h  1\n   4  0.0000000e+00 1.09e+00 3.48e-04  -4.5 4.41e-03    -  9.99e-01 1.00e+00h  1\n   5  0.0000000e+00 2.40e-05 0.00e+00  -6.3 2.21e-05    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 5\n\n                                   (scaled)                 (unscaled)\nObjective...............:   0.0000000000000000e+00    0.0000000000000000e+00\nDual infeasibility......:   0.0000000000000000e+00    0.0000000000000000e+00\nConstraint violation....:   7.2005827011268791e-07    2.3959924874361604e-05\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   4.7560577722374565e-07    4.7560577722374565e-07\nOverall NLP error.......:   7.2005827011268791e-07    2.3959924874361604e-05\n\n\nNumber of objective function evaluations             = 7\nNumber of objective gradient evaluations             = 6\nNumber of equality constraint evaluations            = 10\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 6\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 3.144\n\nEXIT: Optimal Solution Found.\n\nTRAJECTORY SEQUENCE SUMMARY\n==================================================\n\nSequence Overview:\n- Total Events: 3\n- Variable Objects: 2 (6 optimization variables)\n- Constraint Objects: 2 (2 constraint functions)\n- Execution Order: [\"TOI\" → \"Prop to Apoapsis\" → \"MOI\"]\n\nEVENT DETAILS:\n--------------------\n\nEvent 1: \"TOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  └─ toi: DeltaVVector() (ManeuverCalc) (3 components)\n│     ├─  Component 1: ∈ [-10.0, 10.0]\n│     ├─  Component 2: = 0.0\n│     └─  Component 3: = 0.0\n└─ Constraint Objects (0): None\n\nEvent 2: \"Prop to Apoapsis\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 3: \"MOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  ├─ moi: DeltaVVector() (ManeuverCalc) (3 components)\n│  │  ├─  Component 1: ∈ [-10.0, 10.0]\n│  │  ├─  Component 2: = 0.0\n│  │  └─  Component 3: = 0.0\n└─ Constraint Objects (2): 2 constraint functions\n   ├─ PosMag() (OrbitCalc) = 45000.0\n   └─ Ecc() (OrbitCalc) = 0.0\n\nSTATEFUL OBJECTS:\n--------------------\n- ImpulsiveManeuver (×2)\n- Spacecraft\n\n==================================================\n\nTRAJECTORY SOLUTION REPORT\n==================================================\n\nOPTIMIZATION STATUS:\n- Converged: Solve_Succeeded\n- Variable Objects: 2 (6 optimization variables)\n- Constraint Objects: 2 (2 constraint functions)\n\nOPTIMIZATION VARIABLES:\n-------------------------\ntoi (DeltaVVector() (ManeuverCalc)):\n  Component 1: 2.355732 (bounds: [-10.0, 10.0])\n  Component 2: 0.0 (fixed at 0.0)\n  Component 3: 0.0 (fixed at 0.0)\n  Total ΔV: 2.355732\n\nmoi (DeltaVVector() (ManeuverCalc)):\n  Component 1: 1.432696 (bounds: [-10.0, 10.0])\n  Component 2: 0.0 (fixed at 0.0)\n  Component 3: 0.0 (fixed at 0.0)\n  Total ΔV: 1.432696\n\nCONSTRAINT SATISFACTION:\n-------------------------\nEvent \"MOI\":\n  PosMag() (OrbitCalc): 45000.000024 (target: 45000.0)\n  Ecc() (OrbitCalc): 0.0 (target: 0.0)\n\n==================================================","category":"section"},{"location":"complete_examples/#GEO-Transfer","page":"End-to-End Examples","title":"GEO Transfer","text":"\nusing Epicycle\n\n# ========== Create Models =================================================================\n# Create spacecraft\nsat = Spacecraft(\n    state = CartesianState([3737.792, -4607.692, -2845.644, 5.411, 5.367, -1.566]),\n    time = Time(\"2000-01-01T11:59:28.000\", UTC(), ISOT())  # J2000 epoch from GMAT\n)\n\n# Create simple Earth point mass dynamics (no third bodies for now)\ngravity = PointMassGravity(earth, ())  # Only Earth gravity\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(DP8(); abstol=1e-12, reltol=1e-12, dt=60.0)\nprop    = OrbitPropagator(forces, integ)\n\n# Define maneuver models\ntoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 1.518,\n    element2 = 0.0,\n    element3 = 0.0,\n)\n\nmcc = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.559,\n    element2 = 0.588,\n    element3 = 0.0,\n)\n\nmoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = -0.282,\n    element2 = 0.0,\n    element3 = 0.0,\n)\n\n# ========== Define Solver Variables ======================================================\n# TOI: Only vary V component (Element1)\nvar_toi_v = SolverVariable(\n    calc = ManeuverCalc(toi, sat, DeltaVVector()),\n    name = \"toi_v\",\n    lower_bound = [-5.0, 0.0, 0.0],  # Only V component varies significantly\n    upper_bound = [5.0, 0.0, 0.0],\n)\n\n# MCC: Vary V and N components (Element1 and Element2)\nvar_mcc_vn = SolverVariable(\n    calc = ManeuverCalc(mcc, sat, DeltaVVector()),\n    name = \"mcc_vn\",\n    lower_bound = [-2.0, -2.0, -0.001],   # V and N components vary\n    upper_bound = [2.0, 2.0, 0.001],\n)\n\n# MOI: Only vary V component (Element1)\nvar_moi_v = SolverVariable(\n    calc = ManeuverCalc(moi, sat, DeltaVVector()),\n    name = \"moi_v\",\n    lower_bound = [-2.0, -0.001, -0.001],  # Only V component varies significantly\n    upper_bound = [2.0, 0.001, 0.001],\n)\n\n# ========== Define Constraints ===========================================================\n# Constraint: Apoapsis radius = 85,000 km after TOI\napogee_radius_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [85000.0],\n    upper_bounds = [85000.0],\n    scale = [1.0],\n)\n\n# Constraint: Inclination = 2° after MCC\ninclination_con = Constraint(\n    calc = OrbitCalc(sat, Inc()),\n    lower_bounds = [deg2rad(2.0)],\n    upper_bounds = [deg2rad(2.0)],\n    scale = [1.0],\n)\n\n# Constraint: Perigee radius = 42,195 km after MCC\nperigee_radius_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [42195.0],\n    upper_bounds = [42195.0],\n    scale = [1.0],\n)\n\n# Constraint: Final SMA = 42,166.90 km (GEO) after MOI\nfinal_sma_con = Constraint(\n    calc = OrbitCalc(sat, SMA()),\n    lower_bounds = [42166.90],\n    upper_bounds = [42166.90],\n    scale = [1.0],\n)\n\n# ========== Define events (variables, constraints, actions) ==============================\n# Event 1: Propagate to Z=0 crossing (equatorial plane)\nprop_to_z_crossing_1_fun() = propagate(prop, sat, StopAt(sat, PosZ(), 0.0))\nprop_to_z_crossing_1_event = Event(\n    name = \"Prop to Z 1\",\n    event = prop_to_z_crossing_1_fun,\n)\n\n# Event 2: Apply TOI maneuver\ntoi_fun() = maneuver(sat, toi)\ntoi_event = Event(\n    name = \"TOI\",\n    event = toi_fun,\n    vars = [var_toi_v],\n)\n\n# Event 3: Propagate to apoapsis and check radius constraint\nprop_to_apogee_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))\nprop_to_apogee_event = Event(\n    name = \"Prop to Apoapsis\",\n    event = prop_to_apogee_fun,\n    funcs = [apogee_radius_con],\n)\n\n# Event 4: Propagate to perigee\nprop_to_perigee_1_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))\nprop_to_perigee_1_event = Event(\n    name = \"Prop to Perigee 1\",\n    event = prop_to_perigee_1_fun,\n)\n\n# Event 5: Propagate to Z=0 crossing again\nprop_to_z_crossing_2_fun() = propagate(prop, sat, StopAt(sat, PosZ(), 0.0))\nprop_to_z_crossing_2_event = Event(\n    name = \"Prop to Z 2\",\n    event = prop_to_z_crossing_2_fun,\n)\n\n# Event 6: Apply MCC maneuver\nmcc_fun() = maneuver(sat, mcc)\nmcc_event = Event(\n    name = \"MCC\",\n    event = mcc_fun,\n    vars = [var_mcc_vn],\n)\n\n# Event 7: Propagate to perigee and check constraints\nprop_to_perigee_2_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))\nprop_to_perigee_2_event = Event(\n    name = \"Prop to Perigee 2\",\n    event = prop_to_perigee_2_fun,\n    funcs = [inclination_con, perigee_radius_con],\n)\n\n# Event 8: Apply MOI maneuver and check final SMA\nmoi_fun() = maneuver(sat, moi)\nmoi_event = Event(\n    name = \"MOI\",\n    event = moi_fun,\n    vars = [var_moi_v],\n    funcs = [final_sma_con],\n)\n\n# ========== Build the Sequence and Solve =================================================\nseq = Sequence()\nadd_events!(seq, toi_event, [prop_to_z_crossing_1_event])\nadd_events!(seq, prop_to_apogee_event, [toi_event])\nadd_events!(seq, prop_to_perigee_1_event, [prop_to_apogee_event])\nadd_events!(seq, prop_to_z_crossing_2_event, [prop_to_perigee_1_event])\nadd_events!(seq, mcc_event, [prop_to_z_crossing_2_event])\nadd_events!(seq, prop_to_perigee_2_event, [mcc_event])\nadd_events!(seq, moi_event, [prop_to_perigee_2_event])\n\n# Set up IPOPT options\nipopt_options = Dict(\n    \"max_iter\" => 1000,\n    \"tol\" => 1e-6,\n    \"output_file\" => \"ipopt_geo_transfer$(rand(UInt)).out\",\n    \"file_print_level\" => 5,\n    \"print_level\" => 5,\n)\nsnow_options = Options(derivatives=ForwardFD(), solver=IPOPT(ipopt_options))\n\nresult = trajectory_solve(seq, snow_options)\nsequence_report(seq)\nsolution_report(seq, result)\n\nThe output for this configuration is\n\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:       28\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:        7\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        7\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:        4\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  0.0000000e+00 6.86e+04 0.00e+00   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  0.0000000e+00 5.34e+04 3.38e+00  -1.1 5.54e+00    -  4.81e-01 1.28e-01h  3\n   2  0.0000000e+00 3.23e+04 1.09e+01  -0.8 1.46e+00    -  9.75e-01 2.50e-01h  3\n   3  0.0000000e+00 4.01e+04 1.04e+00  -1.1 3.53e-01    -  7.31e-01 1.00e+00H  1\n   4  0.0000000e+00 7.86e+03 2.52e+00  -1.0 9.37e-01    -  1.00e+00 5.00e-01h  2\n   5  0.0000000e+00 5.46e+02 1.61e-01  -2.0 1.41e-01    -  1.00e+00 1.00e+00h  1\n   6  0.0000000e+00 4.68e+00 2.37e-03  -3.7 2.42e-03    -  1.00e+00 1.00e+00h  1\n   7  0.0000000e+00 3.82e-04 3.54e-05  -5.6 3.54e-05    -  1.00e+00 1.00e+00h  1\n   8  0.0000000e+00 1.18e-07 3.02e-12 -11.0 3.92e-09    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 8\n\n                                   (scaled)                 (unscaled)\nObjective...............:   0.0000000000000000e+00    0.0000000000000000e+00\nDual infeasibility......:   3.0156910335045697e-12    3.0156910335045697e-12\nConstraint violation....:   1.5534043499097701e-09    1.1797237675637005e-07\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   8.2697560462276952e-11    8.2697560462276952e-11\nOverall NLP error.......:   1.5534043499097701e-09    1.1797237675637005e-07\n\n\nNumber of objective function evaluations             = 18\nNumber of objective gradient evaluations             = 9\nNumber of equality constraint evaluations            = 22\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 9\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 2.412\n\nEXIT: Optimal Solution Found.\n\nTRAJECTORY SEQUENCE SUMMARY\n==================================================\n\nSequence Overview:\n- Total Events: 8\n- Variable Objects: 3 (9 optimization variables)\n- Constraint Objects: 4 (4 constraint functions)\n- Execution Order: [\"Prop to Z 1\" → \"TOI\" → ... → \"MOI\"]\n\nEVENT DETAILS:\n--------------------\n\nEvent 1: \"Prop to Z 1\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 2: \"TOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  └─ toi_v: DeltaVVector() (ManeuverCalc) (3 components)\n│     ├─  Component 1: ∈ [-5.0, 5.0]\n│     ├─  Component 2: = 0.0\n│     └─  Component 3: = 0.0\n└─ Constraint Objects (0): None\n\nEvent 3: \"Prop to Apoapsis\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (1): 1 constraint functions\n   └─ PosMag() (OrbitCalc) = 85000.0\n\nEvent 4: \"Prop to Perigee 1\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 5: \"Prop to Z 2\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (0): None\n\nEvent 6: \"MCC\"\n├─ Variable Objects (1): 3 optimization variables\n│  └─ mcc_vn: DeltaVVector() (ManeuverCalc) (3 components)\n│     ├─  Component 1: ∈ [-2.0, 2.0]\n│     ├─  Component 2: ∈ [-2.0, 2.0]\n│     └─  Component 3: ∈ [-0.001, 0.001]\n└─ Constraint Objects (0): None\n\nEvent 7: \"Prop to Perigee 2\"\n├─ Variable Objects (0): None\n└─ Constraint Objects (2): 2 constraint functions\n   ├─ Inc() (OrbitCalc) = 0.034907\n   └─ PosMag() (OrbitCalc) = 42195.0\n\nEvent 8: \"MOI\"\n├─ Variable Objects (1): 3 optimization variables\n│  ├─ moi_v: DeltaVVector() (ManeuverCalc) (3 components)\n│  │  ├─  Component 1: ∈ [-2.0, 2.0]\n│  │  ├─  Component 2: ∈ [-0.001, 0.001]\n│  │  └─  Component 3: ∈ [-0.001, 0.001]\n└─ Constraint Objects (1): 1 constraint functions\n   └─ SMA() (OrbitCalc) = 42166.9\n\nSTATEFUL OBJECTS:\n--------------------\n- ImpulsiveManeuver (×3)\n- Spacecraft\n\n==================================================\n\nTRAJECTORY SOLUTION REPORT\n==================================================\n\nOPTIMIZATION STATUS:\n- Converged: Solve_Succeeded\n- Variable Objects: 3 (9 optimization variables)\n- Constraint Objects: 4 (4 constraint functions)\n\nOPTIMIZATION VARIABLES:\n-------------------------\ntoi_v (DeltaVVector() (ManeuverCalc)):\n  Component 1: 2.819829 (bounds: [-5.0, 5.0])\n  Component 2: 0.0 (fixed at 0.0)\n  Component 3: 0.0 (fixed at 0.0)\n  Total ΔV: 2.819829\n\nmcc_vn (DeltaVVector() (ManeuverCalc)):\n  Component 1: 0.699575 (bounds: [-2.0, 2.0])\n  Component 2: 0.895256 (bounds: [-2.0, 2.0])\n  Component 3: 0.0 (bounds: [-0.001, 0.001])\n  Total ΔV: 1.136173\n\nmoi_v (DeltaVVector() (ManeuverCalc)):\n  Component 1: -0.480757 (bounds: [-2.0, 2.0])\n  Component 2: -0.0 (bounds: [-0.001, 0.001])\n  Component 3: -0.0 (bounds: [-0.001, 0.001])\n  Total ΔV: 0.480757\n\nCONSTRAINT SATISFACTION:\n-------------------------\nEvent \"Prop to Apoapsis\":\n  PosMag() (OrbitCalc): 85000.0 (target: 85000.0)\n\nEvent \"Prop to Perigee 2\":\n  Inc() (OrbitCalc): 0.034907 (target: 0.034907)\n  PosMag() (OrbitCalc): 42195.0 (target: 42195.0)\n\nEvent \"MOI\":\n  SMA() (OrbitCalc): 42166.9 (target: 42166.9)\n\n==================================================","category":"section"},{"location":"why_julia/#Why-Julia?","page":"Why Julia?","title":"Why Julia?","text":"[Content to be written]","category":"section"},{"location":"system_architecture/#System-Architecture","page":"System Architecture","title":"System Architecture","text":"[Content to be written]\n\nHow the Epicycle packages connect and work together.","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Quick-Start","page":"Getting Started","title":"Quick Start","text":"Get up and running with Epicycle in just a few lines of code:\n\nusing Pkg\nPkg.add(\"Epicycle\")\n\nusing Epicycle\n\n# Spacecraft\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)\n\n# Forces + integrator\ngravity = PointMassGravity(earth,(moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate to periapsis\npropagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=+1))\nprintln(get_state(sat, Keplerian()))\n\nThis example creates an orbit and propagates to periapis","category":"section"},{"location":"getting_started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"Epicycle requires Julia 1.10 or later. \n\nFor installation instructions, see the Julia Downloads page. Platform-specific guides are available for Windows, macOS, and Linux.","category":"section"},{"location":"getting_started/#Installing-VS-Code","page":"Getting Started","title":"Installing VS Code","text":"Visual Studio Code is the recommended editor for using Epicycle. It provides excellent support for Julia through the Julia Language Server, including syntax highlighting, intelligent code completion, debugging, and integrated REPL.\n\nFor complete installation and setup instructions, see the VS Code Julia Tutorial. This guide covers:\n\nInstalling VS Code\nInstalling the Julia extension\nConfiguring the Julia Language Server\nUsing the integrated REPL\nDebugging Julia code  ","category":"section"},{"location":"getting_started/#Installing-Epicycle","page":"Getting Started","title":"Installing Epicycle","text":"","category":"section"},{"location":"getting_started/#From-the-Julia-Package-Registry","page":"Getting Started","title":"From the Julia Package Registry","text":"The easiest way to install Epicycle is through Julia's built-in package manager:\n\nusing Pkg\nPkg.add(\"Epicycle\")\n\nThis will automatically install Epicycle and all its dependencies.","category":"section"},{"location":"getting_started/#Development-Installation","page":"Getting Started","title":"Development Installation","text":"If you want to contribute to Epicycle or need the latest development version:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/GenAstro/Epicycle.jl\")","category":"section"},{"location":"getting_started/#Verification","page":"Getting Started","title":"Verification","text":"Test your installation by running:\n\nusing Epicycle\n\n# Basic functionality test\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)","category":"section"},{"location":"getting_started/#Common-Installation-Issues","page":"Getting Started","title":"Common Installation Issues","text":"Package not found:\n\nEnsure you're using Julia 1.9 or later: julia --version\nUpdate your package registry: Pkg.Registry.update()\n\nDependency conflicts:\n\nStart with a fresh environment: Pkg.activate(temp=true)\nTry installing in isolated environment first\n\nNetwork issues:\n\nIf behind a corporate firewall, configure Julia's package server\nCheck proxy settings in your Julia startup file","category":"section"},{"location":"getting_started/#Getting-Help","page":"Getting Started","title":"Getting Help","text":"If you encounter installation issues:\n\nCheck the GitHub Issues for known problems\nSearch Julia Discourse for installation help\nOpen a new issue with your Julia version and error message","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Once installed, explore the documentation:\n\nUnit Examples - Learn specific concepts\nComplete Examples - See full mission simulations\nComponents - Understand the package structure","category":"section"},{"location":"unit_examples/#Component-Cheat-Sheets","page":"Component Cheat Sheets","title":"Component Cheat Sheets","text":"","category":"section"},{"location":"unit_examples/#A-Julia-Language-Cheat-Sheet","page":"Component Cheat Sheets","title":"A Julia Language Cheat Sheet","text":"A Julia Language Cheat Sheet.","category":"section"},{"location":"unit_examples/#Time-Systems-(AstroEpochs)","page":"Component Cheat Sheets","title":"Time Systems (AstroEpochs)","text":"AstroEpochs provides comprehensive time system handling for astrodynamics applications. It supports multiple time scales (UTC, TAI, TT, TDB) and formats (Julian Date, Modified Julian Date, ISO 8601) with high-precision conversions between them.\n\nusing AstroEpochs\n\n# Create from Julian Date\nt1 = Time(2451545.0, TT(), JD())\n\n# Create from Modified Julian Date  \nt2 = Time(51544.5, UTC(), MJD())\n\n# Create from ISO string\nt3 = Time(\"2000-01-01T12:00:00.000\", TAI(), ISOT())\n\n# Access different representations\nt1.jd        # Julian Date value\nt1.mjd       # Modified Julian Date value  \nt1.isot      # ISO 8601 string\n\n# Convert between scales (creates new Time object)\nt_utc = t1.utc\nt_tdb = t1.tdb\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Orbital-States-(AstroStates)","page":"Component Cheat Sheets","title":"Orbital States (AstroStates)","text":"AstroStates handles spacecraft orbital state representations and conversions between state representations. It supports 10 representations include Cartesian, Keplerian, B-plane and other representations.\n\nusing AstroStates\n\n# Define a Cartesian state\ncart = CartesianState([7000.0, 0.0, 100.0, 0.0, 7.5, 2.5])\n\n# Convert to Keplerian then back to Cartesian\nmu = 398600.4418 \nkep   = KeplerianState(cart, mu)     \ncart2 = CartesianState(kep, mu)     \n\n# Display some state elements\nkep.sma\nkep.raan\n\n# Generate a vector containing the state struct data\nto_vector(kep)\n\n# See a list of all supported representations\nsubtypes(AbstractOrbitState)\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Spacecraft-Modeling-(AstroModels)","page":"Component Cheat Sheets","title":"Spacecraft Modeling (AstroModels)","text":"AstroModels provides the spacecraft model defining properties such as time, state, and mass.\n\nusing AstroModels, AstroStates, AstroEpochs\n\n# Method 1: Using a CartesianState struct\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    mass = 1000.0\n)\n\n# Method 2: Direct construction with OrbitState\nsc2 = Spacecraft(\n    state = OrbitState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03], Cartesian()),\n    time = Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    mass = 1000.0\n)\n\nSee the full Reference Material for more details. ","category":"section"},{"location":"unit_examples/#Celestial-Bodies-(AstroUniverse)","page":"Component Cheat Sheets","title":"Celestial Bodies (AstroUniverse)","text":"AstroUniverse provides access to celestial body data including gravitational parameters, physical properties, and NAIF identification codes. It includes predefined bodies and supports creation of custom celestial objects for specialized applications and performs translations between coordinate origins. \n\nusing AstroUniverse\n\n# Access predefined celestial bodies\nearth.mu\nvenus.naifid\n\n# Create a custom body\nphobos = CelestialBody(\n    name = \"Phobos\",\n    naifid = 401,                    # NAIF ID for Phobos\n    mu = 7.0875e-4,       # km³/s² (gravitational parameter)\n    equatorial_radius = 11.1,                   # km (mean radius)\n)\n\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Maneuvers-(AstroManeuvers)","page":"Component Cheat Sheets","title":"Maneuvers (AstroManeuvers)","text":"AstroManeuvers provides maneuver modeling capabilities for trajectory modifications. It supports impulsive maneuvers with various coordinate frame options and specific impulse specifications for realistic propulsion modeling.\n\nusing Epicycle\nm = ImpulsiveManeuver(axes=Inertial(), \n                      Isp=300.0, \n                      element1=0.01, \n                      element2=0.0, \n                      element3=0.0)\n\nsc = Spacecraft()\nmaneuver(sc, m)\n\nSee the full Reference Material for more details.","category":"section"},{"location":"unit_examples/#Calculations-Framework-(AstroCallbacks)","page":"Component Cheat Sheets","title":"Calculations Framework (AstroCallbacks)","text":"AstroCallbacks provides a unified calculation framework for extracting and setting orbital parameters, celestial body properties, and maneuver characteristics. It offers a consistent interface for accessing computed quantities across the Epicycle ecosystem.\n\nusing AstroCallbacks, AstroStates, AstroModels\n\n# Create a spacecraft with orbital state\nsc = Spacecraft(state = CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]), \n                time = Time(\"2024-01-01T12:00:00\", UTC(), ISOT()), \n                mass = 1000.0)\n\n# Get semi-major axis from current state\nsma_calc = OrbitCalc(sc, SMA())\na = get_calc(sma_calc)           \nset_calc!(sma_calc, 10000.0)  \n\n# Set target incoming asymptote (rp = 6900, C3 = 14.0)\nhyp = OrbitCalc(sc, IncomingAsymptote())\nset_calc!(hyp, [6900.0, 14.0, 0.0, 0.0, 0.0, 0.0])  \n    \n# Set and get Earth's mu\nmu_calc = BodyCalc(earth, GravParam())\nμ = get_calc(mu_calc)            \nset_calc!(mu_calc, 3.986e5)      \n\n# Set and get maneuver elements\ntoi = ImpulsiveManeuver()\ndvvec_calc = ManeuverCalc(toi, sc, DeltaVVector())\nΔv = get_calc(dvvec_calc)   \nset_calc!(dvvec_calc, [0.2, 0.3, 0.4])\n\nSee the full Reference Material for more details.","category":"section"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"Welcome to Epicycle, an application for space mission analysis, trajectory optimization, and navigation. \n\nEpicycle provides an integrated application for astrodynamics analysis with focus on breadth and extensible interfaces. The system covers orbital state representations, coordinate transformations, trajectory propagation, and optimization.\n\nThe system handles Cartesian, Keplerian, and Modified Equinoctial orbital elements. Trajectory propagation uses Julia's differential equation solvers. Optimization connects SNOW algorithms with IPOPT.\n\nCurrent implementation emphasizes application integration over individual model depth. Interfaces are designed for systematic expansion of the model library.","category":"section"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"Epicycle is a comprehensive Julia package ecosystem for astrodynamics and space mission design. Built with a modular architecture, it provides a complete suite of tools for orbital mechanics, spacecraft trajectory analysis, and mission planning workflows.\n\nThe ecosystem consists of 11 specialized packages that work together to provide everything from fundamental astronomical calculations to advanced trajectory optimization:\n\nFoundation Layer: AstroBase (frames & constants), AstroStates (spacecraft states), AstroEpochs (time systems)\nDynamics Layer: AstroDynamics (propagation), AstroForces (force modeling), AstroSimulation (mission simulation)  \nAnalysis Layer: AstroTrajectories (orbital analysis), AstroManeuvers (spacecraft maneuvers), AstroEvents (mission events)\nMission Layer: AstroMissions (mission design), AstroOptimization (trajectory optimization)\nIntegration Layer: Epicycle (unified interface and workflows)","category":"section"},{"location":"overview/#Why-New-Software?","page":"Overview","title":"Why New Software?","text":"The astrodynamics field has historically relied on legacy Fortran codebases and proprietary tools that create barriers to innovation and collaboration. Existing open-source solutions often suffer from fragmentation, limited extensibility, or performance constraints.","category":"section"},{"location":"overview/#Modern-Architecture-Needs","page":"Overview","title":"Modern Architecture Needs","text":"Contemporary space missions require:\n\nScalable Performance: Handle everything from CubeSat missions to interplanetary trajectories\nModular Design: Compose mission-specific analysis workflows from reusable components  \nOpen Collaboration: Enable researchers and engineers to build upon shared foundations\nRapid Prototyping: Quickly test new algorithms and mission concepts\nIntegration Flexibility: Work seamlessly with modern data science and optimization tools","category":"section"},{"location":"overview/#Julia-Ecosystem-Advantages","page":"Overview","title":"Julia Ecosystem Advantages","text":"Julia provides unique benefits for astrodynamics applications:\n\nPerformance: Near-C/Fortran speeds with high-level expressiveness\nComposability: Multiple dispatch enables seamless package integration\nScientific Computing: Native differential equations, optimization, and automatic differentiation\nGrowing Ecosystem: Active scientific computing community with modern tooling\n\nEpicycle bridges the gap between specialized astrodynamics knowledge and modern computational capabilities.","category":"section"},{"location":"overview/#Design-Philosophy","page":"Overview","title":"Design Philosophy","text":"Epicycle is built around three core principles:","category":"section"},{"location":"overview/#Modularity-and-Composability","page":"Overview","title":"Modularity & Composability","text":"Each package focuses on a specific domain while maintaining clean interfaces. Users can combine components to build custom workflows without unnecessary complexity.","category":"section"},{"location":"overview/#Performance-and-Scalability","page":"Overview","title":"Performance & Scalability","text":"From preliminary mission design to high-fidelity simulation, Epicycle scales efficiently across problem sizes while maintaining numerical accuracy.","category":"section"},{"location":"overview/#Extensibility-and-Interoperability","page":"Overview","title":"Extensibility & Interoperability","text":"Open architecture allows researchers to extend capabilities and integrate with existing tools and datasets seamlessly.","category":"section"},{"location":"overview/#Software-Architecture","page":"Overview","title":"Software Architecture","text":"","category":"section"},{"location":"overview/#Package-Hierarchy","page":"Overview","title":"Package Hierarchy","text":"Package Purpose\nAstroBase Core abstractions and type hierarchy\nAstroStates Orbital state representations and conversions\nAstroEpochs Time systems and epoch handling\nAstroUniverse Celestial body models and ephemeris\nAstroFrames Coordinate systems and transformations\nAstroModels Spacecraft and physical models\nAstroManeuvers Maneuver models and algorithms\nAstroCallbacks Quantities used in I/O, stopping conditions, cost, constraints\nAstroProp Trajectory propagation algorithms\nAstroSolve Optimization and constraint solving\nEpicycle The application.  using Epicycle loads everything.","category":"section"},{"location":"overview/#Dependency-Structure","page":"Overview","title":"Dependency Structure","text":"The packages are organized in layers to ensure clean separation of concerns:\n\nFoundation: Core types and constants that all other packages depend on\nDomain Specific: Specialized functionality for states, time, coordinates, etc.\nAnalysis Tools: Higher-level capabilities built on foundation components\nIntegration: User-facing interfaces and complete workflows","category":"section"},{"location":"overview/#Key-Features","page":"Overview","title":"Key Features","text":"","category":"section"},{"location":"overview/#Comprehensive-Force-Modeling","page":"Overview","title":"Comprehensive Force Modeling","text":"Gravitational perturbations (J2-J6, third-body, solid tides)\nAtmospheric drag with exponential and NRLMSISE-00 models\nSolar radiation pressure with cylindrical and spherical Earth shadow models\nRelativistic effects for high-precision applications","category":"section"},{"location":"overview/#Advanced-Propagation-Methods","page":"Overview","title":"Advanced Propagation Methods","text":"High-order Runge-Kutta integrators with adaptive stepping\nSpecialized methods for different orbit regimes\nEvent detection and handling during propagation\nParallel processing for large trajectory sets","category":"section"},{"location":"overview/#Mission-Design-Tools","page":"Overview","title":"Mission Design Tools","text":"Lambert problem solvers for transfer trajectory design\nManeuver planning and optimization\nLaunch window analysis\nGround track and coverage analysis","category":"section"},{"location":"overview/#Modern-Development-Practices","page":"Overview","title":"Modern Development Practices","text":"Comprehensive test coverage across all packages\nContinuous integration and automated testing\nClear documentation with worked examples\nType-stable implementations for optimal performance","category":"section"},{"location":"overview/#Licensing-Model","page":"Overview","title":"Licensing Model","text":"We believe in the power of open source to foster innovation and community-driven  development and also recognize the need for a sustainable business model and a model that can handle export-controlled aerospace content. \n\nFor these reasons, Epicycle is offered under a tri-licensing model. The license allows users to choose between the following three options:\n\nLGPL v3.0\nEvaluation and Education use Only\nCommercial License","category":"section"},{"location":"overview/#Acknowledgments","page":"Overview","title":"Acknowledgments","text":"Epicycle builds upon the foundational work of many contributors to the aerospace and scientific computing communities:\n\nAstrodynamics Standards\n\nNASA GMAT Development Team for orbital mechanics algorithms and validation test cases\nDavid Vallado for \"Fundamentals of Astrodynamics and Applications\" formulations\nThe Astropy Project for rigorous time system standards and implementations\n\nJulia Scientific Computing Ecosystem\n\nSciML Organization for OrdinaryDiffEq.jl and the broader differential equations ecosystem\nJulia Astro community for SPICE.jl and astronomical coordinate systems\nBYU FLOW Lab for SNOW.jl optimization framework\nWächter & Biegler for the IPOPT nonlinear programming solver\n\nOpen Source Foundations\n\nJulia Computing and contributors for the Julia language\nThe Documenter.jl team for documentation generation\nGitHub Actions and the CI/CD community for automated testing infrastructure\n\nWe gratefully acknowledge these projects and their maintainers, whose work makes Epicycle possible.","category":"section"},{"location":"overview/#Contributing","page":"Overview","title":"Contributing","text":"To protect both contributors and our company, we use the Linux Kernel's Developer's  Certificate of Origin (DCO) as detailed in CONTRIBUTING.txt.","category":"section"},{"location":"overview/#Getting-Started","page":"Overview","title":"Getting Started","text":"New users should begin with the Getting Started guide, which walks through installation and basic usage patterns. The Tutorials section provides hands-on examples for common astrodynamics tasks.\n\nFor developers interested in extending Epicycle, each package maintains its own documentation with implementation details and contribution guidelines.","category":"section"},{"location":"overview/#Software-Architecture-2","page":"Overview","title":"Software Architecture","text":"","category":"section"},{"location":"overview/#Package-Hierarchy-2","page":"Overview","title":"Package Hierarchy","text":"Package Purpose\nAstroBase Core abstractions and type hierarchy\nAstroStates Orbital state representations and conversions\nAstroEpochs Time systems and epoch handling\nAstroUniverse Celestial body models and ephemeris\nAstroFrames Coordinate systems and transformations\nAstroModels Spacecraft and physical models\nAstroManeuvers Maneuver models and algorithms\nAstroCallbacks Quantities used in I/O, stopping conditions, cost, constraints\nAstroProp Trajectory propagation algorithms\nAstroSolve Optimization and constraint solving\nEpicycle The application.  using Epicycle loads everything.","category":"section"},{"location":"overview/#Dependency-Structure-2","page":"Overview","title":"Dependency Structure","text":"The packages are organized in layers to ensure clean separation of concerns:\n\nFoundation: Core types and constants that all other packages depend on\nDomain Specific: Specialized functionality for states, time, coordinates, etc.\nAnalysis Tools: Higher-level capabilities built on foundation components\nIntegration: User-facing interfaces and complete workflows","category":"section"},{"location":"overview/#Key-Features-2","page":"Overview","title":"Key Features","text":"","category":"section"},{"location":"overview/#Comprehensive-Force-Modeling-2","page":"Overview","title":"Comprehensive Force Modeling","text":"Gravitational perturbations (J2-J6, third-body, solid tides)\nAtmospheric drag with exponential and NRLMSISE-00 models\nSolar radiation pressure with cylindrical and spherical Earth shadow models\nRelativistic effects for high-precision applications","category":"section"},{"location":"overview/#Advanced-Propagation-Methods-2","page":"Overview","title":"Advanced Propagation Methods","text":"High-order Runge-Kutta integrators with adaptive stepping\nSpecialized methods for different orbit regimes\nEvent detection and handling during propagation\nParallel processing for large trajectory sets","category":"section"},{"location":"overview/#Mission-Design-Tools-2","page":"Overview","title":"Mission Design Tools","text":"Lambert problem solvers for transfer trajectory design\nManeuver planning and optimization\nLaunch window analysis\nGround track and coverage analysis","category":"section"},{"location":"overview/#Modern-Development-Practices-2","page":"Overview","title":"Modern Development Practices","text":"Comprehensive test coverage across all packages\nContinuous integration and automated testing\nClear documentation with worked examples\nType-stable implementations for optimal performance","category":"section"},{"location":"overview/#Licensing-Model-2","page":"Overview","title":"Licensing Model","text":"We believe in the power of open source to foster innovation and community-driven  development and also recognize the need for a sustainable business model and a model that can handle export-controlled aerospace content. \n\nFor these reasons, Epicycle is offered under a tri-licensing model. The license allows users to choose between the following three options:\n\nLGPL v3.0\nEvaluation and Education use Only\nCommercial License","category":"section"},{"location":"overview/#Acknowledgments-2","page":"Overview","title":"Acknowledgments","text":"Epicycle builds upon the foundational work of many contributors to the aerospace and scientific computing communities:\n\nAstrodynamics Standards\n\nNASA GMAT Development Team for orbital mechanics algorithms and validation test cases\nDavid Vallado for \"Fundamentals of Astrodynamics and Applications\" formulations\nThe Astropy Project for rigorous time system standards and implementations\n\nJulia Scientific Computing Ecosystem\n\nSciML Organization for OrdinaryDiffEq.jl and the broader differential equations ecosystem\nJulia Astro community for SPICE.jl and astronomical coordinate systems\nBYU FLOW Lab for SNOW.jl optimization framework\nWächter & Biegler for the IPOPT nonlinear programming solver\n\nOpen Source Foundations\n\nJulia Computing and contributors for the Julia language\nThe Documenter.jl team for documentation generation\nGitHub Actions and the CI/CD community for automated testing infrastructure\n\nWe gratefully acknowledge these projects and their maintainers, whose work makes Epicycle possible.","category":"section"},{"location":"overview/#Contributing-2","page":"Overview","title":"Contributing","text":"To protect both contributors and our company, we use the Linux Kernel's Developer's  Certificate of Origin (DCO) as detailed in CONTRIBUTING.txt.","category":"section"},{"location":"overview/#Getting-Started-2","page":"Overview","title":"Getting Started","text":"New users should begin with the Getting Started guide, which walks through installation and basic usage patterns. The Tutorials section provides hands-on examples for common astrodynamics tasks.\n\nFor developers interested in extending Epicycle, each package maintains its own documentation with implementation details and contribution guidelines.","category":"section"},{"location":"#Epicycle:-An-Application-for-Space-Mission-Design-and-Navigation","page":"Home","title":"Epicycle: An Application for Space Mission Design and Navigation","text":"Epicycle is a Julia package ecosystem for astrodynamics and space mission design, built with a modular architecture that spans mission analysis workflows from preliminary design through trajectory optimization. The current implementation - which is the initial release - focuses on establishing a robust architecture with key components—coordinate systems, time standards, spacecraft state representations, basic propagation, targeting and optimization—while providing extensible interfaces for systematic expansion toward operational mission design and navigation capabilities.\n\nThe ecosystem consists of eleven specialized packages organized in architectural layers, from core abstractions (AstroBase) through utilities (AstroEpochs, AstroStates, and AstroUniverse) to  integrated workflows (AstroManeuvers, AstroProp, and AstroSolve). The structure enables users to use low level utilities independently of the full system, or compose mission-specific analyses using interfaces designed to solve complex design problems, fast. The architecture in the first release is well tested and documented, and provides a clear pathway for extending capabilities toward high-fidelity force modeling, advanced optimization algorithms, and operational navigation applications as the framework matures.","category":"section"},{"location":"#Architecture-and-Components","page":"Home","title":"Architecture and Components","text":"","category":"section"},{"location":"#Development-Environment","page":"Home","title":"Development Environment","text":"Epicycle is designed to work seamlessly with modern development tools:\n\nVisual Studio Code with Julia Language Server provides comprehensive IDE features\nCode Intelligence through language-based completion and GitHub Copilot integration\nInteractive Development with integrated debugger and REPL workflow\nWorkspace Management for organizing multi-package projects","category":"section"},{"location":"#Package-Architecture","page":"Home","title":"Package Architecture","text":"The Epicycle ecosystem implements a layered architecture where each package provides focused functionality while maintaining clean interfaces for composition in workflows. Users can access the complete system through using Epicycle in Julia, or leverage individual components independently for specialized applications. The packages are organized from the integration layer down through foundational components: \n\nPackage Purpose\nEpicycle Integration layer providing unified interface and common workflows\nAstroBase Core abstractions, type hierarchy, and fundamental constants\nAstroStates Spacecraft state representations and state transformations\nAstroEpochs Time systems, epoch handling, and temporal conversions\nAstroUniverse Celestial body models, ephemeris data, and gravitational parameters\nAstroFrames Reference frames and coordinate system transformations\nAstroModels Spacecraft and physical models\nAstroManeuvers Maneuver models and algorithms\nAstroCallbacks Utilities for constraints, objectives, and events\nAstroProp Numerical integration and trajectory propagation methods\nAstroSolve Optimization algorithms and constraint solving capabilities","category":"section"},{"location":"#Current-Status","page":"Home","title":"Current Status","text":"The initial release of Epicycle provides a core architecture that integrates fundamental algorithms and models into an intuitive application for solving engineering problems. The model packages establish essential functionality while the architecture is designed for systematic expansion. The implementation maintains loose coupling between packages so lower-level components can be used independently of the full Epicycle application.\n\nThe system includes comprehensive test suites and documentation across all packages, with 95% code coverage and continuous integration on GitHub.  The software has been tested and validated on macOS, Linux, and Windows environments, with the architectural foundation established and core functionality implemented, making Epicycle ready for mission analysis workflows while maintaining an extensible design for advanced capabilities. \n\nAstrodynamics computations are tested against the General Mission Analysis Tool (GMAT) R2022a. Time conversion calculations are tested against Astropy.Time.","category":"section"},{"location":"#Why-New-Software","page":"Home","title":"Why New Software","text":"Julia is a modern, high-performance language designed for technical computing. It combines the ease of use found in MATLAB and Python with the performance of C/C++.\n\nMost aerospace tools require custom scripting interfaces or domain-specific languages. Julia serves as both the implementation language and the user interface, providing direct access to the full computational ecosystem. The language's design emphasizes scientific computing and automatic differentiation, both essential for aerospace optimization and navigation applications.\n\nHigh-Performance Numerical Analysis - Julia is designed for high-performance numerical analysis, making it suitable for complex scientific computations.\nEfficient Linear Algebra - Julia excels in linear algebra with efficient matrix operations and optimized algorithms.\nDifferential Equations - Julia provides advanced features for solving differential equations, making it suitable for complex scientific and engineering problems.\nSciML Machine Learning - Julia seamlessly integrates with SciML for machine learning, enhancing the capabilities for scientific machine learning applications.\nOptimization Tools - Julia interfaces seamlessly with optimization tools like SNOPT and IPOPT, facilitating the handling of complex tasks in technical computing.","category":"section"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"Epicycle builds upon the foundational work of many contributors to the aerospace and scientific computing communities:\n\nAstrodynamics Standards\n\nNASA GMAT Development Team for orbital mechanics specifications and validation test cases\nDavid Vallado, \"Fundamentals of Astrodynamics and Applications, 4th Edition\" (2013), Microcosm Press, for mathematical formulations and algorithmic references\nThe Astropy Project for rigorous time system standards and implementations\n\nJulia Scientific Computing Ecosystem\n\nSciML Organization for OrdinaryDiffEq.jl used in AstroProp\nJulia Astro community for SPICE.jl used in AstroUniverse\nBYU FLOW Lab for SNOW.jl used in AstroSolve\nJulia Space Mission Design for the TEMPO.jl library used in AstroEpochs \nWächter & Biegler for the IPOPT nonlinear programming solver\n\nOpen Source Foundations\n\nJulia Computing and contributors to the Julia language\nThe Documenter.jl team for documentation generation\nGitHub Actions and the CI/CD community for automated testing infrastructure\nVisual Studio Code, used to develop Epicycle and the recommended user interface\n\nWe gratefully acknowledge these projects and their maintainers, whose work makes Epicycle possible.","category":"section"},{"location":"#Core-Contributors","page":"Home","title":"Core Contributors","text":"Steve Hughes (steven.hughes at genastro.org), architect and lead developer.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"We believe in the power of open source to foster innovation and community-driven  development and also recognize the need for a sustainable business model and a model that can handle export-controlled aerospace content. \n\nFor these reasons, Epicycle is offered under a tri-licensing model. The license allows users to choose between the following three options:\n\nLGPL V3.0\nEvaluation and Education use Only\nCommercial License\n\nSee LICENSE.txt for the terms of each license option. For licensing questions contact licensing [at] genastro.org","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"To protect both contributors and our company, we use the Linux Kernel's Developer's  Certificate of Origin (DCO) as detailed in CONTRIBUTING.txt.","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"For support, including technical support and services to apply Epicycle to your application, contact support [at] genastro.org","category":"section"},{"location":"#What-is-an-Epicycle?","page":"Home","title":"What is an Epicycle?","text":"Humankind has been studying planetary motion for millennia. An epicycle is a geometric theory developed by Ptolemy to explain why planets appear to reverse direction and perform small loops in their celestial paths. While this model represented a significant advancement over earlier theories, it was ultimately incorrect—and it would be nearly 1500 years before Kepler developed a more accurate framework for understanding orbital mechanics.\n\nWe've come remarkably far in our understanding, yet fundamental questions remain. Either our theories of relativity, quantum mechanics, or both may be incomplete—reminding us that scientific discovery is an ongoing journey.\n\nThe Epicycle software is a tribute to the brilliant minds who came before us, celebrating how far we've advanced while embracing the excitement of continuing to push the boundaries of knowledge and make new discoveries. ","category":"section"}]
}
