<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AstroStates · AstroStates.jl</title><meta name="title" content="AstroStates · AstroStates.jl"/><meta property="og:title" content="AstroStates · AstroStates.jl"/><meta property="twitter:title" content="AstroStates · AstroStates.jl"/><meta name="description" content="Documentation for AstroStates.jl."/><meta property="og:description" content="Documentation for AstroStates.jl."/><meta property="twitter:description" content="Documentation for AstroStates.jl."/><meta property="og:url" content="https://GenAstro.github.io/Epicycle/AstroStates/"/><meta property="twitter:url" content="https://GenAstro.github.io/Epicycle/AstroStates/"/><link rel="canonical" href="https://GenAstro.github.io/Epicycle/AstroStates/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AstroStates</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#State-Overview"><span>State Overview</span></a></li><li><a class="tocitem" href="#OrbitState-Container"><span>OrbitState Container</span></a></li><li><a class="tocitem" href="#Conversions-Overview"><span>Conversions Overview</span></a></li><li><a class="tocitem" href="#Automatic-Differentiation"><span>Automatic Differentiation</span></a></li><li><a class="tocitem" href="#State-Types-Reference"><span>State Types Reference</span></a></li><li><a class="tocitem" href="#Conversions-Reference"><span>Conversions Reference</span></a></li><li><a class="tocitem" href="#API-Index"><span>API Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AstroStates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AstroStates</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenAstro/Epicycle" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenAstro/Epicycle/blob/main/AstroStates/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AstroStates"><a class="docs-heading-anchor" href="#AstroStates">AstroStates</a><a id="AstroStates-1"></a><a class="docs-heading-anchor-permalink" href="#AstroStates" title="Permalink"></a></h1><p>The AstroStates module provides models, structs, utilities, and conversions for orbital state representations. A state representation is a set of quantities that uniquely define an orbit. Supported forms include Cartesian, Keplerian, Modified Equinoctial, and others.</p><p>The module offers multiple interfaces for transforming and storing states. Low‑level conversion functions (e.g., <code>cart_to_kep.jl</code>) can be used directly. A type system automatically provides concrete structs for each representation (e.g., <code>CartesianState</code>) and converts between all supported permutations. The <code>OrbitState</code> utility preserves type stability when the representation may change by storing the numeric state and a type tag in separate fields. The library supports automatic differentiation with ForwardDiff.jl and Zygote.jl.</p><p>AstroStates is tested against output from the General Mission Analysis Tool (GMAT) R2022a.</p><p>References:</p><ul><li>Vallado, D. A. (2013), Fundamentals of Astrodynamics and Applications, 4th ed., Microcosm Press / Springer. </li><li>GMAT Development Team (2022), General Mission Analysis Tool (GMAT) Mathematical Specification, Version R2022a, NASA Goddard Space Flight Center. </li></ul><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><p>The example below illustrates how to create a state struct, perform conversions, inspect elements of a state, and how to view all supported types.  </p><pre><code class="language-julia hljs">using AstroStates

# Define a Cartesian state
cart = CartesianState([7000.0, 0.0, 100.0, 0.0, 7.5, 2.5])

# Convert to Keplerian then back to Cartesian
mu = 398600.4418 
kep   = KeplerianState(cart, mu)     
cart2 = CartesianState(kep, mu)     

# Display some state elements
kep.sma
kep.raan

# Generate a vector containing the state struct data
to_vector(kep)

# See a list of all supported representations
subtypes(AbstractOrbitState)</code></pre><p>The API is documented with docstrings; external references are intentionally omitted to avoid duplication. In the REPL, type <code>?</code> to enter help mode, then enter a name to view its documentation. For example, <code>?IncomingAsymptoteState</code> displays the incoming hyperbolic asymptote state, and <code>?cart_to_sphradec</code> shows the spherical RA/Dec conversion helper.</p><h2 id="State-Overview"><a class="docs-heading-anchor" href="#State-Overview">State Overview</a><a id="State-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#State-Overview" title="Permalink"></a></h2><p>AstroStates provides a library of state structs to create, store, and convert orbit states.  These structs derive from AbstractOrbitState. You can create states from numeric vectors or by converting from another state struct; conversions are performed automatically via overloaded constructors. State structs print readably and expose elements as fields. To list supported representations, run <code>subtypes(AbstractOrbitState)</code>. Kinematic conversions (e.g., Cartesian, Spherical) do not require mu, while conic element conversions (e.g., Keplerian, Modified Equinoctial) do.</p><pre><code class="language-julia hljs">using AstroStates

# Create a Cartesian state from a vector
c = CartesianState([7000.0, 0.0, 100.0, 0.0, 7.5, 2.5])

# Create a Keplerian state from individual elements.
k = KeplerianState(-98000.0, 2.6, pi/4, deg2rad(145), pi/8, 0.0 )

# Create a Keplerian state from a Cartesian State performing conversion automatically
mu = 398600.4415
k2 = KeplerianState(c, mu)

# Convert the Keplerian state to outgoing asymptote representation
h = OutGoingAsymptoteState(k, mu)

# Inspect elements of the states we just created.  Use &quot;?&quot; to see fields on a struct.
k.sma
c.posvel
h.c3</code></pre><h2 id="OrbitState-Container"><a class="docs-heading-anchor" href="#OrbitState-Container">OrbitState Container</a><a id="OrbitState-Container-1"></a><a class="docs-heading-anchor-permalink" href="#OrbitState-Container" title="Permalink"></a></h2><p>The OrbitState struct provides a type-stable container when the representation may change during a simulation but type stability is still required. For example, Epicycle’s Spacecraft uses OrbitState to accept different input representations and to switch state types during a run. OrbitState stores (1) the state data and (2) a tag that describes the representation. The tag is a state-type marker that parallels the concrete state struct names (e.g., Keplerian, Cartesian, etc.).</p><pre><code class="language-julia hljs">using AstroStates

# Create an OrbitState struct that stores the state and state type.
os = OrbitState([-98000.0, 2.6, pi/4, deg2rad(145), pi/8, 0.0 ],Keplerian())

# Print the state and type
println(os.state)
println(os.statetype)

# Create an OrbitState struct from a concrete type struct.
c = CartesianState([7000.0, 0.0, 100.0, 0.0, 7.5, 2.5])
os = OrbitState(c)

# See all available types
subtypes(AbstractOrbitStateType)</code></pre><hr/><h2 id="Conversions-Overview"><a class="docs-heading-anchor" href="#Conversions-Overview">Conversions Overview</a><a id="Conversions-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions-Overview" title="Permalink"></a></h2><p>The conversion functions in AstroStates are contained in individual files with function names like <code>cart_to_kep.jl</code>.  These functions can be used directly without the struct-based interfaces above when appropriate and when that is easier to integrate into other applications.  </p><pre><code class="language-julia hljs">using AstroStates

# Bypass structs and work directly with vectors, etc.  
mu = 398600.4415
k  = cart_to_kep([7000.0, 0.0, 100.0, 0.0, 7.5, 2.5], mu)

# Convert an equinoctial state to alternate equinoctial state
ae = equinoctial_to_alt_equinoctial([7758.763,-0.0047,0.09769,-0.00695,0.16227, 6.2762])</code></pre><p>The conversions are written to resemble astrodynamics textbooks with the intention that the code can serve as its own math spec. Here is an example from <code>kep_to_cart.jl</code>:</p><pre><code class="language-julia hljs">using LinearAlgebra

&quot;&quot;&quot;
    kep_to_cart(state::Vector{&lt;:Real}, μ::Real; tol::Float64=1e-12)

Convert a Keplerian state vector to a Cartesian state vector.

# Arguments
- `state::Vector{&lt;:Real}`: Keplerian elements `[a, e, i, Ω, ω, ν]`
- `μ`: Gravitational parameter
- `tol`: Tolerance for singularities like p ≈ 0 (default: 1e-12)
- `a`: semi-major axis
- `e`: eccentricity
- `i`: inclination
- `Ω`: right ascension of ascending node
- `ω`: argument of periapsis
- `ν`: true anomaly

# Returns
A 6-element vector `[x, y, z, vx, vy, vz]` representing Cartesian position and velocity.

# Example
cart = kep_to_cart([7000.0, 0.01, pi/4, 0.0, 0.0, pi/3], 398600.4418)

# Notes
- Angles must be in radians.
- Dimensional quantities must be consistent units with μ.
- Returns a vector of `NaN`s if conversion is undefined.
&quot;&quot;&quot;
function kep_to_cart(state::Vector{&lt;:Real}, μ::Real; tol::Float64=1e-12)
    if length(state) != 6
        error(&quot;Input vector must have exactly six elements: a, e, i, Ω, ω, ν.&quot;)
    end

    if μ &lt; tol
        @warn &quot;Conversion Failed: μ &lt; tolerance.&quot;
        return fill(NaN, 6)
    end

    # Unpack the elements
    a, e, i, Ω, ω, ν = state

    # Compute semi-latus rectum: p = a * (1 - e²)
    p = a * (1.0 - e^2)

    # Check for degenerate orbit (e.g., parabolic or collapsed)
    if p &lt; tol || abs(1-e) &lt; tol
        @warn &quot;Conversion Failed: Orbit is parabolic or singular.&quot;
        return fill(NaN, 6)
    end

    # Compute radial distance: r = p / (1 + e * cos(ν))
    r = p / (1.0 + e * cos(ν))

    # Position and velocity in perifocal frame 
    factor = sqrt(μ / p)
    r̄ₚ = [r * cos(ν), r * sin(ν), 0.0]
    v̄ₚ = [-factor * sin(ν), factor * (e + cos(ν)), 0.0]

    # Precompute sines and cosines for rotation matrix
    cos_Ω, sin_Ω = cos(Ω), sin(Ω)
    cos_ω, sin_ω = cos(ω), sin(ω)
    cos_i, sin_i = cos(i), sin(i)

    # Rotation matrix from perifocal to inertial
    R = [
        cos_ω * cos_Ω - sin_ω * cos_i * sin_Ω   -sin_ω * cos_Ω - cos_ω * cos_i * sin_Ω   sin_i * sin_Ω;
        cos_ω * sin_Ω + sin_ω * cos_i * cos_Ω   -sin_ω * sin_Ω + cos_ω * cos_i * cos_Ω  -sin_i * cos_Ω;
        sin_ω * sin_i                                    cos_ω * sin_i                   cos_i
    ]

    # Rotate position and velocity from perifocal to inertial frame
    pos = R * r̄ₚ
    vel = R * v̄ₚ 

    return vcat(pos, vel)
end</code></pre><hr/><h2 id="Automatic-Differentiation"><a class="docs-heading-anchor" href="#Automatic-Differentiation">Automatic Differentiation</a><a id="Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation" title="Permalink"></a></h2><p>All functions and conversions in AstroStates are fully differentiable using Julia&#39;s automatic differentation libraries ForwardDiff and Zygote. Examples for computing Jacobians are shown below.  </p><p>Note: The time to precompile AD interfaces is substantial, but those times are only incurred on the first execution and when included in loops or functions the times are orders of magnitude faster. REPL peformance for these examples is poor for that reason. </p><pre><code class="language-julia hljs">using ForwardDiff
using AstroStates

# Define the state vector and mu
x = [7000.0, 0.0, 100.0, 0.0, 7.5, 2.5]
mu = 398600.4418

# Define a function closure that returns a vector  
f(x) = to_vector(KeplerianState(CartesianState(x, mu), mu))

# Compute the Jacobian of Keplerian state w/r/t Cartesian State at x
J = ForwardDiff.jacobian(f, x)</code></pre><pre><code class="language-julia hljs">using Zygote
using AstroStates

# State vector and mu
x = [7000.0, 0.0, 100.0, 0.0, 7.5, 2.5]
mu = 398600.4418

# Define a function closure that returns a vector  
f(x) = to_vector(ModifiedEquinoctialState(CartesianState(x, mu), mu))

# Compute the Jacobian of Modified Equinoctial elements w/r/t Cartesian
J = first(Zygote.jacobian(f, x))  </code></pre><h2 id="State-Types-Reference"><a class="docs-heading-anchor" href="#State-Types-Reference">State Types Reference</a><a id="State-Types-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#State-Types-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.AlternateEquinoctialState" href="#AstroStates.AlternateEquinoctialState"><code>AstroStates.AlternateEquinoctialState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AlternateEquinoctialState(a, h, k, altp, altq, λ)</code></pre><p>Alternate equinoctial elements representation.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>a</code>: Semi-major axis. Defines orbit size and energy.<ul><li>Range: a ≠ 0. If a &gt; 0: elliptic orbit. If a &lt; 0: hyperbolic orbit.</li></ul></li><li><code>h</code>: Eccentricity vector h-component. h = e⋅sin(ω + Ω).<ul><li>Range: Any real value. Related to eccentricity and orientation.</li></ul></li><li><code>k</code>: Eccentricity vector k-component. k = e⋅cos(ω + Ω).<ul><li>Range: Any real value. Related to eccentricity and orientation.</li></ul></li><li><code>altp</code>: Alternate inclination vector p-component. altp = sin(i/2)⋅cos(Ω).<ul><li>Range: Any real value. Alternative inclination parameterization.</li></ul></li><li><code>altq</code>: Alternate inclination vector q-component. altq = sin(i/2)⋅sin(Ω).<ul><li>Range: Any real value. Alternative inclination parameterization.</li></ul></li><li><code>mlong</code>: Mean longitude (rad). Combined angle measure.<ul><li>Range: [0, 2π). Normalized mean longitude.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Alternative to standard equinoctial elements using sin(i/2) instead of tan(i/2).</li><li>Singularities reduced compared to classical elements.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">alteq = AlternateEquinoctialState(7000.0, 0.01, 0.0, 0.05, 0.0, π/4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L560-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.CartesianState" href="#AstroStates.CartesianState"><code>AstroStates.CartesianState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CartesianState(posvel)</code></pre><p>Cartesian position and velocity state representation.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li></ul><p><strong>Fields</strong></p><ul><li><code>posvel::Vector{T}</code>: 6-element position/velocity vector [x, y, z, vx, vy, vz]<ul><li><strong>Position components</strong> (x, y, z): Cartesian coordinates of spacecraft.<ul><li>Range: Any real values. </li></ul></li><li><strong>Velocity components</strong> (vx, vy, vz): Cartesian velocity vector components.<ul><li>Range: Any real values. </li></ul></li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = CartesianState([6778.0, 0.0, 0.0, 0.0, 7.66, 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L81-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.EquinoctialState" href="#AstroStates.EquinoctialState"><code>AstroStates.EquinoctialState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EquinoctialState(a, h, k, p, q, λ)</code></pre><p>Equinoctial orbital elements representation.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>a</code>: Semi-major axis. Defines orbit size and energy.<ul><li>Range: a ≠ 0. If a &gt; 0: elliptic orbit. If a &lt; 0: hyperbolic orbit.</li></ul></li><li><code>h</code>: Eccentricity vector h-component. h = e⋅sin(ω + Ω).<ul><li>Range: Any real value. Related to eccentricity and orientation.</li></ul></li><li><code>k</code>: Eccentricity vector k-component. k = e⋅cos(ω + Ω).<ul><li>Range: Any real value. Related to eccentricity and orientation.</li></ul></li><li><code>p</code>: Inclination vector p-component. p = tan(i/2)⋅cos(Ω).<ul><li>Range: Any real value. Related to inclination and node orientation.</li></ul></li><li><code>q</code>: Inclination vector q-component. q = tan(i/2)⋅sin(Ω).<ul><li>Range: Any real value. Related to inclination and node orientation.</li></ul></li><li><code>mlong</code>: Mean longitude (rad). Ω + ω + ν combined angle measure.<ul><li>Range: [0, 2π). Normalized mean longitude.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Singularities are reduced compared to classical elements but still exist for retrograde equatorial orbits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">eq = EquinoctialState(7000.0, 0.01, 0.0, 0.1, 0.0, π/4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L509-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.IncomingAsymptoteState" href="#AstroStates.IncomingAsymptoteState"><code>AstroStates.IncomingAsymptoteState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IncomingAsymptoteState(rp, c3, rla, dla, bpa, ta)</code></pre><p>Incoming asymptote parameters for hyperbolic trajectories.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>rp</code>: Periapsis radius. <ul><li>Range: rp &gt; 0.</li></ul></li><li><code>c3</code>: Characteristic energy. Specific energy at infinity (v∞²).<ul><li>-∞ &lt; c3 &lt; ∞, c3 &gt; 0 for hyperbolic trajectories.</li></ul></li><li><code>rla</code>: Right ascension of incoming asymptote (rad). <ul><li>Range: [0, 2π).</li></ul></li><li><code>dla</code>: Declination of incoming asymptote (rad). <ul><li>Range: [-π/2, π/2].</li></ul></li><li><code>bpa</code>: B-plane angle (rad). <ul><li>Range: [0, 2π).</li></ul></li><li><code>ta</code>: True anomaly at asymptote (rad). <ul><li>Range: [0, 2π).</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Singularities exist when trajectory becomes parabolic (c3 ≈ 0).</li><li>Singularities exist when e ≈ 0.  Note for elliptic orbits the apsides vector is used in place of the asymptote direction.</li><li>Singular when asymptote direction is aligned with the reference z-axis (dla = ±π/2).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inasym = IncomingAsymptoteState(6778.0, 5.0, 0.0, π/4, π/2, π/2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L395-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.KeplerianState" href="#AstroStates.KeplerianState"><code>AstroStates.KeplerianState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KeplerianState(a, e, i, raan, aop, ta)</code></pre><p>Keplerian orbital elements representation using classical osculating elements.</p><p><strong>Units</strong></p><ul><li>Distance/time units must be consistent with the gravitational parameter <code>μ</code> used in conversions.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>sma</code>: Semi-major axis (must be nonzero). Defines orbit size and energy.<ul><li>If sma &gt; 0: elliptic orbit (bound). If sma &lt; 0: hyperbolic orbit (unbound).</li><li>For elliptic orbits, sma is half the major axis length.</li></ul></li><li><code>ecc</code>: Eccentricity. Defines orbit shape.<ul><li>ecc = 0: circular orbit. 0 &lt; ecc &lt; 1: elliptical orbit.</li><li>ecc = 1: parabolic orbit. ecc &gt; 1: hyperbolic orbit.</li><li>Valid range: [0, ∞), but ecc ≈ 1 results in infinite sma.</li></ul></li><li><code>inc</code>: Inclination (rad). Angle between orbit plane and reference xy-plane.<ul><li>Range: [0, π]. If inc &lt; π/2: prograde orbit. If inc &gt; π/2: retrograde orbit.</li></ul></li><li><code>raan</code>: Right ascension of ascending node (rad). Orients the orbit plane.<ul><li>Range: [0, 2π). Angle from +x axis to ascending node, measured in xy-plane.</li><li>Defines where orbit plane intersects reference plane (ascending crossing).</li><li>Undefined for equatorial orbits (inc ≈ 0 or π).</li></ul></li><li><code>aop</code>: Argument of periapsis (rad). Orients the orbit within its plane.<ul><li>Range: [0, 2π). Angle from ascending node to periapsis point.</li><li>Defines orientation of orbit ellipse within the orbital plane.</li><li>Undefined for circular orbits (ecc ≈ 0).</li></ul></li><li><code>ta</code>: True anomaly (rad). Spacecraft position within the orbit.<ul><li>Range: [0, 2π). Angle from periapsis to current spacecraft position.</li><li>ta = 0: at periapsis. ta = π: at apoapsis (for elliptic orbits).</li><li>Undefined for circular orbits (ecc ≈ 0).</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Classical Keplerian elements have well-known singularities for special cases.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">k = KeplerianState(7000.0, 0.01, π/4, 0.0, 0.0, π/3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L125-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.ModifiedEquinoctialState" href="#AstroStates.ModifiedEquinoctialState"><code>AstroStates.ModifiedEquinoctialState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModifiedEquinoctialState(p, f, g, h, k, L)</code></pre><p>Modified equinoctial elements representation.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>p</code>: Semi-latus rectum. Parameter defining orbit size and shape.<ul><li>Range: p &gt; 0. Related to semi-major axis and eccentricity: p = a(1-e²).</li></ul></li><li><code>f</code>: Eccentricity vector f-component. f = e⋅cos(ω + Ω).<ul><li>Range: Any real value. Eccentricity component in perifocal frame.</li></ul></li><li><code>g</code>: Eccentricity vector g-component. g = e⋅sin(ω + Ω).<ul><li>Range: Any real value. Eccentricity component in perifocal frame.</li></ul></li><li><code>h</code>: Inclination vector h-component. h = tan(i/2)⋅cos(Ω).<ul><li>Range: Any real value. Inclination component related to ascending node.</li></ul></li><li><code>k</code>: Inclination vector k-component. k = tan(i/2)⋅sin(Ω).<ul><li>Range: Any real value. Inclination component related to ascending node.</li></ul></li><li><code>L</code>: True longitude (rad). Ω + ω + ν combined angle measure.<ul><li>Range: [0, 2π). True longitude from reference direction.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Singularities reduced compared to classical elements, but still exist for retrograde equatorial orbits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mee = ModifiedEquinoctialState(7000.0, 0.01, 0.0, 0.1, 0.0, π/4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L290-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.ModifiedKeplerianState" href="#AstroStates.ModifiedKeplerianState"><code>AstroStates.ModifiedKeplerianState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModifiedKeplerianState(rp, ra, inc, raan, aop, ta)</code></pre><p>Modified Keplerian orbital elements using periapsis and apoapsis radii instead of semi-major axis and eccentricity.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>rp</code>: Radius of periapsis. Closest approach distance to central body.<ul><li>Range: rp &gt; 0. Typically rp &gt; central body radius for physical orbits.</li></ul></li><li><code>ra</code>: Radius of apoapsis. Farthest distance from central body (elliptic orbits only).<ul><li>Range: ra ≥ rp for elliptic orbits. For hyperbolic orbits: ra = ∞ (not used).</li></ul></li><li><code>inc</code>: Inclination (rad). Angle between orbit plane and reference xy-plane.<ul><li>Range: [0, π]. If inc &lt; π/2: prograde orbit. If inc &gt; π/2: retrograde orbit.</li><li>inc = 0: equatorial orbit in xy-plane. inc = π/2: polar orbit.</li></ul></li><li><code>raan</code>: Right ascension of ascending node (rad). Orients the orbit plane.<ul><li>Range: [0, 2π). Angle from +x axis to ascending node, measured in xy-plane.</li><li>Defines where orbit plane intersects reference plane (ascending crossing).</li><li>Undefined for equatorial orbits (inc ≈ 0 or π).</li></ul></li><li><code>aop</code>: Argument of periapsis (rad). Orients the orbit within its plane.<ul><li>Range: [0, 2π). Angle from ascending node to periapsis point.</li><li>Defines orientation of orbit ellipse within the orbital plane.</li><li>Undefined for circular orbits (rp ≈ ra).</li></ul></li><li><code>ta</code>: True anomaly (rad). Spacecraft position within the orbit.<ul><li>Range: [0, 2π). Angle from periapsis to current spacecraft position.</li><li>ta = 0: at periapsis. ta = π: at apoapsis (for elliptic orbits).</li><li>Undefined for circular orbits (rp ≈ ra).</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Alternative to classical Keplerian elements using radius parameters instead of sma/ecc.</li><li>Shares same singularities as classical Keplerian elements for circular and equatorial orbits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 400 km x 35,786 km orbit (GTO-like)
modkep = ModifiedKeplerianState(6778.0, 42164.0, π/6, 0.0, 0.0, 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L449-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.OrbitState" href="#AstroStates.OrbitState"><code>AstroStates.OrbitState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrbitState(state::AbstractVector, statetype::AbstractOrbitStateType)</code></pre><p>A generic wrapper for orbital state vectors and their associated metadata.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: The numerical state vector (e.g., position/velocity, orbital elements). Must be a vector of real numbers.</li><li><code>statetype</code>: Marker instance indicating the state representation (e.g., <code>Cartesian()</code>, <code>Keplerian()</code>, etc.).</li><li><pre><code class="nohighlight hljs">         - to see all state types, use `subtypes(AbstractOrbitStateType)`.</code></pre></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">state_vec = [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]  # Cartesian position and velocity
os = OrbitState(state_vec, Cartesian())</code></pre><p><strong>Notes</strong></p><ul><li>Allows easy switching between different state representations without type instability.</li><li>The struct is internally parameterized for performance, and type safety, and differentiation, but users should construct it using the outer constructor as shown above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/orbit_state.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.OutGoingAsymptoteState" href="#AstroStates.OutGoingAsymptoteState"><code>AstroStates.OutGoingAsymptoteState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OutGoingAsymptoteState(rp, c3, rla, dla, bpa, ta)</code></pre><p>Outgoing asymptote parameters for hyperbolic trajectories.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>rp</code>: Periapsis radius. <ul><li>Range: rp &gt; 0.</li></ul></li><li><code>c3</code>: Characteristic energy. Specific energy at infinity (v∞²).<ul><li>-∞ &lt; c3 &lt; ∞, c3 &gt; 0 for hyperbolic trajectories.</li></ul></li><li><code>rla</code>: Right ascension of asymptote (rad). <ul><li>Range: [0, 2π).</li></ul></li><li><code>dla</code>: Declination of asymptote (rad). <ul><li>Range: [-π/2, π/2].</li></ul></li><li><code>bpa</code>: B-plane angle (rad). <ul><li>Range: [0, 2π).</li></ul></li><li><code>ta</code>: True anomaly at asymptote (rad). <ul><li>Range: [0, 2π).</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Singularities exist when trajectory becomes parabolic (c3 ≈ 0).</li><li>Singularities exist when e ≈ 0.  Note for elliptic orbits the apsides vector is used in place of the asymptote direction.</li><li>Singular when asymptote direction is aligned with the reference z-axis (dla = ±π/2).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">outasym = OutGoingAsymptoteState(6778.0, 5.0, 0.0, π/4, π/2, π/2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L341-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.SphericalAZIFPAState" href="#AstroStates.SphericalAZIFPAState"><code>AstroStates.SphericalAZIFPAState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalAZIFPAState(r, ra, dec, v, vazi, fpa)</code></pre><p>Spherical coordinates with azimuth and flight path angle velocity representation.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>r</code>: Radial distance from central body center. Magnitude of position vector.<ul><li>Range: r &gt; 0. </li></ul></li><li><code>ra</code>: Right ascension (rad). Azimuthal angle of position in xy-plane.<ul><li>Range: [0, 2π). Measured counterclockwise from +x axis.</li></ul></li><li><code>dec</code>: Declination (rad). Elevation angle of position above/below xy-plane.<ul><li>Range: [-π/2, π/2]. dec = 0: position in xy-plane. dec = ±π/2: at poles.</li></ul></li><li><code>v</code>: Magnitude of velocity vector. <ul><li>Range: v ≥ 0. </li></ul></li><li><code>vazi</code>: Velocity azimuth (rad). Horizontal direction of velocity vector.<ul><li>Range: [0, 2π). Angle east of north in local horizontal plane.</li><li>vazi = 0: northward velocity. vazi = π/2: eastward velocity.</li></ul></li><li><code>fpa</code>: Flight path angle (rad). Elevation of velocity above local horizontal.<ul><li>Range: [-π/2, π/2]. fpa = 0: horizontal flight. fpa &gt; 0: climbing.</li><li>fpa &lt; 0: descending flight. fpa = ±π/2: purely radial motion.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Singularities exist at r = 0 or v = 0 due to undefined angles.</li><li>Flight path angle and azimuth provide intuitive velocity direction description.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sph = SphericalAZIFPAState(6478.0, 0.0, π/4, 7.5, π/4, π/4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L236-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.SphericalRADECState" href="#AstroStates.SphericalRADECState"><code>AstroStates.SphericalRADECState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalRADECState(r, dec, ra, v, decv, rav)</code></pre><p>Spherical coordinates state with right ascension and declination components.</p><p><strong>Units</strong></p><ul><li>Distance and time units must be consistent with the gravitational parameter <code>μ</code> used in the simulation.</li><li>All angular quantities are in <strong>radians</strong>.</li></ul><p><strong>Fields (all <code>::T</code> where <code>T&lt;:Real</code>)</strong></p><ul><li><code>r</code>: Radial distance from central body center. <ul><li>Range: r &gt; 0.</li></ul></li><li><code>dec</code>: Declination (rad). Elevation angle of position above/below xy-plane.<ul><li>Range: [-π/2, π/2]. dec = 0: equatorial. dec = ±π/2: polar.</li></ul></li><li><code>ra</code>: Right ascension (rad). Azimuthal angle of position in xy-plane.<ul><li>Range: [0, 2π). Measured counterclockwise from +x axis.</li></ul></li><li><code>v</code>: Velocity magnitude. <ul><li>Range: v ≥ 0.</li></ul></li><li><code>decv</code>: Declination of velocity (rad). Elevation angle of velocity vector.<ul><li>Range: [-π/2, π/2]. Angle between velocity vector and xy-plane.</li></ul></li><li><code>rav</code>: Right ascension of velocity (rad). Azimuthal angle of velocity.<ul><li>Range: [0, 2π). Direction of velocity in xy-plane.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Parametric so automatic differentiation and high-precision types are supported.</li><li>Singularities exist at r = 0 or v = 0 due to undefined angles.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">radec = SphericalRADECState(6778.0, π/4, 0.0, 7.5, 0.0, π/2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/AstroStates.jl#L185-L216">source</a></section></article><h2 id="Conversions-Reference"><a class="docs-heading-anchor" href="#Conversions-Reference">Conversions Reference</a><a id="Conversions-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.alt_equinoctial_to_equinoctial-Tuple{Vector{&lt;:Real}}" href="#AstroStates.alt_equinoctial_to_equinoctial-Tuple{Vector{&lt;:Real}}"><code>AstroStates.alt_equinoctial_to_equinoctial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alt_equinoctial_to_equinoctial(alt::Vector{&lt;:Real}; tol::Float64 = 1e-12)</code></pre><p>Convert alternate equinoctial elements to standard equinoctial elements.</p><p><strong>Arguments</strong></p><ul><li><code>alt::Vector{&lt;:Real}</code>: Alternate equinoctial state <code>[a, h, k, altp, altq, λ]</code><ul><li><code>a</code> : semi-major axis [length]</li><li><code>h</code> : e⋅g component of eccentricity vector</li><li><code>k</code> : e⋅f component of eccentricity vector</li><li><code>altp</code> : sin(i/2)⋅cos(Ω)</li><li><code>altq</code> : sin(i/2)⋅sin(Ω)</li><li><code>λ</code> : mean longitude [rad]</li></ul></li><li><code>tol::Float64</code>: tolerance for inclination singularity (default = 1e-12)</li></ul><p><strong>Returns</strong></p><p>Standard equinoctial state <code>[a, h, k, p, q, λ]</code>     - <code>a</code>  : semi-major axis [length]     - <code>h</code>  : e⋅g component of eccentricity vector     - <code>k</code>  : e⋅f component of eccentricity vector     - <code>p</code>  : tan(i/2)⋅cos(Ω)     - <code>q</code>  : tan(i/2)⋅sin(Ω)     - <code>λ</code>  : mean longitude [rad]</p><p><strong>Notes</strong></p><ul><li>Fails if inclination approaches 180°.</li><li>All angles in radians. Units consistent with <code>μ</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">alt_eq = [7000.0, 0.01, 0.0, 0.05, 0.0, π/4]
std_eq = alt_equinoctial_to_equinoctial(alt_eq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/alt_equinoctial_to_equinoctial.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.cart_to_equinoctial-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.cart_to_equinoctial-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_equinoctial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart_to_equinoctial(cart::Vector{&lt;:Real}, μ::Real; tol::Float64 = 1e-12)</code></pre><p>Convert a Cartesian state vector to equinoctial orbital elements.</p><p><strong>Arguments</strong></p><ul><li><code>cart::Vector{&lt;:Real}</code>: Cartesian state <code>[x, y, z, vx, vy, vz]</code></li><li><code>μ::Real</code>: gravitational parameter [length³/time²]</li><li><code>tol::Float64</code>: tolerance for singularity detection (default = 1e-12)</li></ul><p><strong>Returns</strong></p><p>Equinoctial state <code>[a, h, k, p, q, λ]</code>:</p><ul><li><code>a</code> : semi-major axis [length]</li><li><code>h</code> : e⋅g component of eccentricity vector</li><li><code>k</code> : e⋅f component of eccentricity vector</li><li><code>p</code> : tan(i/2)⋅cos(Ω)</li><li><code>q</code> : tan(i/2)⋅sin(Ω)</li><li><code>λ</code> : mean longitude [rad]</li></ul><p><strong>Notes</strong></p><ul><li>Fails gracefully with <code>NaN</code> if orbit is hyperbolic, singular, or edge-case unsupported.</li><li>All angles are in radians. Units consistent with <code>μ</code>.</li><li>Note that in most cases in states, h is the magnitude of angular momentum.  But, not for equinoctial elements.  </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = [6778.0, 0.0, 0.0, 0.0, 7.66, 0.0]
equinoctial = cart_to_equinoctial(cart, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/cart_to_equinoctial.jl#L6-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.cart_to_inasymptote-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.cart_to_inasymptote-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_inasymptote</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart_to_inasymptote(cart::Vector{&lt;:Real}, μ::Real; tol::Float64 = 1e-12)</code></pre><p>Convert a Cartesian state to incoming asymptote parameters.</p><p><strong>Arguments</strong></p><ul><li><code>cart::Vector{&lt;:Real}</code>: Cartesian state <code>[x, y, z, vx, vy, vz]</code></li><li><code>μ::Real</code>: gravitational parameter</li><li><code>tol::Real</code>: tolerance for detecting singularities</li></ul><p><strong>Returns</strong></p><p>A 6-element vector: <code>[rₚ, C₃, λₐ, δₐ, θᵦ, ν]</code>  </p><ul><li>rₚ : radius of periapsis</li><li>C₃ : characteristic energy</li><li>λₐ : right ascension of incoming asymptote</li><li>δₐ : declination of incoming asymptote</li><li>θᵦ : B-plane angle</li><li>ν : true anomaly</li></ul><p><strong>Notes</strong></p><ul><li>Angles are in radians.</li><li>Dimensional quantities are consistent units with μ.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = [10000.0, 0.0, 0.0, 0.0, 12.0, 0.0]  # Hyperbolic trajectory
inasym = cart_to_inasymptote(cart, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/cart_to_inasymptote.jl#L6-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.cart_to_kep-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.cart_to_kep-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_kep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function cart_to_kep(cart::Vector{&lt;:Real}, μ::Real; tol::Float64=1e-12)</code></pre><p>Convert a Cartesian state vector to Keplerian orbital elements.</p><p><strong>Arguments</strong></p><ul><li><code>cart::Vector{Float64}</code>: Cartesian state <code>[x, y, z, vx, vy, vz]</code></li><li><code>μ::Real</code>: Gravitational parameter</li><li><code>tol::Float64</code>: Tolerance for detecting circular or equatorial orbits (default: <code>1e-12</code>)</li></ul><p><strong>Returns</strong></p><p>A vector <code>[a, e, i, Ω, ω, ν]</code> where:</p><ul><li><code>a</code>: semi-major axis</li><li><code>e</code>: eccentricity</li><li><code>i</code>: inclination</li><li><code>Ω</code>: right ascension of ascending node (RAAN)</li><li><code>ω</code>: argument of periapsis</li><li><code>ν</code>: true anomaly</li></ul><p><strong>Notes</strong></p><ul><li>Angles must be in radians.</li><li>Dimensional quantities must use consistent units with μ.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = [6778.0, 0.0, 0.0, 0.0, 7.66, 0.0]
kep = cart_to_kep(cart, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/cart_to_kep.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.cart_to_mee-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.cart_to_mee-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_mee</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart_to_mee(cart::Vector{&lt;:Real}, μ::Real; j::Float64 = 1.0)</code></pre><p>Convert Cartesian state to Modified Equinoctial Elements (MEE).</p><p><strong>Arguments</strong></p><ul><li><code>cart::Vector{&lt;:Real}</code>: 6-element vector <code>[x, y, z, vx, vy, vz]</code></li><li><code>μ::Real</code>: Gravitational parameter</li><li><code>j::Float64=1.0</code>: Optional constant (1 for prograde, -1 for retrograde), defaults to <code>1.0</code></li><li><code>tol::Float64</code>: Optional tolerance for singularity checking</li></ul><p><strong>Returns</strong></p><ul><li>A 6-element vector <code>[p, f, g, h, k, L]</code> representing the modified equinoctial elements.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = [6778.0, 0.0, 0.0, 0.0, 7.66, 0.0]
mee = cart_to_mee(cart, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/cart_to_mee.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.cart_to_outasymptote-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.cart_to_outasymptote-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_outasymptote</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart_to_outasymptote(cart::Vector{&lt;:Real}, μ::Real; tol::Float64 = 1e-12) -&gt; Vector{Float64}</code></pre><p>Convert a Cartesian state to outgoing asymptote parameters.</p><p><strong>Arguments</strong></p><ul><li><code>cart::Vector{&lt;:Real}</code>: Cartesian state <code>[x, y, z, vx, vy, vz]</code></li><li><code>μ::Real</code>: gravitational parameter</li><li><code>tol::Float64</code>: tolerance for detecting singularities</li></ul><p><strong>Returns</strong></p><p>A 6-element vector: <code>[rₚ, C₃, λₐ, δₐ, θᵦ, ν]</code>  </p><ul><li>rₚ : radius of periapsis</li><li>C₃ : characteristic energy</li><li>λₐ : right ascension of outgoing asymptote</li><li>δₐ : declination of outgoing asymptote</li><li>θᵦ : B-plane angle</li><li>ν : true anomaly</li></ul><p><strong>Notes</strong></p><ul><li>Angles are in radians.</li><li>Dimensional quantities are consistent with units of μ </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = [10000.0, 0.0, 0.0, 0.0, 12.0, 0.0]  # Hyperbolic trajectory
outasym = cart_to_outasymptote(cart, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/cart_to_outasymptote.jl#L6-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.cart_to_sphazfpa-Tuple{Vector{&lt;:Real}}" href="#AstroStates.cart_to_sphazfpa-Tuple{Vector{&lt;:Real}}"><code>AstroStates.cart_to_sphazfpa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart_to_sphazfpa(cart::Vector{&lt;:Real}; tol::Float64 = 1e-12)</code></pre><p>Convert a Cartesian state to Spherical AZ-FPA representation.</p><p><strong>Arguments</strong></p><ul><li><code>cart::Vector{&lt;:Real}</code>: Cartesian state <code>[x, y, z, vx, vy, vz]</code></li><li><code>tol::Float64</code>: Numerical tolerance for singularity checks (default: <code>1e-12</code>)</li></ul><p><strong>Returns</strong></p><p>A 6-element Spherical AZ-FPA state <code>[r, λ, δ, v, αₚ, ψ]</code>:</p><ul><li><code>r</code>   : radial distance [length]</li><li><code>λ</code>   : right ascension [rad]</li><li><code>δ</code>   : declination [rad]</li><li><code>v</code>   : velocity magnitude [length/time]</li><li><code>αₚ</code>  : flight path azimuth [rad]</li><li><code>ψ</code>   : flight path angle [rad]</li></ul><p><strong>Notes</strong></p><ul><li>Returns <code>fill(NaN, 6)</code> if <code>r</code> or <code>v</code> are near zero or orbit is singular</li><li>All angles are in radians.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = [6778.0, 0.0, 0.0, 0.0, 7.66, 0.0]
sphazfpa = cart_to_sphazfpa(cart)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/cart_to_sphazfpa.jl#L6-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.cart_to_sphradec-Tuple{Vector{&lt;:Real}}" href="#AstroStates.cart_to_sphradec-Tuple{Vector{&lt;:Real}}"><code>AstroStates.cart_to_sphradec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart_to_sphradec(state::Vector{&lt;:Real}; tol::Float64=1e-12)</code></pre><p>Convert a Cartesian state vector to a spherical RA/DEC state vector.</p><p><strong>Arguments</strong></p><ul><li><code>state::Vector{&lt;:Real}</code>: A 6-element vector <code>[x, y, z, vx, vy, vz]</code> representing Cartesian position and velocity.</li></ul><p><strong>Returns</strong></p><p>A 6-element vector <code>[r, ra, dec, v, vra, vdec]</code> where:</p><ul><li><code>r</code>  : magnitude of position vector </li><li><code>λᵣ</code> : right ascension (radians)</li><li><code>δᵣ</code> : declination (radians)</li><li><code>v</code>  : magnitude of velocity</li><li><code>λᵥ</code> : azimuthal direction of velocity (radians)</li><li><code>δᵥ</code> : elevation direction of velocity (radians)</li></ul><p><strong>Notes</strong></p><ul><li>Assumes all angles are in radians.</li><li>Units must be consistent between position and velocity components.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cart = [6778.0, 0.0, 0.0, 0.0, 7.66, 0.0]
sphradec = cart_to_sphradec(cart)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/cart_to_sphradec.jl#L6-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.equinoctial_to_alt_equinoctial-Tuple{Vector{&lt;:Real}}" href="#AstroStates.equinoctial_to_alt_equinoctial-Tuple{Vector{&lt;:Real}}"><code>AstroStates.equinoctial_to_alt_equinoctial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equinoctial_to_alt_equinoctial(eq::Vector{&lt;:Real}; tol::Float64 = 1e-12)</code></pre><p>Convert equinoctial elements to alternate equinoctial elements.</p><p><strong>Arguments</strong></p><ul><li><code>eq::Vector{&lt;:Real}</code>: Equinoctial state <code>[a, h, k, p, q, λ]</code><ul><li><code>a</code>  : semi-major axis [length]</li><li><code>h</code>  : e⋅g component of eccentricity vector</li><li><code>k</code>  : e⋅f component of eccentricity vector</li><li><code>p</code>  : tan(i/2)⋅cos(Ω)</li><li><code>q</code>  : tan(i/2)⋅sin(Ω)</li><li><code>λ</code>  : mean longitude [rad]</li></ul></li><li><code>tol::Float64</code>: tolerance for inclination singularity detection (default: 1e-12)</li></ul><p><strong>Returns</strong></p><p>Alternate equinoctial state <code>[a, h, k, altp, altq, λ]</code>     - <code>a</code> : semi-major axis [length]     - <code>h</code> : e⋅g component of eccentricity vector     - <code>k</code> : e⋅f component of eccentricity vector     - <code>altp</code> : sin(i/2)⋅cos(Ω)     - <code>altq</code> : sin(i/2)⋅sin(Ω)     - <code>λ</code> : mean longitude [rad]</p><p><strong>Notes</strong></p><ul><li>Singular when inclination is near 180°, returns <code>fill(NaN, 6)</code> in that case.</li><li>Units and angles must be consistent; λ in radians.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">eq = [7000.0, 0.01, 0.0, 0.1, 0.0, π/4]
alt_eq = equinoctial_to_alt_equinoctial(eq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/equinoctial_to_alt_equinoctial.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.equinoctial_to_cart-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.equinoctial_to_cart-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.equinoctial_to_cart</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equinoctial_to_cart(eq::Vector{&lt;:Real}, μ::Real; tol::Float64 = 1e-12)</code></pre><p>Convert equinoctial elements to Cartesian state.</p><p><strong>Arguments</strong></p><ul><li><code>eq::Vector{&lt;:Real}</code>: Equinoctial state <code>[a, h, k, p, q, λ]</code><ul><li><code>a</code> : semi-major axis [length]</li><li><code>h</code> : e⋅g component of eccentricity vector</li><li><code>k</code> : e⋅f component of eccentricity vector</li><li><code>p</code> : tan(i/2)⋅cos(Ω)</li><li><code>q</code> : tan(i/2)⋅sin(Ω)</li><li><code>λ</code> : mean longitude [rad]</li></ul></li><li><code>μ::Real</code>: gravitational parameter [length³/time²]</li><li><code>tol::Float64</code>: numerical tolerance (default: 1e-12)</li></ul><p><strong>Returns</strong></p><p>Cartesian state <code>[x, y, z, vx, vy, vz]</code></p><p><strong>Notes</strong></p><ul><li>Returns <code>fill(NaN, 6)</code> if eccentricity is too high or radius becomes non-physical.</li><li>Assumes all angles are in radians and other units are consistent with μ.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">eq = [7000.0, 0.01, 0.0, 0.1, 0.0, π/4]
cart = equinoctial_to_cart(eq, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/equinoctial_to_cart.jl#L6-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.inasymptote_to_kep-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.inasymptote_to_kep-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.inasymptote_to_kep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inasymptote_to_kep(outasym::Vector{&lt;:Real}, μ::Real; tol::Float64=1e-12)</code></pre><p>Convert incoming asymptote elements to Keplerian elements.</p><p><strong>Arguments</strong></p><ul><li><p><code>outasym</code>: Vector{&lt;:Real} of outgoing asymptote elements:</p><ul><li><code>rₚ</code>  : periapsis radius [length]</li><li><code>C₃</code>  : characteristic energy [length²/time²]</li><li><code>λₐ</code> : right ascension of the asymptote [rad]</li><li><code>δₐ</code> : declination of the asymptote [rad]</li><li><code>θᵦ</code> : B-plane angle [rad]</li><li><code>ν</code>  : true anomaly [rad]</li></ul></li><li><p><code>μ</code>: Gravitational parameter [length³/time²]</p></li><li><p><code>tol</code>: Singularity tolerance (default = 1e-12)</p></li></ul><p><strong>Returns</strong></p><ul><li>Keplerian state vector <code>[a, e, i, Ω, ω, ν]</code></li></ul><p><strong>Notes</strong></p><ul><li>Returns <code>fill(NaN, 6)</code> if singularity is detected.</li><li>Angles in radians. Units consistent with <code>μ</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inasym = [6778.0, 5.0, 0.0, π/4, π/2, π/2]
kep = inasymptote_to_kep(inasym, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/inasymptote_to_kep.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.kep_to_cart-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.kep_to_cart-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.kep_to_cart</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kep_to_cart(state::Vector{&lt;:Real}, μ::Real; tol::Float64=1e-12)</code></pre><p>Convert a Keplerian state vector to a Cartesian state vector.</p><p><strong>Arguments</strong></p><ul><li><code>state::Vector{&lt;:Real}</code>: Keplerian elements <code>[a, e, i, Ω, ω, ν]</code></li><li><code>μ</code>: Gravitational parameter</li><li><code>tol</code>: Tolerance for singularities like p ≈ 0 (default: 1e-12)</li><li><code>a</code>: semi-major axis</li><li><code>e</code>: eccentricity</li><li><code>i</code>: inclination</li><li><code>Ω</code>: right ascension of ascending node</li><li><code>ω</code>: argument of periapsis</li><li><code>ν</code>: true anomaly</li></ul><p><strong>Returns</strong></p><p>A 6-element vector <code>[x, y, z, vx, vy, vz]</code> representing Cartesian position and velocity.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">kep = [7000.0, 0.01, π/4, 0.0, 0.0, π/3]
cart = kep_to_cart(kep, 398600.4418)</code></pre><p><strong>Notes</strong></p><ul><li>Angles must be in radians.</li><li>Dimensional quantities must be consistent units with μ.</li><li>Returns a vector of <code>NaN</code>s if conversion is undefined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/kep_to_cart.jl#L6-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.kep_to_modkep-Tuple{Vector{&lt;:Real}}" href="#AstroStates.kep_to_modkep-Tuple{Vector{&lt;:Real}}"><code>AstroStates.kep_to_modkep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kep_to_modkep(kep::Vector{&lt;:Real}; tol::Float64 = 1e-12)</code></pre><p>Convert a classical Keplerian state to a Modified Keplerian state.</p><p><strong>Arguments</strong></p><ul><li><p><code>kep::Vector{&lt;:Real}</code>: Keplerian state vector <code>[a, e, i, Ω, ω, ν]</code></p><ul><li><code>a</code>  : semi-major axis </li><li><code>e</code>  : eccentricity</li><li><code>i</code>  : inclination </li><li><code>Ω</code>  : right ascension of ascending node </li><li><code>ω</code>  : argument of periapsis </li><li><code>ν</code>  : true anomaly </li></ul></li><li><p><code>tol::Float64</code>: tolerance for singularity and consistency checks (default = 1e-12)</p></li></ul><p><strong>Returns</strong></p><p>Modified Keplerian state <code>[rₚ, rₐ, i, Ω, ω, ν]</code> or <code>fill(NaN, 6)</code> if invalid.</p><p><strong>Notes</strong></p><ul><li>Parabolic orbits (<code>e ≈ 1</code>) and singular conics are not supported.</li><li>Units must be consistent. Angles in radians.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">kep = [7000.0, 0.01, π/4, 0.0, 0.0, π/3]
modkep = kep_to_modkep(kep)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/kep_to_modkep.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.mee_to_cart-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.mee_to_cart-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.mee_to_cart</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mee_to_cart(mod_equinoct::Vector{&lt;:Real}, μ::Real; j::Real = 1.0)</code></pre><p>Convert Modified Equinoctial Elements to Cartesian state.</p><p><strong>Arguments</strong></p><ul><li><code>mod_equinoct::Vector{&lt;:Real}</code>: Vector containing the Modified Equinoctial Elements [p, f, g, h, k, L]</li><li><code>μ::Real</code>: Gravitational parameter</li><li><code>j::Real=1.0</code>: Optional constant (1 for prograde, -1 for retrograde), defaults to <code>1.0</code></li></ul><p><strong>Returns</strong></p><ul><li>A 6-element vector <code>[x, y, z, vx, vy, vz]</code> representing the Cartesian position and velocity.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mee = [7000.0, 0.01, 0.0, 0.1, 0.0, π/4]
cart = mee_to_cart(mee, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/mee_to_cart.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.modkep_to_kep-Tuple{Vector{&lt;:Real}}" href="#AstroStates.modkep_to_kep-Tuple{Vector{&lt;:Real}}"><code>AstroStates.modkep_to_kep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modkep_to_kep(modkep::Vector{&lt;:Real}; tol::Float64 = 1e-12)</code></pre><p>Convert a Modified Keplerian state to a classical Keplerian state.</p><p><strong>Arguments</strong></p><ul><li><p><code>modkep::Vector{&lt;:Real}</code>: Modified Keplerian state vector <code>[rₚ, rₐ, i, Ω, ω, ν]</code></p><ul><li><code>rₚ</code> : radius of periapsis</li><li><code>rₐ</code> : radius of apoapsis </li><li><code>i</code>  : inclination </li><li><code>Ω</code>  : right ascension of ascending node </li><li><code>ω</code>  : argument of periapsis </li><li><code>ν</code>  : true anomaly</li></ul></li><li><p><code>tol::Float64</code>: tolerance for singularity and consistency checks (default = 1e-12)</p></li></ul><p><strong>Returns</strong></p><p>A classical Keplerian state <code>[a, e, i, Ω, ω, ν]</code> or <code>fill(NaN, 6)</code> if invalid.</p><p><strong>Notes</strong></p><ul><li>Returns <code>NaN</code> vector if input describes a parabolic, undefined, or inconsistent orbit.</li><li>Assumes input angles are in radians and distances use consistent units.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">modkep = [6778.0, 42164.0, π/6, 0.0, 0.0, 0.0]
kep = modkep_to_kep(modkep)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/modkep_to_kep.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.outasymptote_to_kep-Tuple{Vector{&lt;:Real}, Real}" href="#AstroStates.outasymptote_to_kep-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.outasymptote_to_kep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outasymptote_to_kep(outasym::Vector{&lt;:Real}, μ::Real; tol::Float64=1e-12)</code></pre><p>Convert outgoing asymptote elements to Keplerian elements.</p><p><strong>Arguments</strong></p><ul><li><p><code>outasym</code>: Vector{&lt;:Real} of outgoing asymptote elements:</p><ul><li><code>rₚ</code>  : periapsis radius [length]</li><li><code>C₃</code>  : characteristic energy [length²/time²]</li><li><code>λₐ</code> : right ascension of the asymptote [rad]</li><li><code>δₐ</code> : declination of the asymptote [rad]</li><li><code>θᵦ</code> : B-plane angle [rad]</li><li><code>ν</code>  : true anomaly [rad]</li></ul></li><li><p><code>μ</code>: Gravitational parameter [length³/time²]</p></li><li><p><code>tol</code>: Singularity tolerance (default = 1e-12)</p></li></ul><p><strong>Returns</strong></p><ul><li>Keplerian state vector <code>[a, e, i, Ω, ω, ν]</code></li></ul><p><strong>Notes</strong></p><ul><li>Returns <code>fill(NaN, 6)</code> if singularity is detected.</li><li>Angles in radians. Units consistent with <code>μ</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">outasym = [6778.0, 5.0, 0.0, π/4, π/2, π/2]
kep = outasymptote_to_kep(outasym, 398600.4418)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/outasymptote_to_kep.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.sphazfpa_to_cart-Tuple{Vector{&lt;:Real}}" href="#AstroStates.sphazfpa_to_cart-Tuple{Vector{&lt;:Real}}"><code>AstroStates.sphazfpa_to_cart</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sphazfpa_to_cart(spherical::Vector{&lt;:Real}) -&gt; Vector{&lt;:Real}</code></pre><p>Convert a Spherical AZ-FPA state to a Cartesian state vector.</p><p><strong>Arguments</strong></p><ul><li><code>spherical::Vector{&lt;:Real}</code>: Spherical AZ-FPA state vector <code>[r, λ, δ, v, αₚ, ψ]</code><ul><li><code>r</code>   : radial distance [length]</li><li><code>λ</code>   : right ascension [rad]</li><li><code>δ</code>   : declination [rad]</li><li><code>v</code>   : velocity magnitude [length/time]</li><li><code>αₚ</code>  : flight path azimuth (angle east of north in local horizon) [rad]</li><li><code>ψ</code>   : flight path angle (angle above local horizon) [rad]</li></ul></li></ul><p><strong>Returns</strong></p><p>A 6-element Cartesian state vector <code>[x, y, z, vx, vy, vz]</code>.</p><p><strong>Notes</strong></p><ul><li>All angles must be in radians.</li><li>Velocity frame uses local vertical/local horizontal.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sphazfpa = [6478.0, 0.0, π/4, 7.5, π/4, π/4]
cart = sphazfpa_to_cart(sphazfpa)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/sphazfpa_to_cart.jl#L6-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.sphradec_to_cart-Tuple{Vector{&lt;:Real}}" href="#AstroStates.sphradec_to_cart-Tuple{Vector{&lt;:Real}}"><code>AstroStates.sphradec_to_cart</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sphradec_to_cart(state::Vector{&lt;:Real}) -&gt; Vector{&lt;:Real}</code></pre><p>Convert a spherical RA/Dec state <code>[r, λᵣ, δᵣ, v, λᵥ, δᵥ]</code> to a Cartesian state <code>[x, y, z, vx, vy, vz]</code>.</p><p>Arguments</p><ul><li>state::Vector{&lt;:Real}: length-6 vector where:<ul><li>r   = position magnitude</li><li>λᵣ  = right ascension of position (radians)</li><li>δᵣ  = declination of position (radians)</li><li>v   = velocity magnitude</li><li>λᵥ  = azimuth of velocity direction (radians)</li><li>δᵥ  = elevation of velocity direction (radians)</li></ul></li></ul><p>Returns</p><ul><li>Vector{&lt;:Real}: length-6 Cartesian state <code>[x, y, z, vx, vy, vz]</code>.</li></ul><p>Notes</p><ul><li>All angles are in radians.</li><li>Units must be consistent between position and velocity components.</li><li>Right ascension typically in [0, 2π); declination in [-π/2, π/2].</li></ul><p>Examples</p><pre><code class="language-julia hljs">sphradec = [7000.0, 0.0, 0.0, 7.5, π/2, 0.0]
cart = sphradec_to_cart(sphradec)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/sphradec_to_cart.jl#L6-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AstroStates.to_state-Tuple{OrbitState}" href="#AstroStates.to_state-Tuple{OrbitState}"><code>AstroStates.to_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_state(os::OrbitState) -&gt; AbstractState</code></pre><p>Convert an <code>OrbitState</code> to its corresponding concrete state type (subtype of <code>AbstractState</code>), using the stored state vector and marker type.</p><p><strong>Arguments</strong></p><ul><li><code>os::OrbitState</code>: The <code>OrbitState</code> instance to convert.</li></ul><p><strong>Returns</strong></p><ul><li>The concrete state type (e.g., <code>CartesianState</code>, <code>KeplerianState</code>, etc.) corresponding to the <code>statetype</code> marker and the stored state vector.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">state_vec = [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]
os = OrbitState(state_vec, Cartesian())
cs = to_state(os)  # cs is a CartesianState

# For other state types:
os_kep = OrbitState([8000.0, 0.05, 0.1, 0.2, 0.3, 0.4], Keplerian())
ks = to_state(os_kep)  # ks is a KeplerianState</code></pre><p><strong>Notes</strong></p><ul><li>This function does not perform any physical conversions; it simply reconstructs the concrete state type from the stored vector and marker.</li><li>For conversions between different state types (e.g., <code>CartesianState</code> to <code>KeplerianState</code>), use the appropriate constructor or conversion function, providing additional parameters (such as <code>μ</code>) if required.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/7e4cea8cc2ad4581673dd9ae7262397572768fb4/AstroStates/src/orbit_state.jl#L128-L153">source</a></section></article><h2 id="API-Index"><a class="docs-heading-anchor" href="#API-Index">API Index</a><a id="API-Index-1"></a><a class="docs-heading-anchor-permalink" href="#API-Index" title="Permalink"></a></h2><ul><li><a href="#AstroStates.AlternateEquinoctialState"><code>AstroStates.AlternateEquinoctialState</code></a></li><li><a href="#AstroStates.CartesianState"><code>AstroStates.CartesianState</code></a></li><li><a href="#AstroStates.EquinoctialState"><code>AstroStates.EquinoctialState</code></a></li><li><a href="#AstroStates.IncomingAsymptoteState"><code>AstroStates.IncomingAsymptoteState</code></a></li><li><a href="#AstroStates.KeplerianState"><code>AstroStates.KeplerianState</code></a></li><li><a href="#AstroStates.ModifiedEquinoctialState"><code>AstroStates.ModifiedEquinoctialState</code></a></li><li><a href="#AstroStates.ModifiedKeplerianState"><code>AstroStates.ModifiedKeplerianState</code></a></li><li><a href="#AstroStates.OrbitState"><code>AstroStates.OrbitState</code></a></li><li><a href="#AstroStates.OutGoingAsymptoteState"><code>AstroStates.OutGoingAsymptoteState</code></a></li><li><a href="#AstroStates.SphericalAZIFPAState"><code>AstroStates.SphericalAZIFPAState</code></a></li><li><a href="#AstroStates.SphericalRADECState"><code>AstroStates.SphericalRADECState</code></a></li><li><a href="#AstroStates.alt_equinoctial_to_equinoctial-Tuple{Vector{&lt;:Real}}"><code>AstroStates.alt_equinoctial_to_equinoctial</code></a></li><li><a href="#AstroStates.cart_to_equinoctial-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_equinoctial</code></a></li><li><a href="#AstroStates.cart_to_inasymptote-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_inasymptote</code></a></li><li><a href="#AstroStates.cart_to_kep-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_kep</code></a></li><li><a href="#AstroStates.cart_to_mee-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_mee</code></a></li><li><a href="#AstroStates.cart_to_outasymptote-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.cart_to_outasymptote</code></a></li><li><a href="#AstroStates.cart_to_sphazfpa-Tuple{Vector{&lt;:Real}}"><code>AstroStates.cart_to_sphazfpa</code></a></li><li><a href="#AstroStates.cart_to_sphradec-Tuple{Vector{&lt;:Real}}"><code>AstroStates.cart_to_sphradec</code></a></li><li><a href="#AstroStates.equinoctial_to_alt_equinoctial-Tuple{Vector{&lt;:Real}}"><code>AstroStates.equinoctial_to_alt_equinoctial</code></a></li><li><a href="#AstroStates.equinoctial_to_cart-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.equinoctial_to_cart</code></a></li><li><a href="#AstroStates.inasymptote_to_kep-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.inasymptote_to_kep</code></a></li><li><a href="#AstroStates.kep_to_cart-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.kep_to_cart</code></a></li><li><a href="#AstroStates.kep_to_modkep-Tuple{Vector{&lt;:Real}}"><code>AstroStates.kep_to_modkep</code></a></li><li><a href="#AstroStates.mee_to_cart-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.mee_to_cart</code></a></li><li><a href="#AstroStates.modkep_to_kep-Tuple{Vector{&lt;:Real}}"><code>AstroStates.modkep_to_kep</code></a></li><li><a href="#AstroStates.outasymptote_to_kep-Tuple{Vector{&lt;:Real}, Real}"><code>AstroStates.outasymptote_to_kep</code></a></li><li><a href="#AstroStates.sphazfpa_to_cart-Tuple{Vector{&lt;:Real}}"><code>AstroStates.sphazfpa_to_cart</code></a></li><li><a href="#AstroStates.sphradec_to_cart-Tuple{Vector{&lt;:Real}}"><code>AstroStates.sphradec_to_cart</code></a></li><li><a href="#AstroStates.to_state-Tuple{OrbitState}"><code>AstroStates.to_state</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Sunday 9 November 2025 22:25">Sunday 9 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
