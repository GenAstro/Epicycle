<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AstroSolve.jl · AstroSolve.jl</title><meta name="title" content="AstroSolve.jl · AstroSolve.jl"/><meta property="og:title" content="AstroSolve.jl · AstroSolve.jl"/><meta property="twitter:title" content="AstroSolve.jl · AstroSolve.jl"/><meta name="description" content="Documentation for AstroSolve.jl."/><meta property="og:description" content="Documentation for AstroSolve.jl."/><meta property="twitter:description" content="Documentation for AstroSolve.jl."/><meta property="og:url" content="https://GenAstro.github.io/Epicycle/AstroSolve/"/><meta property="twitter:url" content="https://GenAstro.github.io/Epicycle/AstroSolve/"/><link rel="canonical" href="https://GenAstro.github.io/Epicycle/AstroSolve/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>AstroSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AstroSolve.jl</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Core-Functions"><span>Core Functions</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#A-More-Complex-Example"><span>A More Complex Example</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AstroSolve.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AstroSolve.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenAstro/Epicycle" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenAstro/Epicycle/blob/main/AstroSolve/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AstroSolve.jl"><a class="docs-heading-anchor" href="#AstroSolve.jl">AstroSolve.jl</a><a id="AstroSolve.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AstroSolve.jl" title="Permalink"></a></h1><p>AstroSolve provides a framework for solving astrodynamics design problems through constrained optimization and event-driven architecture. AstroSolve builds an event sequence as a Directed Acyclic Graph (DAG), which will soon be fully differentiable using AD. The DAG model for optimization is inspired by the architecture used in NASA&#39;s Copernicus software.  </p><p><strong>Reference:</strong> Jacob Williams, Robert Falck, and Izaak Beekman. &quot;Application of Modern Fortran to Spacecraft Trajectory Design and Optimization.&quot; <em>AIAA/AAS Space Flight Mechanics Meeting</em>, Kissimmee, FL, 2018. <a href="https://ntrs.nasa.gov/api/citations/20180000413/downloads/20180000413.pdf">Available online</a></p><p>AstroSolve&#39;s architecture is based on a few key user-facing components:</p><table><tr><th style="text-align: left">Component</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><strong>Models</strong></td><td style="text-align: left">Spacecraft, maneuvers, propagators, etc. that model the physics of the system</td></tr><tr><td style="text-align: left"><strong>SolverVariables</strong></td><td style="text-align: left">Optimization variables that the solver can adjust during trajectory design</td></tr><tr><td style="text-align: left"><strong>Constraints</strong></td><td style="text-align: left">Equality and inequality constraints that must be satisfied in the solution</td></tr><tr><td style="text-align: left"><strong>Events</strong></td><td style="text-align: left">Discrete mission phases that execute actions (propagate, maneuver, etc.) and apply constraints</td></tr><tr><td style="text-align: left"><strong>Sequence</strong></td><td style="text-align: left">DAG structure that defines event dependencies and execution order</td></tr></table><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><p>The example below uses AstroSolve&#39;s Event Sequence architecture to solve a simple orbit raising problem using IPOPT.</p><pre><code class="language-julia hljs">using Epicycle

# Create spacecraft with default orbital state
sat = Spacecraft()

# Create the propagator with point mass gravity model
gravity = PointMassGravity(earth, (moon, sun))
forces  = ForceModel(gravity)
integ   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)
prop    = OrbitPropagator(forces, integ)

# Create an impulsive maneuver (only V component will vary)
toi = ImpulsiveManeuver(
    axes = VNB(),
    element1 = 0.1,
)

# Define DeltaVVector of toi as a solver variable
# V component allowed to vary, N and B components constrained to zero
var_toi = SolverVariable(
    calc = ManeuverCalc(toi, sat, DeltaVVector()),
    name = &quot;toi&quot;,
    lower_bound = [-10.0, 0.0, 0.0],
    upper_bound = [10.0, 0.0, 0.0],
)

# Define a constraint on position magnitude of spacecraft
# Target apoapsis altitude of 55000 km
pos_target = 55000.0
pos_con = Constraint(
    calc = OrbitCalc(sat, PosMag()),
    lower_bounds = [pos_target],
    upper_bounds = [pos_target],
    scale = [1.0],
)

# Create an event that applies the maneuver with toi as optimization variable
fun_toi() = maneuver(sat, toi) 
toi_event = Event(name = &quot;TOI Maneuver&quot;, 
                  event = fun_toi,
                  vars = [var_toi],
                  funcs = [])

# Create propagation event to apoapsis with position constraint
fun_prop_apo() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))
prop_event = Event(name = &quot;Propagate to Apoapsis&quot;, 
                   event = fun_prop_apo,
                   funcs = [pos_con])

# Build sequence: maneuver first, then propagate to apoapsis
seq = Sequence()
add_events!(seq, prop_event, [toi_event]) 

# Solve trajectory optimization using default settings (finite differences, IPOPT)
result = trajectory_solve(seq)

# Write a report documenting sequence and solution
sequence_report(seq)
solution_report(seq, result)</code></pre><h2 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h2><p>This section contains reference material for the key user facing elements of AstroSolve. Note: Constraint is currently in the AstroCallbacks module but will be moved to AstroSolve in a future release. </p><article><details class="docstring" open="true"><summary id="AstroSolve.SolverVariable"><a class="docstring-binding" href="#AstroSolve.SolverVariable"><code>AstroSolve.SolverVariable</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">SolverVariable{C&lt;:AbstractCalc}</code></pre><p>Represents a solver-controlled variable defined by a calculation container for  trajectory optimization.</p><p><strong>Fields</strong></p><ul><li><code>calc::C</code>: Calculation container (e.g., <code>OrbitCalc</code>, <code>ManeuverCalc</code>, <code>BodyCalc</code>)</li><li><code>numvars::Int</code>: Number of scalar variables for this calculation</li><li><code>lower_bound::Vector{Float64}</code>: Lower bounds for optimization (length <code>numvars</code>,  defaults to <code>-Inf</code>)</li><li><code>upper_bound::Vector{Float64}</code>: Upper bounds for optimization (length <code>numvars</code>,  defaults to <code>+Inf</code>)</li><li><code>shift::Vector{Float64}</code>: Variable shifting for numerical conditioning  (length <code>numvars</code>, defaults to <code>0.0</code>)</li><li><code>scale::Vector{Float64}</code>: Variable scaling for numerical conditioning  (length <code>numvars</code>, defaults to <code>1.0</code>)</li><li><code>name::String</code>: Optional human-readable identifier</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SolverVariable(; calc, lower_bound=nothing, upper_bound=nothing, shift=nothing,
scale=nothing, name=&quot;&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>calc</code>: Calculation container implementing <code>AbstractCalc</code> interface</li><li><code>lower_bound</code>: Scalar or vector of lower bounds (broadcast to <code>numvars</code> if scalar)</li><li><code>upper_bound</code>: Scalar or vector of upper bounds (broadcast to <code>numvars</code> if scalar)  </li><li><code>shift</code>: Scalar or vector of shift values for numerical conditioning</li><li><code>scale</code>: Scalar or vector of scale factors for numerical conditioning</li><li><code>name</code>: Optional descriptive name for the variable</li></ul><p><strong>Notes</strong></p><ul><li>See <code>AbstractCalc</code> for supported calculation types</li><li><code>numvars</code> is automatically determined from the calculation variable type</li><li>Bounds, shift, and scale vectors are stored as <code>Float64</code> for optimizer compatibility</li><li>The calculation must support setting values (<code>calc_is_settable(calc.var) == true</code>) </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Epicycle

# Spacecraft and maneuver objects
sc = Spacecraft(); toi = ImpulsiveManeuver()

# 3D delta-V vector variable with individual component bounds
var_toi = SolverVariable(
    calc = ManeuverCalc(toi, sc, DeltaVVector()),
    lower_bound = [-2.0, -2.0, -2.0],
    upper_bound = [2.0, 2.0, 2.0],
    scale = [1.0, 1.0, 1.0],  
    name = &quot;Departure DV Vector&quot;
)

# Orbital element variable
var_sma = SolverVariable(
    calc = OrbitCalc(sc, SMA()),
    lower_bound = 6700.0,   
    upper_bound = 42000.0,  
    name = &quot;Target Semi-Major Axis&quot;
)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L136-L197">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.Event"><a class="docstring-binding" href="#AstroSolve.Event"><code>AstroSolve.Event</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Event</code></pre><p>Defines an event node for trajectory sequence execution in mission design workflows.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Human-readable identifier for the event</li><li><code>event::Function</code>: Function closure to execute when this node runs</li><li><code>vars::Vector{Any}</code>: Vector of solver variables (<code>SolverVariable</code>) associated with this event</li><li><code>funcs::Vector{Any}</code>: Vector of constraint/objective functions for this event</li></ul><p><strong>Notes</strong></p><p>Events are the fundamental building blocks of trajectory sequences, encapsulating both the action to be performed and the optimization variables/constraints associated with that action.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Simple propagation event
prop_event = Event(
    name = &quot;Propagate to Apoapsis&quot;,
    event = () -&gt; propagate(dynsys, integ, StopAtApoapsis(sat)),
)

# Event with solver variables and constraints
sc = Spacecraft(); toi = ImpulsiveManeuver();
var_dv = SolverVariable(
    calc = ManeuverCalc(toi, sc, DeltaVVector()),
)
fun_dv = Constraint(
    calc = ManeuverCalc(toi, sc, DeltaVMag()),
    lower_bounds = [0.1],
    upper_bounds = [0.1],
    scale = [1.0],
)
maneuver_event = Event(
    event = () -&gt; maneuver!(sc, toi),
    vars = [var_dv],
    funcs = [fun_dv],
    name = &quot;Departure Maneuver&quot;,
)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L40-L82">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.Sequence"><a class="docstring-binding" href="#AstroSolve.Sequence"><code>AstroSolve.Sequence</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Sequence</code></pre><p>A directed acyclic graph (DAG) representation of trajectory events for optimization.</p><p>In Epicycle, trajectories are modeled as sequences of events (maneuvers, propagations, etc.)  that must occur in a specific order. The <code>Sequence</code> struct represents this as a DAG where events are nodes and dependencies are edges.</p><p><strong>Fields</strong></p><ul><li><code>events::Vector{Event}</code>: Collection of all events in the sequence</li><li><code>adj_map::Dict{Event, Vector{Event}}</code>: Adjacency map defining event dependencies</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">seq = Sequence()
add_events!(seq, event1, Event[])          # Add root event
add_events!(seq, event2, [event1])         # event2 depends on event1
add_events!(seq, event3, [event1, event2]) # event3 depends on both</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L4-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.add_events!"><a class="docstring-binding" href="#AstroSolve.add_events!"><code>AstroSolve.add_events!</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">add_events!(seq::Sequence, event::Event, dependencies::Vector{Event})</code></pre><p>Add an event to the sequence with specified dependencies.</p><p>This function adds <code>event</code> to the sequence DAG, ensuring that all events in  <code>dependencies</code> must occur before <code>event</code> during execution. The internal adjacency  map is updated to reflect these dependencies.</p><p><strong>Arguments</strong></p><ul><li><code>seq::Sequence</code>: Sequence to modify</li><li><code>event::Event</code>: Event to add to the sequence</li><li><code>dependencies::Vector{Event}</code>: Events directly linked to and preceding <code>event</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">seq = Sequence()
add_events!(seq, maneuver_event, [prop_event])  # maneuver after propagation
add_events!(seq, final_event, [maneuver_event, other_event])  # final after both</code></pre><p>See also: <a href="#AstroSolve.Sequence"><code>Sequence</code></a>, <a href="#AstroSolve.topo_sort-Tuple{Sequence}"><code>topo_sort</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L244-L266">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.trajectory_solve"><a class="docstring-binding" href="#AstroSolve.trajectory_solve"><code>AstroSolve.trajectory_solve</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">trajectory_solve(seq::Sequence)</code></pre><p>Solve trajectory sequence using default SNOW/IPOPT configuration.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L654-L658">source</a></div><div><pre><code class="language-julia hljs">trajectory_solve(seq::Sequence, options::SNOW.Options)</code></pre><p>Solve trajectory sequence using specified SNOW optimization options.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L663-L667">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.sequence_report"><a class="docstring-binding" href="#AstroSolve.sequence_report"><code>AstroSolve.sequence_report</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">sequence_report(seq::Sequence)</code></pre><p>Generate a comprehensive report summarizing the trajectory sequence configuration.</p><p>This function creates a human-readable summary of the sequence structure showing:</p><ul><li>Sequence overview (total events, variables, constraints)</li><li>Event details with dependencies and execution order</li><li>Variable information (names, sizes, bounds)</li><li>Constraint summary (types, sizes, bounds)</li></ul><p><strong>Arguments</strong></p><ul><li><code>seq::Sequence</code>: Trajectory sequence to analyze</li></ul><p><strong>Returns</strong></p><ul><li>Nothing (prints directly to stdout for better formatting)</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L1-L17">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.solution_report"><a class="docstring-binding" href="#AstroSolve.solution_report"><code>AstroSolve.solution_report</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">solution_report(seq::Sequence, result)</code></pre><p>Generate a comprehensive report showing the optimized trajectory solution.</p><p>This function displays the optimization results including variable values, constraint satisfaction, and solution summary. It works with the result from <code>trajectory_solve()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>seq::Sequence</code>: Original trajectory sequence</li><li><code>result</code>: Result tuple from trajectory_solve with (variables, objective, info)</li></ul><p><strong>Returns</strong></p><ul><li>Nothing (prints directly to stdout for better formatting)</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L300-L315">source</a></div></details></article><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><ul><li><a href="#AstroSolve.Event-Tuple{}"><code>AstroSolve.Event</code></a></li><li><a href="#AstroSolve.Event"><code>AstroSolve.Event</code></a></li><li><a href="#AstroSolve.Sequence-Tuple{}"><code>AstroSolve.Sequence</code></a></li><li><a href="#AstroSolve.Sequence"><code>AstroSolve.Sequence</code></a></li><li><a href="#AstroSolve.SequenceManager"><code>AstroSolve.SequenceManager</code></a></li><li><a href="#AstroSolve.SequenceManager-Tuple{Sequence}"><code>AstroSolve.SequenceManager</code></a></li><li><a href="#AstroSolve.SolverVariable"><code>AstroSolve.SolverVariable</code></a></li><li><a href="#AstroSolve.SolverVariable-Union{Tuple{}, Tuple{C}} where C&lt;:AbstractCalc"><code>AstroSolve.SolverVariable</code></a></li><li><a href="#AstroSolve._push_stateful!-Tuple{Vector{Any}, IdSet, Any}"><code>AstroSolve._push_stateful!</code></a></li><li><a href="#AstroSolve.add_events!"><code>AstroSolve.add_events!</code></a></li><li><a href="#AstroSolve.add_events!-Tuple{Sequence, Event, Vector{Event}}"><code>AstroSolve.add_events!</code></a></li><li><a href="#AstroSolve.apply_event-Tuple{Event}"><code>AstroSolve.apply_event</code></a></li><li><a href="#AstroSolve.copy_struct_fields!-Tuple{Any, Any}"><code>AstroSolve.copy_struct_fields!</code></a></li><li><a href="#AstroSolve.default_snow_options-Tuple{}"><code>AstroSolve.default_snow_options</code></a></li><li><a href="#AstroSolve.find_all_stateful_structs-Tuple{Any, Any}"><code>AstroSolve.find_all_stateful_structs</code></a></li><li><a href="#AstroSolve.format_bounds"><code>AstroSolve.format_bounds</code></a></li><li><a href="#AstroSolve.get_bounds_description-Tuple{Any, Any}"><code>AstroSolve.get_bounds_description</code></a></li><li><a href="#AstroSolve.get_calc_description-Tuple{Any}"><code>AstroSolve.get_calc_description</code></a></li><li><a href="#AstroSolve.get_enhanced_constraint_description-Tuple{Any}"><code>AstroSolve.get_enhanced_constraint_description</code></a></li><li><a href="#AstroSolve.get_enhanced_variable_description-Tuple{SolverVariable}"><code>AstroSolve.get_enhanced_variable_description</code></a></li><li><a href="#AstroSolve.get_event_constraint_mapping-Tuple{SequenceManager}"><code>AstroSolve.get_event_constraint_mapping</code></a></li><li><a href="#AstroSolve.get_fun_lower_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_fun_lower_bounds</code></a></li><li><a href="#AstroSolve.get_fun_upper_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_fun_upper_bounds</code></a></li><li><a href="#AstroSolve.get_fun_values-Tuple{SequenceManager}"><code>AstroSolve.get_fun_values</code></a></li><li><a href="#AstroSolve.get_simplified_type_name-Tuple{Any}"><code>AstroSolve.get_simplified_type_name</code></a></li><li><a href="#AstroSolve.get_sol_var-Tuple{SolverVariable}"><code>AstroSolve.get_sol_var</code></a></li><li><a href="#AstroSolve.get_subject_description-Tuple{Any}"><code>AstroSolve.get_subject_description</code></a></li><li><a href="#AstroSolve.get_var_lower_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_var_lower_bounds</code></a></li><li><a href="#AstroSolve.get_var_lower_bounds-Tuple{Any}"><code>AstroSolve.get_var_lower_bounds</code></a></li><li><a href="#AstroSolve.get_var_scales-Tuple{Any}"><code>AstroSolve.get_var_scales</code></a></li><li><a href="#AstroSolve.get_var_shifts-Tuple{Any}"><code>AstroSolve.get_var_shifts</code></a></li><li><a href="#AstroSolve.get_var_upper_bounds-Tuple{Any}"><code>AstroSolve.get_var_upper_bounds</code></a></li><li><a href="#AstroSolve.get_var_upper_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_var_upper_bounds</code></a></li><li><a href="#AstroSolve.get_var_values-Tuple{SequenceManager}"><code>AstroSolve.get_var_values</code></a></li><li><a href="#AstroSolve.get_var_values-Tuple{Any}"><code>AstroSolve.get_var_values</code></a></li><li><a href="#AstroSolve.order_unique_vars-Tuple{Vector{Event}}"><code>AstroSolve.order_unique_vars</code></a></li><li><a href="#AstroSolve.reset_stateful_structs!-Tuple{SequenceManager}"><code>AstroSolve.reset_stateful_structs!</code></a></li><li><a href="#AstroSolve.sequence_report"><code>AstroSolve.sequence_report</code></a></li><li><a href="#AstroSolve.sequence_report-Tuple{Sequence}"><code>AstroSolve.sequence_report</code></a></li><li><a href="#AstroSolve.set_sol_var-Tuple{SolverVariable, Vector}"><code>AstroSolve.set_sol_var</code></a></li><li><a href="#AstroSolve.set_var_values-Tuple{Vector, Vector{SolverVariable}}"><code>AstroSolve.set_var_values</code></a></li><li><a href="#AstroSolve.set_var_values-Tuple{SequenceManager, AbstractVector}"><code>AstroSolve.set_var_values</code></a></li><li><a href="#AstroSolve.show_constraint_components-Tuple{Any, Bool}"><code>AstroSolve.show_constraint_components</code></a></li><li><a href="#AstroSolve.show_variable_components-Tuple{SolverVariable, Bool}"><code>AstroSolve.show_variable_components</code></a></li><li><a href="#AstroSolve.solution_report-Tuple{Sequence, Any}"><code>AstroSolve.solution_report</code></a></li><li><a href="#AstroSolve.solution_report"><code>AstroSolve.solution_report</code></a></li><li><a href="#AstroSolve.solver_fun!-Tuple{AbstractVector, AbstractVector, SequenceManager}"><code>AstroSolve.solver_fun!</code></a></li><li><a href="#AstroSolve.topo_sort-Tuple{Sequence}"><code>AstroSolve.topo_sort</code></a></li><li><a href="#AstroSolve.trajectory_solve-Tuple{Sequence, Options}"><code>AstroSolve.trajectory_solve</code></a></li><li><a href="#AstroSolve.trajectory_solve-Tuple{Sequence}"><code>AstroSolve.trajectory_solve</code></a></li><li><a href="#AstroSolve.trajectory_solve"><code>AstroSolve.trajectory_solve</code></a></li><li><a href="#Base.show-Tuple{IO, SolverVariable}"><code>Base.show</code></a></li><li><a href="#Base.show-Tuple{IO, Event}"><code>Base.show</code></a></li></ul><article><details class="docstring" open="true"><summary id="AstroSolve.Event-Tuple{}"><a class="docstring-binding" href="#AstroSolve.Event-Tuple{}"><code>AstroSolve.Event</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Event(; name::String = &quot;&quot;, event::Function = () -&gt; nothing, vars = [], funcs = [])</code></pre><p>Outer constructor for Event with kwargs.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L128-L132">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.Sequence-Tuple{}"><a class="docstring-binding" href="#AstroSolve.Sequence-Tuple{}"><code>AstroSolve.Sequence</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Sequence()</code></pre><p>Create an empty trajectory sequence with no events or dependencies.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L30-L34">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.SequenceManager"><a class="docstring-binding" href="#AstroSolve.SequenceManager"><code>AstroSolve.SequenceManager</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">SequenceManager</code></pre><p>Orchestrator for trajectory sequence execution and optimization.</p><p>The <code>SequenceManager</code> prepares and manages a <code>Sequence</code> for iterative optimization. It topologically sorts events, orders variables and constraints, extracts bounds and scaling parameters, and manages stateful object restoration.</p><p><strong>Fields</strong></p><ul><li><code>sequence::Sequence</code>: Original sequence definition</li><li><code>sorted_events::Vector{Event}</code>: Topologically sorted events for execution</li><li><code>ordered_vars::Vector{SolverVariable}</code>: Unique variables in dependency order</li><li><code>ordered_funcs::Vector{Constraint}</code>: All constraints in execution order</li><li><code>fun_sizes::Vector{Int}</code>: Number of scalar constraints per constraint function</li><li><code>var_shift::Vector</code>: Concatenated variable shift parameters for scaling</li><li><code>var_scale::Vector</code>: Concatenated variable scale parameters for scaling  </li><li><code>var_lower_bounds::Vector</code>: Concatenated lower bounds for all variables</li><li><code>var_upper_bounds::Vector</code>: Concatenated upper bounds for all variables</li><li><code>stateful_structs::Vector{Any}</code>: All stateful objects referenced in sequence</li><li><code>initial_stateful_structs::Vector{Any}</code>: Deep copies for state restoration</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">seq = Sequence()
add_events!(seq, event1, Event[])
add_events!(seq, event2, [event1])
sm = SequenceManager(seq)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L39-L68">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.SequenceManager-Tuple{Sequence}"><a class="docstring-binding" href="#AstroSolve.SequenceManager-Tuple{Sequence}"><code>AstroSolve.SequenceManager</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">SequenceManager(seq::Sequence)</code></pre><p>Construct a sequence manager from a trajectory sequence.</p><p>This constructor performs several optimization steps:</p><ol><li>Topologically sorts events to ensure dependency ordering</li><li>Extracts unique variables while preserving dependency order</li><li>Collects all constraints with their sizes</li><li>Identifies and snapshots all stateful objects for reset capability</li><li>Pre-computes variable bounds and scaling parameters</li></ol><p><strong>Notes</strong></p><ul><li><code>ErrorException</code>: If sequence contains cycles (not a valid DAG)</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L83-L97">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.SolverVariable-Union{Tuple{}, Tuple{C}} where C&lt;:AbstractCalc"><a class="docstring-binding" href="#AstroSolve.SolverVariable-Union{Tuple{}, Tuple{C}} where C&lt;:AbstractCalc"><code>AstroSolve.SolverVariable</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">SolverVariable(; calc, lower_bound=nothing, upper_bound=nothing, shift=nothing, scale=nothing, name=&quot;&quot;)</code></pre><p>Convenience constructor that automatically infers the calculation type parameter <code>C</code> from the <code>calc</code> argument.</p><p>This eliminates the need to explicitly specify the type parameter when creating <code>SolverVariable</code> instances.</p><p><strong>Usage Comparison</strong></p><pre><code class="language-julia hljs"># Without convenience constructor (explicit type parameter):
var1 = SolverVariable{OrbitCalc}(calc=OrbitCalc(sat, SemiMajorAxis()))

# With convenience constructor (type inferred):
var2 = SolverVariable(calc=OrbitCalc(sat, SemiMajorAxis()))  # Preferred</code></pre><p>This constructor delegates to <code>SolverVariable{C}(...)</code> with the inferred type.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L233-L250">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve._push_stateful!-Tuple{Vector{Any}, IdSet, Any}"><a class="docstring-binding" href="#AstroSolve._push_stateful!-Tuple{Vector{Any}, IdSet, Any}"><code>AstroSolve._push_stateful!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">_push_stateful!(out::Vector{Any}, seen::IdSet, objs)</code></pre><p>Push unique stateful objects to output vector, preserving discovery order.</p><p>Only objects that are marked as stateful (via <code>is_astrosolve_stateful</code>) and not already seen are added to the output collection.</p><p><strong>Arguments</strong></p><ul><li><code>out::Vector{Any}</code>: Output collection to append to</li><li><code>seen::IdSet</code>: Set tracking already discovered objects</li><li><code>objs</code>: Collection of objects to check and potentially add</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Any}</code>: The modified output vector (for chaining)</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L123-L138">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.add_events!-Tuple{Sequence, Event, Vector{Event}}"><a class="docstring-binding" href="#AstroSolve.add_events!-Tuple{Sequence, Event, Vector{Event}}"><code>AstroSolve.add_events!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">add_events!(seq::Sequence, event::Event, dependencies::Vector{Event})</code></pre><p>Add an event to the sequence with specified dependencies.</p><p>This function adds <code>event</code> to the sequence DAG, ensuring that all events in  <code>dependencies</code> must occur before <code>event</code> during execution. The internal adjacency  map is updated to reflect these dependencies.</p><p><strong>Arguments</strong></p><ul><li><code>seq::Sequence</code>: Sequence to modify</li><li><code>event::Event</code>: Event to add to the sequence</li><li><code>dependencies::Vector{Event}</code>: Events directly linked to and preceding <code>event</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">seq = Sequence()
add_events!(seq, maneuver_event, [prop_event])  # maneuver after propagation
add_events!(seq, final_event, [maneuver_event, other_event])  # final after both</code></pre><p>See also: <a href="#AstroSolve.Sequence"><code>Sequence</code></a>, <a href="#AstroSolve.topo_sort-Tuple{Sequence}"><code>topo_sort</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L244-L266">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.apply_event-Tuple{Event}"><a class="docstring-binding" href="#AstroSolve.apply_event-Tuple{Event}"><code>AstroSolve.apply_event</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">apply_event(event::Event)</code></pre><p>Execute the event&#39;s function closure.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L305-L309">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.copy_struct_fields!-Tuple{Any, Any}"><a class="docstring-binding" href="#AstroSolve.copy_struct_fields!-Tuple{Any, Any}"><code>AstroSolve.copy_struct_fields!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">copy_struct_fields!(dest, src)</code></pre><p>Recursively copy all fields from <code>src</code> to <code>dest</code> struct, preserving mutable references.</p><p>This function performs deep copying for stateful struct restoration. For arrays, it overwrites contents rather than replacing references. For nested mutable structs, it recursively copies fields.</p><p><strong>Arguments</strong></p><ul><li><code>dest</code>: Destination struct to copy into</li><li><code>src</code>: Source struct to copy from</li></ul><p><strong>Returns</strong></p><ul><li>Modified <code>dest</code> struct</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L187-L202">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.default_snow_options-Tuple{}"><a class="docstring-binding" href="#AstroSolve.default_snow_options-Tuple{}"><code>AstroSolve.default_snow_options</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">default_snow_options()</code></pre><p>Create default SNOW optimization options.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L689-L693">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.find_all_stateful_structs-Tuple{Any, Any}"><a class="docstring-binding" href="#AstroSolve.find_all_stateful_structs-Tuple{Any, Any}"><code>AstroSolve.find_all_stateful_structs</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">find_all_stateful_structs(ordered_vars, sorted_events)</code></pre><p>Find all unique stateful structs referenced by SolverVariables and events.</p><p>Stateful structs are objects that maintain state during trajectory propagation and need to be reset between optimization iterations. This function discovers all such objects referenced throughout the sequence.</p><p><strong>Arguments</strong></p><ul><li><code>ordered_vars::Vector{SolverVariable}</code>: Ordered optimization variables</li><li><code>sorted_events::Vector{Event}</code>: Topologically sorted events</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Any}</code>: Collection of unique stateful objects in discovery order</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L149-L164">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.format_bounds"><a class="docstring-binding" href="#AstroSolve.format_bounds"><code>AstroSolve.format_bounds</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">format_bounds(lower, upper, size=1)</code></pre><p>Format numeric bounds for display with consistent precision.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L128-L132">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_bounds_description-Tuple{Any, Any}"><a class="docstring-binding" href="#AstroSolve.get_bounds_description-Tuple{Any, Any}"><code>AstroSolve.get_bounds_description</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_bounds_description(lower, upper)</code></pre><p>Describe bounds as equality, inequality, or range constraints.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L237-L241">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_calc_description-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_calc_description-Tuple{Any}"><code>AstroSolve.get_calc_description</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_calc_description(calc)</code></pre><p>Extract calculation description from calc objects.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L180-L184">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_enhanced_constraint_description-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_enhanced_constraint_description-Tuple{Any}"><code>AstroSolve.get_enhanced_constraint_description</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_enhanced_constraint_description(func)</code></pre><p>Get enhanced constraint description with calc info for display.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L162-L166">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_enhanced_variable_description-Tuple{SolverVariable}"><a class="docstring-binding" href="#AstroSolve.get_enhanced_variable_description-Tuple{SolverVariable}"><code>AstroSolve.get_enhanced_variable_description</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_enhanced_variable_description(var::SolverVariable)</code></pre><p>Get enhanced variable description with calc info for display.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L141-L145">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_event_constraint_mapping-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.get_event_constraint_mapping-Tuple{SequenceManager}"><code>AstroSolve.get_event_constraint_mapping</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_event_constraint_mapping(sm::SequenceManager)</code></pre><p>Create mapping from events to their constraints for reporting.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L472-L476">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_fun_lower_bounds-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.get_fun_lower_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_fun_lower_bounds</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_fun_lower_bounds(sm::SequenceManager)</code></pre><p>Extract lower bounds from all constraint functions in the sequence manager.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing constraint functions</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated lower bounds for all constraints</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L525-L535">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_fun_upper_bounds-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.get_fun_upper_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_fun_upper_bounds</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_fun_upper_bounds(sm::SequenceManager)</code></pre><p>Extract upper bounds from all constraint functions in the sequence manager.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing constraint functions</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated upper bounds for all constraints</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L510-L520">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_fun_values-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.get_fun_values-Tuple{SequenceManager}"><code>AstroSolve.get_fun_values</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_fun_values(sm::SequenceManager)</code></pre><p>Evaluate all constraint functions in the sequence manager and return  concatenated function values.</p><p>This function evaluates all constraints in the current state and returns their values as a flat vector. The ordering matches the constraint order established during SequenceManager construction.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing constraints to evaluate</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Concatenated constraint function values</li></ul><p><strong>Notes</strong></p><p>This function assumes all stateful objects are in the correct state for constraint evaluation (typically after event sequence execution).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L570-L589">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_simplified_type_name-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_simplified_type_name-Tuple{Any}"><code>AstroSolve.get_simplified_type_name</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_simplified_type_name(obj)</code></pre><p>Simplify type names by removing module prefixes and parameters.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L287-L291">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_sol_var-Tuple{SolverVariable}"><a class="docstring-binding" href="#AstroSolve.get_sol_var-Tuple{SolverVariable}"><code>AstroSolve.get_sol_var</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_sol_var(var::SolverVariable)</code></pre><p>Get the solver variable values from the struct.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L294-L298">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_subject_description-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_subject_description-Tuple{Any}"><code>AstroSolve.get_subject_description</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_subject_description(subject)</code></pre><p>Get subject description with type and name information.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L213-L217">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_lower_bounds-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_var_lower_bounds-Tuple{Any}"><code>AstroSolve.get_var_lower_bounds</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_lower_bounds(ordered_vars)</code></pre><p>Extract lower bounds from all solver variables into a flat vector.</p><p><strong>Arguments</strong></p><ul><li><code>ordered_vars::Vector{SolverVariable}</code>: Variables to extract bounds from</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated lower bounds for optimization constraints</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L450-L460">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_lower_bounds-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.get_var_lower_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_var_lower_bounds</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_lower_bounds(sm::SequenceManager)</code></pre><p>Extract lower bounds from all variables in the sequence manager.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing variables</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated lower bounds for optimization constraints</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L465-L475">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_scales-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_var_scales-Tuple{Any}"><code>AstroSolve.get_var_scales</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_scales(ordered_vars)</code></pre><p>Extract scale parameters from all solver variables into a flat vector.</p><p><strong>Arguments</strong></p><ul><li><code>ordered_vars::Vector{SolverVariable}</code>: Variables to extract scales from</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated scale values for optimization scaling</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L435-L445">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_shifts-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_var_shifts-Tuple{Any}"><code>AstroSolve.get_var_shifts</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_shifts(ordered_vars)</code></pre><p>Extract shift parameters from all solver variables into a flat vector.</p><p><strong>Arguments</strong></p><ul><li><code>ordered_vars::Vector{SolverVariable}</code>: Variables to extract shifts from</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated shift values for optimization scaling</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L420-L430">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_upper_bounds-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_var_upper_bounds-Tuple{Any}"><code>AstroSolve.get_var_upper_bounds</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_upper_bounds(ordered_vars)</code></pre><p>Extract upper bounds from all solver variables into a flat vector.</p><p><strong>Arguments</strong></p><ul><li><code>ordered_vars::Vector{SolverVariable}</code>: Variables to extract bounds from</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated upper bounds for optimization constraints</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L480-L490">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_upper_bounds-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.get_var_upper_bounds-Tuple{SequenceManager}"><code>AstroSolve.get_var_upper_bounds</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_upper_bounds(sm::SequenceManager)</code></pre><p>Extract upper bounds from all variables in the sequence manager.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing variables</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated upper bounds for optimization constraints</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L495-L505">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_values-Tuple{Any}"><a class="docstring-binding" href="#AstroSolve.get_var_values-Tuple{Any}"><code>AstroSolve.get_var_values</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_values(ordered_vars)</code></pre><p>Extract current values from all SolverVariables into a flat vector.</p><p><strong>Arguments</strong></p><ul><li><code>ordered_vars::Vector{SolverVariable}</code>: Variables to extract values from</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated values from all variables</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L390-L400">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.get_var_values-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.get_var_values-Tuple{SequenceManager}"><code>AstroSolve.get_var_values</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_var_values(sm::SequenceManager)</code></pre><p>Extract current values from all variables in the sequence manager.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing variables</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Concatenated values from all variables</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L405-L415">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.order_unique_vars-Tuple{Vector{Event}}"><a class="docstring-binding" href="#AstroSolve.order_unique_vars-Tuple{Vector{Event}}"><code>AstroSolve.order_unique_vars</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">order_unique_vars(sorted_events::Vector{Event})</code></pre><p>Extract unique solver variables from events in dependency order.</p><p>This function processes topologically sorted events and extracts all unique SolverVariables while preserving the order of first appearance. This ensures variables are ordered according to their dependency relationships.</p><p><strong>Arguments</strong></p><ul><li><code>sorted_events::Vector{Event}</code>: Events in topological order</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{SolverVariable}</code>: Unique variables in dependency order</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L347-L361">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.reset_stateful_structs!-Tuple{SequenceManager}"><a class="docstring-binding" href="#AstroSolve.reset_stateful_structs!-Tuple{SequenceManager}"><code>AstroSolve.reset_stateful_structs!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">reset_stateful_structs!(sm::SequenceManager)</code></pre><p>Reset all stateful structs in the sequence manager to their initial state.</p><p>This function is called before each optimization iteration to ensure a clean starting state for trajectory propagation. It restores all spacecraft, maneuvers, and other stateful objects to their initial conditions.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing stateful objects to reset</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L225-L236">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.sequence_report-Tuple{Sequence}"><a class="docstring-binding" href="#AstroSolve.sequence_report-Tuple{Sequence}"><code>AstroSolve.sequence_report</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">sequence_report(seq::Sequence)</code></pre><p>Generate a comprehensive report summarizing the trajectory sequence configuration.</p><p>This function creates a human-readable summary of the sequence structure showing:</p><ul><li>Sequence overview (total events, variables, constraints)</li><li>Event details with dependencies and execution order</li><li>Variable information (names, sizes, bounds)</li><li>Constraint summary (types, sizes, bounds)</li></ul><p><strong>Arguments</strong></p><ul><li><code>seq::Sequence</code>: Trajectory sequence to analyze</li></ul><p><strong>Returns</strong></p><ul><li>Nothing (prints directly to stdout for better formatting)</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L1-L17">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.set_sol_var-Tuple{SolverVariable, Vector}"><a class="docstring-binding" href="#AstroSolve.set_sol_var-Tuple{SolverVariable, Vector}"><code>AstroSolve.set_sol_var</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">set_sol_var(var::SolverVariable, val::Vector)</code></pre><p>Set the value(s) of the solver variable struct</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L272-L276">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.set_var_values-Tuple{SequenceManager, AbstractVector}"><a class="docstring-binding" href="#AstroSolve.set_var_values-Tuple{SequenceManager, AbstractVector}"><code>AstroSolve.set_var_values</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">set_var_values(sm::SequenceManager, x::AbstractVector)</code></pre><p>Set all solver variables in the sequence manager to values from vector <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sm::SequenceManager</code>: Sequence manager containing ordered variables</li><li><code>x::AbstractVector</code>: Flat vector of variable values</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L377-L385">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.set_var_values-Tuple{Vector, Vector{SolverVariable}}"><a class="docstring-binding" href="#AstroSolve.set_var_values-Tuple{Vector, Vector{SolverVariable}}"><code>AstroSolve.set_var_values</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">set_var_values(vec::Vector, ordered_vars::Vector{SolverVariable})</code></pre><p>Set values for an ordered collection of solver variables from a flat vector.</p><p>This function distributes values from a flat optimization vector to the appropriate SolverVariables, handling the different sizes of vector vs scalar variables correctly.</p><p><strong>Arguments</strong></p><ul><li><code>vec::Vector</code>: Flat vector of values to distribute</li><li><code>ordered_vars::Vector{SolverVariable}</code>: Variables to set in order</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Set 3 variables: 2 scalars + 1 3-vector
x = [1.0, 2.0, 0.1, 0.2, 0.3]  # 5 total values
set_var_values(x, [scalar1, scalar2, vector3])</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L540-L558">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.show_constraint_components-Tuple{Any, Bool}"><a class="docstring-binding" href="#AstroSolve.show_constraint_components-Tuple{Any, Bool}"><code>AstroSolve.show_constraint_components</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">show_constraint_components(func, is_last_constraint::Bool)</code></pre><p>Show constraint component breakdown with proper indentation.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L271-L275">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.show_variable_components-Tuple{SolverVariable, Bool}"><a class="docstring-binding" href="#AstroSolve.show_variable_components-Tuple{SolverVariable, Bool}"><code>AstroSolve.show_variable_components</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">show_variable_components(var::SolverVariable, is_last_var::Bool)</code></pre><p>Show variable component breakdown with proper indentation.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L255-L259">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.solution_report-Tuple{Sequence, Any}"><a class="docstring-binding" href="#AstroSolve.solution_report-Tuple{Sequence, Any}"><code>AstroSolve.solution_report</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solution_report(seq::Sequence, result)</code></pre><p>Generate a comprehensive report showing the optimized trajectory solution.</p><p>This function displays the optimization results including variable values, constraint satisfaction, and solution summary. It works with the result from <code>trajectory_solve()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>seq::Sequence</code>: Original trajectory sequence</li><li><code>result</code>: Result tuple from trajectory_solve with (variables, objective, info)</li></ul><p><strong>Returns</strong></p><ul><li>Nothing (prints directly to stdout for better formatting)</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence_report.jl#L300-L315">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.solver_fun!-Tuple{AbstractVector, AbstractVector, SequenceManager}"><a class="docstring-binding" href="#AstroSolve.solver_fun!-Tuple{AbstractVector, AbstractVector, SequenceManager}"><code>AstroSolve.solver_fun!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solver_fun!(F::AbstractVector, x::AbstractVector, sm::SequenceManager)</code></pre><p>Core optimization function: set variables, execute sequence, and evaluate constraints.</p><p>This is the primary interface between optimization solvers and Epicycle trajectory sequences. It performs a complete trajectory execution cycle:</p><ol><li><strong>Reset</strong>: Restore all stateful objects to initial conditions</li><li><strong>Set Variables</strong>: Apply optimization variables to events </li><li><strong>Execute</strong>: Run events in topological order, applying maneuvers and propagations, etc.</li><li><strong>Evaluate</strong>: Collect function values at appropriate times during execution</li></ol><p><strong>Arguments</strong></p><ul><li><code>F::AbstractVector</code>: Output vector to fill with constraint values</li><li><code>x::AbstractVector</code>: Input optimization variables (flat vector)</li><li><code>sm::SequenceManager</code>: Configured sequence manager</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Status code (0 for success)</li></ul><p><strong>Notes</strong></p><ul><li>Function values are evaluated immediately after their associated events to capture the correct spacecraft state at that point in the trajectory</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L602-L626">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.topo_sort-Tuple{Sequence}"><a class="docstring-binding" href="#AstroSolve.topo_sort-Tuple{Sequence}"><code>AstroSolve.topo_sort</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">topo_sort(seq::Sequence)</code></pre><p>Perform topological sorting of events using Kahn&#39;s algorithm.</p><p>This function sorts the events in the sequence. If event A depends on event B,  then B will appear before A in the sorted output. </p><p><strong>Arguments</strong></p><ul><li><code>seq::Sequence</code>: Sequence containing events and their dependencies</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Event}</code>: Events sorted in dependency order (dependencies first)</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the sequence contains cycles (not a valid DAG)</li></ul><p><strong>Algorithm</strong></p><p>Uses Kahn&#39;s algorithm:</p><ol><li>Calculate in-degree for all events</li><li>Start with events having no dependencies (in-degree 0)  </li><li>Remove events and update in-degrees until all processed</li><li>Detect cycles if any events remain unprocessed</li></ol><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L281-L304">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.trajectory_solve-Tuple{Sequence, Options}"><a class="docstring-binding" href="#AstroSolve.trajectory_solve-Tuple{Sequence, Options}"><code>AstroSolve.trajectory_solve</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">trajectory_solve(seq::Sequence, options::SNOW.Options)</code></pre><p>Solve trajectory sequence using specified SNOW optimization options.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L663-L667">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AstroSolve.trajectory_solve-Tuple{Sequence}"><a class="docstring-binding" href="#AstroSolve.trajectory_solve-Tuple{Sequence}"><code>AstroSolve.trajectory_solve</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">trajectory_solve(seq::Sequence)</code></pre><p>Solve trajectory sequence using default SNOW/IPOPT configuration.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/sequence.jl#L654-L658">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, Event}"><a class="docstring-binding" href="#Base.show-Tuple{IO, Event}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Base.show(io::IO, event::Event)</code></pre><p>Display method for <code>Event</code> showing name, actual variable count, and function count.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L90-L94">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, SolverVariable}"><a class="docstring-binding" href="#Base.show-Tuple{IO, SolverVariable}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><div><p>Base.show(io::IO, sv::SolverVariable)</p><p>Show method for <code>SolverVariable</code> that displays key information about the variable.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/GenAstro/Epicycle/blob/fc557e45f7b7027a051ea8c2f5eb748f64c7d92a/AstroSolve/src/AstroSolve.jl#L255-L260">source</a></div></details></article><hr/><h2 id="A-More-Complex-Example"><a class="docs-heading-anchor" href="#A-More-Complex-Example">A More Complex Example</a><a id="A-More-Complex-Example-1"></a><a class="docs-heading-anchor-permalink" href="#A-More-Complex-Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">
using Epicycle

# ========== Create Models =================================================================
# Create spacecraft
sat = Spacecraft(
    state = CartesianState([3737.792, -4607.692, -2845.644, 5.411, 5.367, -1.566]),
    time = Time(&quot;2000-01-01T11:59:28.000&quot;, UTC(), ISOT())  # J2000 epoch from GMAT
)

# Create simple Earth point mass dynamics (no third bodies for now)
gravity = PointMassGravity(earth, ())  # Only Earth gravity
forces  = ForceModel(gravity)
integ   = IntegratorConfig(DP8(); abstol=1e-12, reltol=1e-12, dt=60.0)
prop    = OrbitPropagator(forces, integ)

# Define maneuver models
toi = ImpulsiveManeuver(
    axes = VNB(),
    element1 = 1.518,
    element2 = 0.0,
    element3 = 0.0,
)

mcc = ImpulsiveManeuver(
    axes = VNB(),
    element1 = 0.559,
    element2 = 0.588,
    element3 = 0.0,
)

moi = ImpulsiveManeuver(
    axes = VNB(),
    element1 = -0.282,
    element2 = 0.0,
    element3 = 0.0,
)

# ========== Define Solver Variables ======================================================
# TOI: Only vary V component (Element1)
var_toi_v = SolverVariable(
    calc = ManeuverCalc(toi, sat, DeltaVVector()),
    name = &quot;toi_v&quot;,
    lower_bound = [-5.0, 0.0, 0.0],  # Only V component varies significantly
    upper_bound = [5.0, 0.0, 0.0],
)

# MCC: Vary V and N components (Element1 and Element2)
var_mcc_vn = SolverVariable(
    calc = ManeuverCalc(mcc, sat, DeltaVVector()),
    name = &quot;mcc_vn&quot;,
    lower_bound = [-2.0, -2.0, -0.001],   # V and N components vary
    upper_bound = [2.0, 2.0, 0.001],
)

# MOI: Only vary V component (Element1)
var_moi_v = SolverVariable(
    calc = ManeuverCalc(moi, sat, DeltaVVector()),
    name = &quot;moi_v&quot;,
    lower_bound = [-2.0, -0.001, -0.001],  # Only V component varies significantly
    upper_bound = [2.0, 0.001, 0.001],
)

# ========== Define Constraints ===========================================================
# Constraint: Apoapsis radius = 85,000 km after TOI
apogee_radius_con = Constraint(
    calc = OrbitCalc(sat, PosMag()),
    lower_bounds = [85000.0],
    upper_bounds = [85000.0],
    scale = [1.0],
)

# Constraint: Inclination = 2° after MCC
inclination_con = Constraint(
    calc = OrbitCalc(sat, Inc()),
    lower_bounds = [deg2rad(2.0)],
    upper_bounds = [deg2rad(2.0)],
    scale = [1.0],
)

# Constraint: Perigee radius = 42,195 km after MCC
perigee_radius_con = Constraint(
    calc = OrbitCalc(sat, PosMag()),
    lower_bounds = [42195.0],
    upper_bounds = [42195.0],
    scale = [1.0],
)

# Constraint: Final SMA = 42,166.90 km (GEO) after MOI
final_sma_con = Constraint(
    calc = OrbitCalc(sat, SMA()),
    lower_bounds = [42166.90],
    upper_bounds = [42166.90],
    scale = [1.0],
)

# ========== Define events (variables, constraints, actions) ==============================
# Event 1: Propagate to Z=0 crossing (equatorial plane)
prop_to_z_crossing_1_fun() = propagate(prop, sat, StopAt(sat, PosZ(), 0.0))
prop_to_z_crossing_1_event = Event(
    name = &quot;Prop to Z 1&quot;,
    event = prop_to_z_crossing_1_fun,
)

# Event 2: Apply TOI maneuver
toi_fun() = maneuver(sat, toi)
toi_event = Event(
    name = &quot;TOI&quot;,
    event = toi_fun,
    vars = [var_toi_v],
)

# Event 3: Propagate to apoapsis and check radius constraint
prop_to_apogee_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))
prop_to_apogee_event = Event(
    name = &quot;Prop to Apoapsis&quot;,
    event = prop_to_apogee_fun,
    funcs = [apogee_radius_con],
)

# Event 4: Propagate to perigee
prop_to_perigee_1_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))
prop_to_perigee_1_event = Event(
    name = &quot;Prop to Perigee 1&quot;,
    event = prop_to_perigee_1_fun,
)

# Event 5: Propagate to Z=0 crossing again
prop_to_z_crossing_2_fun() = propagate(prop, sat, StopAt(sat, PosZ(), 0.0))
prop_to_z_crossing_2_event = Event(
    name = &quot;Prop to Z 2&quot;,
    event = prop_to_z_crossing_2_fun,
)

# Event 6: Apply MCC maneuver
mcc_fun() = maneuver(sat, mcc)
mcc_event = Event(
    name = &quot;MCC&quot;,
    event = mcc_fun,
    vars = [var_mcc_vn],
)

# Event 7: Propagate to perigee and check constraints
prop_to_perigee_2_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))
prop_to_perigee_2_event = Event(
    name = &quot;Prop to Perigee 2&quot;,
    event = prop_to_perigee_2_fun,
    funcs = [inclination_con, perigee_radius_con],
)

# Event 8: Apply MOI maneuver and check final SMA
moi_fun() = maneuver(sat, moi)
moi_event = Event(
    name = &quot;MOI&quot;,
    event = moi_fun,
    vars = [var_moi_v],
    funcs = [final_sma_con],
)

# ========== Build the Sequence and Solve =================================================
seq = Sequence()
add_events!(seq, toi_event, [prop_to_z_crossing_1_event])
add_events!(seq, prop_to_apogee_event, [toi_event])
add_events!(seq, prop_to_perigee_1_event, [prop_to_apogee_event])
add_events!(seq, prop_to_z_crossing_2_event, [prop_to_perigee_1_event])
add_events!(seq, mcc_event, [prop_to_z_crossing_2_event])
add_events!(seq, prop_to_perigee_2_event, [mcc_event])
add_events!(seq, moi_event, [prop_to_perigee_2_event])

# Set up IPOPT options
ipopt_options = Dict(
    &quot;max_iter&quot; =&gt; 1000,
    &quot;tol&quot; =&gt; 1e-6,
    &quot;output_file&quot; =&gt; &quot;ipopt_geo_transfer$(rand(UInt)).out&quot;,
    &quot;file_print_level&quot; =&gt; 5,
    &quot;print_level&quot; =&gt; 5,
)
snow_options = Options(derivatives=ForwardFD(), solver=IPOPT(ipopt_options))

result = trajectory_solve(seq, snow_options)
sequence_report(seq)
solution_report(seq, result)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Friday 14 November 2025 16:18">Friday 14 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
