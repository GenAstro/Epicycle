var documenterSearchIndex = {"docs":
[{"location":"#AstroSolve.jl","page":"AstroSolve.jl","title":"AstroSolve.jl","text":"AstroSolve provides a framework for solving astrodynamics design problems through constrained optimization and event-driven architecture. AstroSolve builds an event sequence as a Directed Acyclic Graph (DAG), which will soon be fully differentiable using AD. The DAG model for optimization is inspired by the architecture used in NASA's Copernicus software.  \n\nReference: Jacob Williams, Robert Falck, and Izaak Beekman. \"Application of Modern Fortran to Spacecraft Trajectory Design and Optimization.\" AIAA/AAS Space Flight Mechanics Meeting, Kissimmee, FL, 2018. Available online\n\nAstroSolve's architecture is based on a few key user-facing components:\n\nComponent Description\nModels Spacecraft, maneuvers, propagators, etc. that model the physics of the system\nSolverVariables Optimization variables that the solver can adjust during trajectory design\nConstraints Equality and inequality constraints that must be satisfied in the solution\nEvents Discrete mission phases that execute actions (propagate, maneuver, etc.) and apply constraints\nSequence DAG structure that defines event dependencies and execution order","category":"section"},{"location":"#Quick-Start","page":"AstroSolve.jl","title":"Quick Start","text":"The example below uses AstroSolve's Event Sequence architecture to solve a simple orbit raising problem using IPOPT.\n\nusing Epicycle\n\n# Create spacecraft with default orbital state\nsat = Spacecraft()\n\n# Create the propagator with point mass gravity model\ngravity = PointMassGravity(earth, (moon, sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Create an impulsive maneuver (only V component will vary)\ntoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.1,\n)\n\n# Define DeltaVVector of toi as a solver variable\n# V component allowed to vary, N and B components constrained to zero\nvar_toi = SolverVariable(\n    calc = ManeuverCalc(toi, sat, DeltaVVector()),\n    name = \"toi\",\n    lower_bound = [-10.0, 0.0, 0.0],\n    upper_bound = [10.0, 0.0, 0.0],\n)\n\n# Define a constraint on position magnitude of spacecraft\n# Target apoapsis altitude of 55000 km\npos_target = 55000.0\npos_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [pos_target],\n    upper_bounds = [pos_target],\n    scale = [1.0],\n)\n\n# Create an event that applies the maneuver with toi as optimization variable\nfun_toi() = maneuver(sat, toi) \ntoi_event = Event(name = \"TOI Maneuver\", \n                  event = fun_toi,\n                  vars = [var_toi],\n                  funcs = [])\n\n# Create propagation event to apoapsis with position constraint\nfun_prop_apo() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))\nprop_event = Event(name = \"Propagate to Apoapsis\", \n                   event = fun_prop_apo,\n                   funcs = [pos_con])\n\n# Build sequence: maneuver first, then propagate to apoapsis\nseq = Sequence()\nadd_events!(seq, prop_event, [toi_event]) \n\n# Solve trajectory optimization using default settings (finite differences, IPOPT)\nresult = trajectory_solve(seq)\n\n# Write a report documenting sequence and solution\nsequence_report(seq)\nsolution_report(seq, result)","category":"section"},{"location":"#Core-Functions","page":"AstroSolve.jl","title":"Core Functions","text":"This section contains reference material for the key user facing elements of AstroSolve. Note: Constraint is currently in the AstroCallbacks module but will be moved to AstroSolve in a future release. ","category":"section"},{"location":"#API-Reference","page":"AstroSolve.jl","title":"API Reference","text":"\n\n","category":"section"},{"location":"#A-More-Complex-Example","page":"AstroSolve.jl","title":"A More Complex Example","text":"\nusing Epicycle\n\n# ========== Create Models =================================================================\n# Create spacecraft\nsat = Spacecraft(\n    state = CartesianState([3737.792, -4607.692, -2845.644, 5.411, 5.367, -1.566]),\n    time = Time(\"2000-01-01T11:59:28.000\", UTC(), ISOT())  # J2000 epoch from GMAT\n)\n\n# Create simple Earth point mass dynamics (no third bodies for now)\ngravity = PointMassGravity(earth, ())  # Only Earth gravity\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(DP8(); abstol=1e-12, reltol=1e-12, dt=60.0)\nprop    = OrbitPropagator(forces, integ)\n\n# Define maneuver models\ntoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 1.518,\n    element2 = 0.0,\n    element3 = 0.0,\n)\n\nmcc = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = 0.559,\n    element2 = 0.588,\n    element3 = 0.0,\n)\n\nmoi = ImpulsiveManeuver(\n    axes = VNB(),\n    element1 = -0.282,\n    element2 = 0.0,\n    element3 = 0.0,\n)\n\n# ========== Define Solver Variables ======================================================\n# TOI: Only vary V component (Element1)\nvar_toi_v = SolverVariable(\n    calc = ManeuverCalc(toi, sat, DeltaVVector()),\n    name = \"toi_v\",\n    lower_bound = [-5.0, 0.0, 0.0],  # Only V component varies significantly\n    upper_bound = [5.0, 0.0, 0.0],\n)\n\n# MCC: Vary V and N components (Element1 and Element2)\nvar_mcc_vn = SolverVariable(\n    calc = ManeuverCalc(mcc, sat, DeltaVVector()),\n    name = \"mcc_vn\",\n    lower_bound = [-2.0, -2.0, -0.001],   # V and N components vary\n    upper_bound = [2.0, 2.0, 0.001],\n)\n\n# MOI: Only vary V component (Element1)\nvar_moi_v = SolverVariable(\n    calc = ManeuverCalc(moi, sat, DeltaVVector()),\n    name = \"moi_v\",\n    lower_bound = [-2.0, -0.001, -0.001],  # Only V component varies significantly\n    upper_bound = [2.0, 0.001, 0.001],\n)\n\n# ========== Define Constraints ===========================================================\n# Constraint: Apoapsis radius = 85,000 km after TOI\napogee_radius_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [85000.0],\n    upper_bounds = [85000.0],\n    scale = [1.0],\n)\n\n# Constraint: Inclination = 2Â° after MCC\ninclination_con = Constraint(\n    calc = OrbitCalc(sat, Inc()),\n    lower_bounds = [deg2rad(2.0)],\n    upper_bounds = [deg2rad(2.0)],\n    scale = [1.0],\n)\n\n# Constraint: Perigee radius = 42,195 km after MCC\nperigee_radius_con = Constraint(\n    calc = OrbitCalc(sat, PosMag()),\n    lower_bounds = [42195.0],\n    upper_bounds = [42195.0],\n    scale = [1.0],\n)\n\n# Constraint: Final SMA = 42,166.90 km (GEO) after MOI\nfinal_sma_con = Constraint(\n    calc = OrbitCalc(sat, SMA()),\n    lower_bounds = [42166.90],\n    upper_bounds = [42166.90],\n    scale = [1.0],\n)\n\n# ========== Define events (variables, constraints, actions) ==============================\n# Event 1: Propagate to Z=0 crossing (equatorial plane)\nprop_to_z_crossing_1_fun() = propagate(prop, sat, StopAt(sat, PosZ(), 0.0))\nprop_to_z_crossing_1_event = Event(\n    name = \"Prop to Z 1\",\n    event = prop_to_z_crossing_1_fun,\n)\n\n# Event 2: Apply TOI maneuver\ntoi_fun() = maneuver(sat, toi)\ntoi_event = Event(\n    name = \"TOI\",\n    event = toi_fun,\n    vars = [var_toi_v],\n)\n\n# Event 3: Propagate to apoapsis and check radius constraint\nprop_to_apogee_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=-1))\nprop_to_apogee_event = Event(\n    name = \"Prop to Apoapsis\",\n    event = prop_to_apogee_fun,\n    funcs = [apogee_radius_con],\n)\n\n# Event 4: Propagate to perigee\nprop_to_perigee_1_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))\nprop_to_perigee_1_event = Event(\n    name = \"Prop to Perigee 1\",\n    event = prop_to_perigee_1_fun,\n)\n\n# Event 5: Propagate to Z=0 crossing again\nprop_to_z_crossing_2_fun() = propagate(prop, sat, StopAt(sat, PosZ(), 0.0))\nprop_to_z_crossing_2_event = Event(\n    name = \"Prop to Z 2\",\n    event = prop_to_z_crossing_2_fun,\n)\n\n# Event 6: Apply MCC maneuver\nmcc_fun() = maneuver(sat, mcc)\nmcc_event = Event(\n    name = \"MCC\",\n    event = mcc_fun,\n    vars = [var_mcc_vn],\n)\n\n# Event 7: Propagate to perigee and check constraints\nprop_to_perigee_2_fun() = propagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=1))\nprop_to_perigee_2_event = Event(\n    name = \"Prop to Perigee 2\",\n    event = prop_to_perigee_2_fun,\n    funcs = [inclination_con, perigee_radius_con],\n)\n\n# Event 8: Apply MOI maneuver and check final SMA\nmoi_fun() = maneuver(sat, moi)\nmoi_event = Event(\n    name = \"MOI\",\n    event = moi_fun,\n    vars = [var_moi_v],\n    funcs = [final_sma_con],\n)\n\n# ========== Build the Sequence and Solve =================================================\nseq = Sequence()\nadd_events!(seq, toi_event, [prop_to_z_crossing_1_event])\nadd_events!(seq, prop_to_apogee_event, [toi_event])\nadd_events!(seq, prop_to_perigee_1_event, [prop_to_apogee_event])\nadd_events!(seq, prop_to_z_crossing_2_event, [prop_to_perigee_1_event])\nadd_events!(seq, mcc_event, [prop_to_z_crossing_2_event])\nadd_events!(seq, prop_to_perigee_2_event, [mcc_event])\nadd_events!(seq, moi_event, [prop_to_perigee_2_event])\n\n# Set up IPOPT options\nipopt_options = Dict(\n    \"max_iter\" => 1000,\n    \"tol\" => 1e-6,\n    \"output_file\" => \"ipopt_geo_transfer$(rand(UInt)).out\",\n    \"file_print_level\" => 5,\n    \"print_level\" => 5,\n)\nsnow_options = Options(derivatives=ForwardFD(), solver=IPOPT(ipopt_options))\n\nresult = trajectory_solve(seq, snow_options)\nsequence_report(seq)\nsolution_report(seq, result)","category":"section"},{"location":"#AstroSolve.SolverVariable","page":"AstroSolve.jl","title":"AstroSolve.SolverVariable","text":"SolverVariable{C<:AbstractCalc}\n\nRepresents a solver-controlled variable defined by a calculation container for  trajectory optimization.\n\nFields\n\ncalc::C: Calculation container (e.g., OrbitCalc, ManeuverCalc, BodyCalc)\nnumvars::Int: Number of scalar variables for this calculation\nlower_bound::Vector{Float64}: Lower bounds for optimization (length numvars,  defaults to -Inf)\nupper_bound::Vector{Float64}: Upper bounds for optimization (length numvars,  defaults to +Inf)\nshift::Vector{Float64}: Variable shifting for numerical conditioning  (length numvars, defaults to 0.0)\nscale::Vector{Float64}: Variable scaling for numerical conditioning  (length numvars, defaults to 1.0)\nname::String: Optional human-readable identifier\n\nConstructor\n\nSolverVariable(; calc, lower_bound=nothing, upper_bound=nothing, shift=nothing,\nscale=nothing, name=\"\")\n\nArguments\n\ncalc: Calculation container implementing AbstractCalc interface\nlower_bound: Scalar or vector of lower bounds (broadcast to numvars if scalar)\nupper_bound: Scalar or vector of upper bounds (broadcast to numvars if scalar)  \nshift: Scalar or vector of shift values for numerical conditioning\nscale: Scalar or vector of scale factors for numerical conditioning\nname: Optional descriptive name for the variable\n\nNotes\n\nSee AbstractCalc for supported calculation types\nnumvars is automatically determined from the calculation variable type\nBounds, shift, and scale vectors are stored as Float64 for optimizer compatibility\nThe calculation must support setting values (calc_is_settable(calc.var) == true) \n\nExamples\n\nusing Epicycle\n\n# Spacecraft and maneuver objects\nsc = Spacecraft(); toi = ImpulsiveManeuver()\n\n# 3D delta-V vector variable with individual component bounds\nvar_toi = SolverVariable(\n    calc = ManeuverCalc(toi, sc, DeltaVVector()),\n    lower_bound = [-2.0, -2.0, -2.0],\n    upper_bound = [2.0, 2.0, 2.0],\n    scale = [1.0, 1.0, 1.0],  \n    name = \"Departure DV Vector\"\n)\n\n# Orbital element variable\nvar_sma = SolverVariable(\n    calc = OrbitCalc(sc, SMA()),\n    lower_bound = 6700.0,   \n    upper_bound = 42000.0,  \n    name = \"Target Semi-Major Axis\"\n)\n\n\n\n\n\n","category":"type"},{"location":"#AstroSolve.Event","page":"AstroSolve.jl","title":"AstroSolve.Event","text":"Event\n\nDefines an event node for trajectory sequence execution in mission design workflows.\n\nFields\n\nname::String: Human-readable identifier for the event\nevent::Function: Function closure to execute when this node runs\nvars::Vector{Any}: Vector of solver variables (SolverVariable) associated with this event\nfuncs::Vector{Any}: Vector of constraint/objective functions for this event\n\nNotes\n\nEvents are the fundamental building blocks of trajectory sequences, encapsulating both the action to be performed and the optimization variables/constraints associated with that action.\n\nExamples\n\n# Simple propagation event\nprop_event = Event(\n    name = \"Propagate to Apoapsis\",\n    event = () -> propagate(dynsys, integ, StopAtApoapsis(sat)),\n)\n\n# Event with solver variables and constraints\nsc = Spacecraft(); toi = ImpulsiveManeuver();\nvar_dv = SolverVariable(\n    calc = ManeuverCalc(toi, sc, DeltaVVector()),\n)\nfun_dv = Constraint(\n    calc = ManeuverCalc(toi, sc, DeltaVMag()),\n    lower_bounds = [0.1],\n    upper_bounds = [0.1],\n    scale = [1.0],\n)\nmaneuver_event = Event(\n    event = () -> maneuver!(sc, toi),\n    vars = [var_dv],\n    funcs = [fun_dv],\n    name = \"Departure Maneuver\",\n)\n\n\n\n\n\n","category":"type"},{"location":"#AstroSolve.Sequence","page":"AstroSolve.jl","title":"AstroSolve.Sequence","text":"Sequence\n\nA directed acyclic graph (DAG) representation of trajectory events for optimization.\n\nIn Epicycle, trajectories are modeled as sequences of events (maneuvers, propagations, etc.)  that must occur in a specific order. The Sequence struct represents this as a DAG where events are nodes and dependencies are edges.\n\nFields\n\nevents::Vector{Event}: Collection of all events in the sequence\nadj_map::Dict{Event, Vector{Event}}: Adjacency map defining event dependencies\n\nExamples\n\nseq = Sequence()\nadd_events!(seq, event1, Event[])          # Add root event\nadd_events!(seq, event2, [event1])         # event2 depends on event1\nadd_events!(seq, event3, [event1, event2]) # event3 depends on both\n\n\n\n\n\n","category":"type"},{"location":"#AstroSolve.add_events!","page":"AstroSolve.jl","title":"AstroSolve.add_events!","text":"add_events!(seq::Sequence, event::Event, dependencies::Vector{Event})\n\nAdd an event to the sequence with specified dependencies.\n\nThis function adds event to the sequence DAG, ensuring that all events in  dependencies must occur before event during execution. The internal adjacency  map is updated to reflect these dependencies.\n\nArguments\n\nseq::Sequence: Sequence to modify\nevent::Event: Event to add to the sequence\ndependencies::Vector{Event}: Events directly linked to and preceding event.\n\nExamples\n\nseq = Sequence()\nadd_events!(seq, maneuver_event, [prop_event])  # maneuver after propagation\nadd_events!(seq, final_event, [maneuver_event, other_event])  # final after both\n\nSee also: Sequence, topo_sort\n\n\n\n\n\n","category":"function"},{"location":"#AstroSolve.trajectory_solve","page":"AstroSolve.jl","title":"AstroSolve.trajectory_solve","text":"trajectory_solve(seq::Sequence)\n\nSolve trajectory sequence using default SNOW/IPOPT configuration.\n\n\n\n\n\ntrajectory_solve(seq::Sequence, options::SNOW.Options)\n\nSolve trajectory sequence using specified SNOW optimization options.\n\n\n\n\n\n","category":"function"},{"location":"#AstroSolve.sequence_report","page":"AstroSolve.jl","title":"AstroSolve.sequence_report","text":"sequence_report(seq::Sequence)\n\nGenerate a comprehensive report summarizing the trajectory sequence configuration.\n\nThis function creates a human-readable summary of the sequence structure showing:\n\nSequence overview (total events, variables, constraints)\nEvent details with dependencies and execution order\nVariable information (names, sizes, bounds)\nConstraint summary (types, sizes, bounds)\n\nArguments\n\nseq::Sequence: Trajectory sequence to analyze\n\nReturns\n\nNothing (prints directly to stdout for better formatting)\n\n\n\n\n\n","category":"function"},{"location":"#AstroSolve.solution_report","page":"AstroSolve.jl","title":"AstroSolve.solution_report","text":"solution_report(seq::Sequence, result)\n\nGenerate a comprehensive report showing the optimized trajectory solution.\n\nThis function displays the optimization results including variable values, constraint satisfaction, and solution summary. It works with the result from trajectory_solve().\n\nArguments\n\nseq::Sequence: Original trajectory sequence\nresult: Result tuple from trajectory_solve with (variables, objective, info)\n\nReturns\n\nNothing (prints directly to stdout for better formatting)\n\n\n\n\n\n","category":"function"},{"location":"#AstroSolve.Event-Tuple{}","page":"AstroSolve.jl","title":"AstroSolve.Event","text":"Event(; name::String = \"\", event::Function = () -> nothing, vars = [], funcs = [])\n\nOuter constructor for Event with kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.Sequence-Tuple{}","page":"AstroSolve.jl","title":"AstroSolve.Sequence","text":"Sequence()\n\nCreate an empty trajectory sequence with no events or dependencies.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.SequenceManager","page":"AstroSolve.jl","title":"AstroSolve.SequenceManager","text":"SequenceManager\n\nOrchestrator for trajectory sequence execution and optimization.\n\nThe SequenceManager prepares and manages a Sequence for iterative optimization. It topologically sorts events, orders variables and constraints, extracts bounds and scaling parameters, and manages stateful object restoration.\n\nFields\n\nsequence::Sequence: Original sequence definition\nsorted_events::Vector{Event}: Topologically sorted events for execution\nordered_vars::Vector{SolverVariable}: Unique variables in dependency order\nordered_funcs::Vector{Constraint}: All constraints in execution order\nfun_sizes::Vector{Int}: Number of scalar constraints per constraint function\nvar_shift::Vector: Concatenated variable shift parameters for scaling\nvar_scale::Vector: Concatenated variable scale parameters for scaling  \nvar_lower_bounds::Vector: Concatenated lower bounds for all variables\nvar_upper_bounds::Vector: Concatenated upper bounds for all variables\nstateful_structs::Vector{Any}: All stateful objects referenced in sequence\ninitial_stateful_structs::Vector{Any}: Deep copies for state restoration\n\nExamples\n\nseq = Sequence()\nadd_events!(seq, event1, Event[])\nadd_events!(seq, event2, [event1])\nsm = SequenceManager(seq)\n\n\n\n\n\n","category":"type"},{"location":"#AstroSolve.SequenceManager-Tuple{Sequence}","page":"AstroSolve.jl","title":"AstroSolve.SequenceManager","text":"SequenceManager(seq::Sequence)\n\nConstruct a sequence manager from a trajectory sequence.\n\nThis constructor performs several optimization steps:\n\nTopologically sorts events to ensure dependency ordering\nExtracts unique variables while preserving dependency order\nCollects all constraints with their sizes\nIdentifies and snapshots all stateful objects for reset capability\nPre-computes variable bounds and scaling parameters\n\nNotes\n\nErrorException: If sequence contains cycles (not a valid DAG)\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.SolverVariable-Union{Tuple{}, Tuple{C}} where C<:AbstractCalc","page":"AstroSolve.jl","title":"AstroSolve.SolverVariable","text":"SolverVariable(; calc, lower_bound=nothing, upper_bound=nothing, shift=nothing, scale=nothing, name=\"\")\n\nConvenience constructor that automatically infers the calculation type parameter C from the calc argument.\n\nThis eliminates the need to explicitly specify the type parameter when creating SolverVariable instances.\n\nUsage Comparison\n\n# Without convenience constructor (explicit type parameter):\nvar1 = SolverVariable{OrbitCalc}(calc=OrbitCalc(sat, SemiMajorAxis()))\n\n# With convenience constructor (type inferred):\nvar2 = SolverVariable(calc=OrbitCalc(sat, SemiMajorAxis()))  # Preferred\n\nThis constructor delegates to SolverVariable{C}(...) with the inferred type.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve._push_stateful!-Tuple{Vector{Any}, Set{UInt64}, Any}","page":"AstroSolve.jl","title":"AstroSolve._push_stateful!","text":"_push_stateful!(out::Vector{Any}, seen::Set{UInt}, objs)\n\nPush unique stateful objects to output vector, preserving discovery order.\n\nOnly objects that are marked as stateful (via is_astrosolve_stateful) and not already seen are added to the output collection.\n\nArguments\n\nout::Vector{Any}: Output collection to append to\nseen::Set{UInt}: Set tracking object IDs of already discovered objects\nobjs: Collection of objects to check and potentially add\n\nReturns\n\nVector{Any}: The modified output vector (for chaining)\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.add_events!-Tuple{Sequence, Event, Vector{Event}}","page":"AstroSolve.jl","title":"AstroSolve.add_events!","text":"add_events!(seq::Sequence, event::Event, dependencies::Vector{Event})\n\nAdd an event to the sequence with specified dependencies.\n\nThis function adds event to the sequence DAG, ensuring that all events in  dependencies must occur before event during execution. The internal adjacency  map is updated to reflect these dependencies.\n\nArguments\n\nseq::Sequence: Sequence to modify\nevent::Event: Event to add to the sequence\ndependencies::Vector{Event}: Events directly linked to and preceding event.\n\nExamples\n\nseq = Sequence()\nadd_events!(seq, maneuver_event, [prop_event])  # maneuver after propagation\nadd_events!(seq, final_event, [maneuver_event, other_event])  # final after both\n\nSee also: Sequence, topo_sort\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.apply_event-Tuple{Event}","page":"AstroSolve.jl","title":"AstroSolve.apply_event","text":"apply_event(event::Event)\n\nExecute the event's function closure.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.copy_struct_fields!-Tuple{Any, Any}","page":"AstroSolve.jl","title":"AstroSolve.copy_struct_fields!","text":"copy_struct_fields!(dest, src)\n\nRecursively copy all fields from src to dest struct, preserving mutable references.\n\nThis function performs deep copying for stateful struct restoration. For arrays, it overwrites contents rather than replacing references. For nested mutable structs, it recursively copies fields.\n\nArguments\n\ndest: Destination struct to copy into\nsrc: Source struct to copy from\n\nReturns\n\nModified dest struct\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.default_snow_options-Tuple{}","page":"AstroSolve.jl","title":"AstroSolve.default_snow_options","text":"default_snow_options()\n\nCreate default SNOW optimization options.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.find_all_stateful_structs-Tuple{Any, Any}","page":"AstroSolve.jl","title":"AstroSolve.find_all_stateful_structs","text":"find_all_stateful_structs(ordered_vars, sorted_events)\n\nFind all unique stateful structs referenced by SolverVariables and events.\n\nStateful structs are objects that maintain state during trajectory propagation and need to be reset between optimization iterations. This function discovers all such objects referenced throughout the sequence.\n\nArguments\n\nordered_vars::Vector{SolverVariable}: Ordered optimization variables\nsorted_events::Vector{Event}: Topologically sorted events\n\nReturns\n\nVector{Any}: Collection of unique stateful objects in discovery order\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.format_bounds","page":"AstroSolve.jl","title":"AstroSolve.format_bounds","text":"format_bounds(lower, upper, size=1)\n\nFormat numeric bounds for display with consistent precision.\n\n\n\n\n\n","category":"function"},{"location":"#AstroSolve.get_bounds_description-Tuple{Any, Any}","page":"AstroSolve.jl","title":"AstroSolve.get_bounds_description","text":"get_bounds_description(lower, upper)\n\nDescribe bounds as equality, inequality, or range constraints.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_calc_description-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_calc_description","text":"get_calc_description(calc)\n\nExtract calculation description from calc objects.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_enhanced_constraint_description-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_enhanced_constraint_description","text":"get_enhanced_constraint_description(func)\n\nGet enhanced constraint description with calc info for display.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_enhanced_variable_description-Tuple{SolverVariable}","page":"AstroSolve.jl","title":"AstroSolve.get_enhanced_variable_description","text":"get_enhanced_variable_description(var::SolverVariable)\n\nGet enhanced variable description with calc info for display.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_event_constraint_mapping-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.get_event_constraint_mapping","text":"get_event_constraint_mapping(sm::SequenceManager)\n\nCreate mapping from events to their constraints for reporting.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_fun_lower_bounds-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.get_fun_lower_bounds","text":"get_fun_lower_bounds(sm::SequenceManager)\n\nExtract lower bounds from all constraint functions in the sequence manager.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing constraint functions\n\nReturns\n\nVector: Concatenated lower bounds for all constraints\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_fun_upper_bounds-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.get_fun_upper_bounds","text":"get_fun_upper_bounds(sm::SequenceManager)\n\nExtract upper bounds from all constraint functions in the sequence manager.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing constraint functions\n\nReturns\n\nVector: Concatenated upper bounds for all constraints\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_fun_values-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.get_fun_values","text":"get_fun_values(sm::SequenceManager)\n\nEvaluate all constraint functions in the sequence manager and return  concatenated function values.\n\nThis function evaluates all constraints in the current state and returns their values as a flat vector. The ordering matches the constraint order established during SequenceManager construction.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing constraints to evaluate\n\nReturns\n\nVector{Float64}: Concatenated constraint function values\n\nNotes\n\nThis function assumes all stateful objects are in the correct state for constraint evaluation (typically after event sequence execution).\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_simplified_type_name-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_simplified_type_name","text":"get_simplified_type_name(obj)\n\nSimplify type names by removing module prefixes and parameters.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_sol_var-Tuple{SolverVariable}","page":"AstroSolve.jl","title":"AstroSolve.get_sol_var","text":"get_sol_var(var::SolverVariable)\n\nGet the solver variable values from the struct.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_subject_description-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_subject_description","text":"get_subject_description(subject)\n\nGet subject description with type and name information.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_lower_bounds-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_var_lower_bounds","text":"get_var_lower_bounds(ordered_vars)\n\nExtract lower bounds from all solver variables into a flat vector.\n\nArguments\n\nordered_vars::Vector{SolverVariable}: Variables to extract bounds from\n\nReturns\n\nVector: Concatenated lower bounds for optimization constraints\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_lower_bounds-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.get_var_lower_bounds","text":"get_var_lower_bounds(sm::SequenceManager)\n\nExtract lower bounds from all variables in the sequence manager.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing variables\n\nReturns\n\nVector: Concatenated lower bounds for optimization constraints\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_scales-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_var_scales","text":"get_var_scales(ordered_vars)\n\nExtract scale parameters from all solver variables into a flat vector.\n\nArguments\n\nordered_vars::Vector{SolverVariable}: Variables to extract scales from\n\nReturns\n\nVector: Concatenated scale values for optimization scaling\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_shifts-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_var_shifts","text":"get_var_shifts(ordered_vars)\n\nExtract shift parameters from all solver variables into a flat vector.\n\nArguments\n\nordered_vars::Vector{SolverVariable}: Variables to extract shifts from\n\nReturns\n\nVector: Concatenated shift values for optimization scaling\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_upper_bounds-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_var_upper_bounds","text":"get_var_upper_bounds(ordered_vars)\n\nExtract upper bounds from all solver variables into a flat vector.\n\nArguments\n\nordered_vars::Vector{SolverVariable}: Variables to extract bounds from\n\nReturns\n\nVector: Concatenated upper bounds for optimization constraints\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_upper_bounds-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.get_var_upper_bounds","text":"get_var_upper_bounds(sm::SequenceManager)\n\nExtract upper bounds from all variables in the sequence manager.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing variables\n\nReturns\n\nVector: Concatenated upper bounds for optimization constraints\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_values-Tuple{Any}","page":"AstroSolve.jl","title":"AstroSolve.get_var_values","text":"get_var_values(ordered_vars)\n\nExtract current values from all SolverVariables into a flat vector.\n\nArguments\n\nordered_vars::Vector{SolverVariable}: Variables to extract values from\n\nReturns\n\nVector: Concatenated values from all variables\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.get_var_values-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.get_var_values","text":"get_var_values(sm::SequenceManager)\n\nExtract current values from all variables in the sequence manager.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing variables\n\nReturns\n\nVector: Concatenated values from all variables\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.order_unique_vars-Tuple{Vector{Event}}","page":"AstroSolve.jl","title":"AstroSolve.order_unique_vars","text":"order_unique_vars(sorted_events::Vector{Event})\n\nExtract unique solver variables from events in dependency order.\n\nThis function processes topologically sorted events and extracts all unique SolverVariables while preserving the order of first appearance. This ensures variables are ordered according to their dependency relationships.\n\nArguments\n\nsorted_events::Vector{Event}: Events in topological order\n\nReturns\n\nVector{SolverVariable}: Unique variables in dependency order\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.reset_stateful_structs!-Tuple{SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.reset_stateful_structs!","text":"reset_stateful_structs!(sm::SequenceManager)\n\nReset all stateful structs in the sequence manager to their initial state.\n\nThis function is called before each optimization iteration to ensure a clean starting state for trajectory propagation. It restores all spacecraft, maneuvers, and other stateful objects to their initial conditions.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing stateful objects to reset\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.sequence_report-Tuple{Sequence}","page":"AstroSolve.jl","title":"AstroSolve.sequence_report","text":"sequence_report(seq::Sequence)\n\nGenerate a comprehensive report summarizing the trajectory sequence configuration.\n\nThis function creates a human-readable summary of the sequence structure showing:\n\nSequence overview (total events, variables, constraints)\nEvent details with dependencies and execution order\nVariable information (names, sizes, bounds)\nConstraint summary (types, sizes, bounds)\n\nArguments\n\nseq::Sequence: Trajectory sequence to analyze\n\nReturns\n\nNothing (prints directly to stdout for better formatting)\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.set_sol_var-Tuple{SolverVariable, Vector}","page":"AstroSolve.jl","title":"AstroSolve.set_sol_var","text":"set_sol_var(var::SolverVariable, val::Vector)\n\nSet the value(s) of the solver variable struct\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.set_var_values-Tuple{SequenceManager, AbstractVector}","page":"AstroSolve.jl","title":"AstroSolve.set_var_values","text":"set_var_values(sm::SequenceManager, x::AbstractVector)\n\nSet all solver variables in the sequence manager to values from vector x.\n\nArguments\n\nsm::SequenceManager: Sequence manager containing ordered variables\nx::AbstractVector: Flat vector of variable values\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.set_var_values-Tuple{Vector, Vector{SolverVariable}}","page":"AstroSolve.jl","title":"AstroSolve.set_var_values","text":"set_var_values(vec::Vector, ordered_vars::Vector{SolverVariable})\n\nSet values for an ordered collection of solver variables from a flat vector.\n\nThis function distributes values from a flat optimization vector to the appropriate SolverVariables, handling the different sizes of vector vs scalar variables correctly.\n\nArguments\n\nvec::Vector: Flat vector of values to distribute\nordered_vars::Vector{SolverVariable}: Variables to set in order\n\nExamples\n\n# Set 3 variables: 2 scalars + 1 3-vector\nx = [1.0, 2.0, 0.1, 0.2, 0.3]  # 5 total values\nset_var_values(x, [scalar1, scalar2, vector3])\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.show_constraint_components-Tuple{Any, Bool}","page":"AstroSolve.jl","title":"AstroSolve.show_constraint_components","text":"show_constraint_components(func, is_last_constraint::Bool)\n\nShow constraint component breakdown with proper indentation.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.show_variable_components-Tuple{SolverVariable, Bool}","page":"AstroSolve.jl","title":"AstroSolve.show_variable_components","text":"show_variable_components(var::SolverVariable, is_last_var::Bool)\n\nShow variable component breakdown with proper indentation.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.solution_report-Tuple{Sequence, Any}","page":"AstroSolve.jl","title":"AstroSolve.solution_report","text":"solution_report(seq::Sequence, result)\n\nGenerate a comprehensive report showing the optimized trajectory solution.\n\nThis function displays the optimization results including variable values, constraint satisfaction, and solution summary. It works with the result from trajectory_solve().\n\nArguments\n\nseq::Sequence: Original trajectory sequence\nresult: Result tuple from trajectory_solve with (variables, objective, info)\n\nReturns\n\nNothing (prints directly to stdout for better formatting)\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.solver_fun!-Tuple{AbstractVector, AbstractVector, SequenceManager}","page":"AstroSolve.jl","title":"AstroSolve.solver_fun!","text":"solver_fun!(F::AbstractVector, x::AbstractVector, sm::SequenceManager)\n\nCore optimization function: set variables, execute sequence, and evaluate constraints.\n\nThis is the primary interface between optimization solvers and Epicycle trajectory sequences. It performs a complete trajectory execution cycle:\n\nReset: Restore all stateful objects to initial conditions\nSet Variables: Apply optimization variables to events \nExecute: Run events in topological order, applying maneuvers and propagations, etc.\nEvaluate: Collect function values at appropriate times during execution\n\nArguments\n\nF::AbstractVector: Output vector to fill with constraint values\nx::AbstractVector: Input optimization variables (flat vector)\nsm::SequenceManager: Configured sequence manager\n\nReturns\n\nInt: Status code (0 for success)\n\nNotes\n\nFunction values are evaluated immediately after their associated events to capture the correct spacecraft state at that point in the trajectory\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.topo_sort-Tuple{Sequence}","page":"AstroSolve.jl","title":"AstroSolve.topo_sort","text":"topo_sort(seq::Sequence)\n\nPerform topological sorting of events using Kahn's algorithm.\n\nThis function sorts the events in the sequence. If event A depends on event B,  then B will appear before A in the sorted output. \n\nArguments\n\nseq::Sequence: Sequence containing events and their dependencies\n\nReturns\n\nVector{Event}: Events sorted in dependency order (dependencies first)\n\nThrows\n\nErrorException: If the sequence contains cycles (not a valid DAG)\n\nAlgorithm\n\nUses Kahn's algorithm:\n\nCalculate in-degree for all events\nStart with events having no dependencies (in-degree 0)  \nRemove events and update in-degrees until all processed\nDetect cycles if any events remain unprocessed\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.trajectory_solve-Tuple{Sequence, Options}","page":"AstroSolve.jl","title":"AstroSolve.trajectory_solve","text":"trajectory_solve(seq::Sequence, options::SNOW.Options)\n\nSolve trajectory sequence using specified SNOW optimization options.\n\n\n\n\n\n","category":"method"},{"location":"#AstroSolve.trajectory_solve-Tuple{Sequence}","page":"AstroSolve.jl","title":"AstroSolve.trajectory_solve","text":"trajectory_solve(seq::Sequence)\n\nSolve trajectory sequence using default SNOW/IPOPT configuration.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, Event}","page":"AstroSolve.jl","title":"Base.show","text":"Base.show(io::IO, event::Event)\n\nDisplay method for Event showing name, actual variable count, and function count.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, SolverVariable}","page":"AstroSolve.jl","title":"Base.show","text":"Base.show(io::IO, sv::SolverVariable)\n\nShow method for SolverVariable that displays key information about the variable.\n\n\n\n\n\n","category":"method"}]
}
