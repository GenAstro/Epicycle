var documenterSearchIndex = {"docs":
[{"location":"dev/astrocallbacks_spec/#AstroCallbacks-–-Spec-(v0.1)","page":"AstroCallbacks – Spec (v0.1)","title":"AstroCallbacks – Spec (v0.1)","text":"","category":"section"},{"location":"dev/astrocallbacks_spec/#1.-Overview-and-Scope-(What-are-we-building?)","page":"AstroCallbacks – Spec (v0.1)","title":"1. Overview and Scope (What are we building?)","text":"Purpose:\n\nAstroCallbacks provides a unified interface for defining and evaluating quantities of interest from astrodynamics domain objects (spacecraft, maneuvers, celestial bodies). Calcs enable reuse - define a quantity once, use it everywhere (optimization, plotting, propagation, reporting, event detection, estimation).\n\nIn-scope:\n\nStandard calc definition that is expressive and applies across ecosystem and to custom calcs\nStandardized access patterns: get_calc() and set_calc!()\nType-safe variable definitions using Julia's type hierarchy\nSpacecraft state quantities (position, velocity, orbital elements)\nTime-based quantities (epochs, durations, in various scales/formats)\nControl quantities (maneuver parameters)\nCelestial body properties\nUser-defined custom quantities\nComposable calculations (derive new quantities from existing ones)\nCalc attribute system (settability, continuity, differentiability, etc.)\n\nOut-of-scope:\n\nHow optimizers use calcs (that's AstroSolve)\nHow plotting tools use calcs (external plotting packages)\nReport formatting and generation (reporting packages)\nEvent sequencing logic (AstroSolve)\nNumerical optimization algorithms","category":"section"},{"location":"dev/astrocallbacks_spec/#2.-Requirements-(What-we-are-building.)","page":"AstroCallbacks – Spec (v0.1)","title":"2. Requirements (What we are building.)","text":"","category":"section"},{"location":"dev/astrocallbacks_spec/#Functional-Requirements-Calc-Types","page":"AstroCallbacks – Spec (v0.1)","title":"Functional Requirements - Calc Types","text":"AstroCallbacks shall support calcs for:\n\nAstroState state elements (AstroStates.jl)\nAstroTime time elements (AstroEpochs.jl)\nManeuver elements (AstroManeuvers.jl)\nCelestialBody properties (AstroUniverse.jl)\nSpacecraft properties (AstroModels.jl)\nForceModel properties (AstroProp.jl)\nUser-defined custom calcs\n\nNote, this list is based on current functionality.  The design needs to be extendible as the system grows. ","category":"section"},{"location":"dev/astrocallbacks_spec/#Functional-Requirements-Calc-Interface","page":"AstroCallbacks – Spec (v0.1)","title":"Functional Requirements - Calc Interface","text":"AstroCallbacks shall provide interfaces for:\n\nReading current values from domain objects (e.g., via a get method)\nWriting new values to mutable domain objects (e.g., via a set method, when calc is settable)\n\nAstroCallbacks shall expose calc attributes to support integration:\n\nIs the calc numeric (returns numeric type vs non-numeric like String)\nCalc dimensionality (scalar or vector, with size)\nIs the calc settable (supports modification)\nIs the calc continuous (suitable for gradient-based optimization)\nDoes the calc support automatic differentiation","category":"section"},{"location":"dev/astrocallbacks_spec/#Integration-Requirements","page":"AstroCallbacks – Spec (v0.1)","title":"Integration Requirements","text":"AstroCallbacks calcs shall support integration into:\n\nPropagation stopping conditions (e.g., StopAt using time calc)\nOptimization/estimation variables (solve-fors via SolverVariable)\nOptimization/estimation constraints (via Constraint)\nPlotting (time series evaluation)\nReporting (formatted output, including non-numeric calcs)\n\nAstroCallbacks shall ensure:\n\nAutomatic differentiation (AD) compatibility for numeric mutable calcs\nChanges to calc values are visible to external code (e.g., event function closures)","category":"section"},{"location":"dev/astrocallbacks_spec/#Extensibility-Requirements","page":"AstroCallbacks – Spec (v0.1)","title":"Extensibility Requirements","text":"AstroCallbacks shall enable:\n\nUsers to define custom variable types\nUsers to define custom calc implementations (extend get and optionally set methods)\nPackage developers to add new subject-variable combinations","category":"section"},{"location":"dev/astrocallbacks_spec/#Design-Requirements","page":"AstroCallbacks – Spec (v0.1)","title":"Design Requirements","text":"AstroCallbacks shall ensure:\n\nCalcs can reference multiple domain objects (composite calculations)\nCalcs can derive new quantities from existing calcs\nType-stable operations for compiler optimization\nClear error messages for invalid operations (type mismatches, setting read-only calcs, out-of-range values)","category":"section"},{"location":"dev/astrocallbacks_spec/#3.-Design-(How-we-are-building-it.)","page":"AstroCallbacks – Spec (v0.1)","title":"3. Design (How we are building it.)","text":"","category":"section"},{"location":"dev/astrocallbacks_spec/#Design-Overview","page":"AstroCallbacks – Spec (v0.1)","title":"Design Overview","text":"The AstroCallbacks design centers on calc objects - lightweight wrappers that bind one or more domain objects (the \"subject(s)\") to a specific quantity of interest (the \"variable\"). This subject-variable binding pattern enables type-safe, extensible quantity access across the Epicycle ecosystem.\n\nCore Architecture:\n\nCalc Types (OrbitCalc, ManeuverCalc, BodyCalc, TimeCalc) - categorized by subject type\nVariable Types (SMA, Cartesian, DeltaVMag, etc.) - define which quantity to access\nAccess Interface (get_calc(), set_calc!()) - retrieve and modify values via multiple dispatch\nAttribute System - calcs self-describe capabilities (settability, continuity, dimensionality, AD compatibility)\n\nKey Design Principles:\n\nSeparation of concerns: Calcs define what quantities are; external modules determine how to use them\nType safety: Compiler catches invalid subject-variable combinations at compile time\nExtensibility: Users and packages add new calcs via Julia's multiple dispatch\nComposability: Calcs can reference multiple objects and aggregate values from other calcs\nMutable references: Calcs hold references to mutable domain objects, enabling in-place updates during propagation and optimization\nEncapsulation: Calcs interact with domain objects through public get/set methods, not direct field access\n\nInformation Flow:\n\nDomain Object (Spacecraft, Maneuver, Time)\n    ↓ wrapped by\nCalc (OrbitCalc, ManeuverCalc, TimeCalc) + Variable Type (SMA, Cartesian, JD)\n    ↓ accessed via\nget_calc() / set_calc!()\n    ↓ returns/accepts\nNumeric or Non-numeric Value\n    ↓ consumed by\nExternal Modules (AstroSolve, plotting, reporting)\n\nCalc Patterns:\n\nThe design supports three complementary patterns for defining calcs:\n\nSubject-Variable Binding - Standard pattern for accessing properties of domain objects\nExample: OrbitCalc(spacecraft, SMA()) accesses semi-major axis\nUse when: Accessing a well-defined quantity from a single subject type\nCharacteristics: Type-safe, extensible via dispatch, clear semantics\nMulti-Subject Calcs - Access quantities involving multiple domain objects\nExample: RelativeMotionCalc(sat1, sat2, RelativeDistance()) \nUse when: Quantity depends on relationships between multiple objects\nCharacteristics: Same subject-variable binding pattern, multiple subjects\nFunction-Based Calcs - Arbitrary computations over domain objects\nExample: Custom cost function, complex constraint, physics-based metric\nUse when: Computation doesn't map cleanly to a variable type, or requires complex logic\nCharacteristics: Maximum flexibility, user-defined computation\nImplementation: Custom calc struct holds function + object references, get_calc() evaluates function\n\nAll three patterns share the same public interface (get_calc(), set_calc!(), attribute functions) enabling uniform integration into optimization, plotting, and reporting workflows regardless of underlying implementation.\n\nThe following subsections detail the specific types, functions, patterns, and conventions that implement this design.","category":"section"},{"location":"dev/astrocallbacks_spec/#Core-Components","page":"AstroCallbacks – Spec (v0.1)","title":"Core Components","text":"Calc Types (the wrappers):\n\nCalc types are structs that hold references to domain objects and specify what quantity to access:\n\nOrbitCalc - accesses spacecraft state quantities (mutable)\nManeuverCalc - accesses maneuver parameters (mutable)\nBodyCalc - accesses celestial body properties (typically read-only)\nTimeCalc - accesses time values with specified scale/format (mutable)\nCustom calc types - user-defined for multi-subject or composite calculations\n\nVariable Type Hierarchy (what quantities):\n\nVariable types specify which quantity a calc accesses. They are immutable singleton types organized in a hierarchy:\n\nAbstractCalcVariable - base type for all variable types\nAbstractOrbitVar - base for orbit quantities\nSMA, Inc, RAAN, Cartesian, etc. - concrete orbit variable types\nAbstractManeuverVar - base for maneuver quantities\nDeltaVMag, DeltaVVector, etc. - concrete maneuver variable types\nAbstractBodyVar - base for body quantities\nGravParam, Radius, etc. - concrete body variable types\nUser-defined variable types for custom quantities\n\nRelationship:\n\nCalc types combine one or more subjects with a variable type: CalcType(subject(s)..., VariableType())\n\nExample: OrbitCalc(spacecraft, SMA()) creates a calc that accesses the SMA of the spacecraft.\n\nFunctions:\n\nCore Access:\n\nget_calc(calc) - retrieve current value from calc\nset_calc!(calc, value) - update mutable calc (! indicates mutation)\n\nCalc Attributes:\n\nis_settable(calc) - returns true if calc supports modification\nis_numeric(calc) - returns true if calc returns numeric type\nlength(calc) - returns dimensionality (1 for scalar, n for vector)\n\nExtensibility:\n\nmake_calc(subject(s), variable) - dispatch point for creating calcs (extensibility)\n\nPatterns:\n\nSubject-Variable Binding: CalcType(subject(s), variable_type)\nExample: OrbitCalc(spacecraft, SMA()), ManeuverCalc(maneuver, DeltaVVector())\nDirect Object Reference: CalcType(object, ...params)\nExample: TimeCalc(sat.time, TDB(), JD())\nComposite Calcs: Custom struct holds multiple references, aggregates in get_calc()","category":"section"},{"location":"dev/astrocallbacks_spec/#Usage-Examples","page":"AstroCallbacks – Spec (v0.1)","title":"Usage Examples","text":"Use Case: Full Spacecraft State and Core API\n\nDemonstrates complete calc API: creation, get, set, and attribute queries.\n\n# Create spacecraft\nsat = Spacecraft(\n    state = CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]),\n    time = Time(\"2025-01-01T00:00:00\", UTC(), ISOT())\n)\n\n# Create calc for full Cartesian state\nstate_calc = OrbitCalc(sat, IncomingAsymptote())\n\n# Read current value\ncurrent_state = get_calc(state_calc)  \n# Returns: [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0] (6-element vector [x,y,z,vx,vy,vz])\n\n# Modify value (if settable)\nnew_state = [7100.0, 100.0, 50.0, 0.1, 7.6, 0.2]\nset_calc!(state_calc, new_state)\n# Spacecraft state updated in-place\n\n# Query calc attributes\nis_settable(state_calc)  # Returns: true (can modify spacecraft state)\nis_numeric(state_calc)   # Returns: true (returns Float64 vector)\nlength(state_calc)       # Returns: 6 (dimensionality: [x,y,z,vx,vy,vz])\n\n# Other element types\nstate_calc = OrbitCalc(sat, IncomingAsymptote())\n\n\n\nUse Case: Spacecraft State Element\n\nAccess individual orbital elements (scalar or vector quantities).\n\n# Scalar orbital element\nsma_calc = OrbitCalc(sat, SMA())         # Semi-major axis (km)\ninc_calc = OrbitCalc(sat, Inc())         # Inclination (rad)\n\n\n\nUse Case: Time in Different Scales and Formats\n\nTime calcs support multiple time scales (UTC, TDB, TT) and formats (numeric vs string).\n\n# Numeric formats (settable, for optimization/plotting)\njd_calc = TimeCalc(sat.time, TDB(), JD())        # Julian Date\nmjd_calc = TimeCalc(sat.time, UTC(), MJD())      # Modified Julian Date  \n\n# String format (read-only, for reporting)\niso_calc = TimeCalc(sat.time, UTC(), ISOT())           # ISO 8601 string\n# get_calc(iso_calc) returns \"2025-01-01T00:00:00\"\n\n\n\nUse Case: Custom Composite Calc\n\nAggregate values from multiple existing calcs.\n\n# Define custom calc struct (holds references to multiple objects)\nstruct TotalDeltaVCalc\n    maneuvers::Vector{ImpulsiveManeuver}\n    spacecraft::Spacecraft\nend\n\n# Implement get_calc (aggregates from other calcs)\nfunction AstroCallbacks.get_calc(calc::TotalDeltaVCalc)\n    total = 0.0\n    for mnv in calc.maneuvers\n        dv_calc = ManeuverCalc(mnv, calc.spacecraft, DeltaVMag())\n        total += get_calc(dv_calc)\n    end\n    return total\nend\n\n# Usage\ntoi = ImpulsiveManeuver(axes=VNB(), element1=2.5, element2=0.0, element3=0.0)\nmcc = ImpulsiveManeuver(axes=VNB(), element1=0.6, element2=0.5, element3=0.0) \nmoi = ImpulsiveManeuver(axes=VNB(), element1=0.3, element2=0.0, element3=0.0)\n\ntotal_dv_calc = TotalDeltaVCalc([toi, mcc, moi], sat)\n# get_calc(total_dv_calc) returns ~3.27 km/s\n\n\n\nUse Case: Maneuver Parameters (Multi-Subject Pattern)\n\nAccess and modify impulsive maneuver delta-v components.\n\n# Create maneuver in VNB frame\ntoi = ImpulsiveManeuver(axes=VNB(), element1=2.5, element2=0.1, element3=-0.2)\n\n# Scalar maneuver magnitude (read-only, computed)\nmag_calc = ManeuverCalc(toi, sat, DeltaVMag())\n# get_calc(mag_calc) returns ~2.51 km/s\n\n# Vector maneuver components (settable)\nvec_calc = ManeuverCalc(toi, sat, DeltaVVector())\n# get_calc(vec_calc) returns [2.5, 0.1, -0.2]\n# set_calc!(vec_calc, [2.6, 0.0, 0.0]) updates maneuver\n\n# Note: ManeuverCalc demonstrates Pattern 2 (Multi-Subject Calcs)\n# Takes two subjects: maneuver and spacecraft (needed for frame transformations)\n\n\n\nUse Case: Celestial Body Properties\n\nAccess celestial body properties (typically read-only).\n\n# Body gravitational parameter\nmu_calc = BodyCalc(earth, GravParam())\n# get_calc(mu_calc) returns 398600.4418 (km³/s²)\n\n# Body equatorial radius  \nradius_calc = BodyCalc(earth, Radius())\n# get_calc(radius_calc) returns 6378.137 (km)\n\n# Body properties are typically read-only\n# set_calc!(mu_calc, new_value) would throw error\n\n\n\nUse Case: Custom Variable and Vector Calcs\n\nWrap user-defined parameters as calcs for optimization.\n\n# Scalar parameter\nstop_radius = VariableCalc(10000.0)\nget_calc(stop_radius)           # Returns: 10000.0\nset_calc!(stop_radius, 9500.0)  # Updates internal value\nget_calc(stop_radius)           # Returns: 9500.0\n\n# Vector parameter\ngains = VariableCalc([0.1, 0.2, 0.3])\nget_calc(gains)                    # Returns: [0.1, 0.2, 0.3]\nset_calc!(gains, [0.15, 0.25, 0.35])\n\n# Use in optimization\nvar_radius = SolverVariable(calc=stop_radius, lower=8000.0, upper=12000.0)\nvar_gains = SolverVariable(calc=gains, lower=[0.0, 0.0, 0.0], upper=[1.0, 1.0, 1.0])\n\n# Use in functions (accepts calc or literal)\npropagate!(prop, sat, StopAt(sat, PosMag(), stop_radius))\n# StopAt evaluates: get_calc(stop_radius) during propagation\n\n# Pattern: Any function accepting numeric values can accept calc\n# Enables parameter optimization without changing function signatures\n\n\n\nUse Case (DEFERRED): Spacecraft Properties\n\nDesign validation for spacecraft-level properties (mass, area, coefficients).\n\n# Mass (changes with maneuvers)\nmass_calc = SpacecraftCalc(sat, Mass())\n# get_calc(mass_calc) returns current mass (kg)\n# set_calc!(mass_calc, 1500.0) updates mass\n\n# Drag coefficient (configuration parameter)\ncd_calc = SpacecraftCalc(sat, DragCoefficient())\n# get_calc(cd_calc) returns Cd value\n# set_calc!(cd_calc, 2.2) updates coefficient\n\n# Pattern: Same subject-variable binding, works with existing design\n# DEFERRED: Implementation not required for initial release\n\n\n\nUse Case (DEFERRED): ForceModel Properties\n\nDesign validation for force model configuration parameters.\n\n# Gravity field degree/order\ndegree_calc = ForceModelCalc(gravity_model, GravityDegree())\n# get_calc(degree_calc) returns current degree\n# set_calc!(degree_calc, 8) updates degree\n\n# Integrator tolerance\ntol_calc = IntegratorCalc(integrator, RelativeTolerance())\n# get_calc(tol_calc) returns current reltol\n# set_calc!(tol_calc, 1e-10) updates tolerance\n\n# Pattern: Same subject-variable binding, extends naturally to new domains\n# DEFERRED: Implementation not required for initial release\n\n\n\nUse Case: Relative/Elapsed Time\n\nElapsed time from anchor captured at construction.\n\n# Time interval between two epochs (explicit endpoints)\nt1 = Time(\"2025-01-01T00:00:00\", UTC(), ISOT())\nt2 = Time(\"2025-01-15T12:00:00\", UTC(), ISOT())\ndt_calc = TimeInterval(t1, t2, Days())\n# get_calc(dt_calc) returns 14.5 (days)\n\n# Elapsed time from anchor (captured at construction)\n# Use case: \"propagate for 3 days\", \"stop after 2 hours\", time-series plotting\nelapsed_calc = RelativeTimeCalc(sat, ElapsedDays())\n# Constructor deep copies sat.time as immutable anchor\n# get_calc(elapsed_calc) returns days elapsed from anchor to current sat.time\n\n# Different time units via variable type\nelapsed_sec = RelativeTimeCalc(sat, ElapsedSeconds())\nelapsed_hr = RelativeTimeCalc(sat, ElapsedHours())\n\n# Use in propagation stopping conditions\npropagate!(prop, sat, StopAt(sat, elapsed_calc, 3.0))  # Stop after 3 days from anchor\n\n# Use in optimization (anchor remains fixed across iterations)\nvar_time = SolverVariable(calc=elapsed_calc, lower=0.0, upper=10.0)\n\n# Use in plotting (anchor set once, tracks elapsed time)\ntimes = []\nsmas = []\nfor step in propagation_history\n    push!(times, get_calc(elapsed_calc))  # Elapsed days from anchor\n    push!(smas, get_calc(OrbitCalc(sat, SMA())))\nend\nplot(times, smas)  # X-axis: days from mission start\n\n# Pattern: RelativeTimeCalc follows subject-variable binding\n# Variable types: ElapsedDays(), ElapsedSeconds(), ElapsedHours()\n# Anchor captured at construction, remains immutable thereafter\n\n\n\nUse Case: Function-Based Calc\n\nArbitrary computation using closure pattern (Pattern 3).\n\n# Define custom calc with function + references\nstruct CustomCostCalc\n    func::Function\n    spacecraft::Spacecraft\n    target_sma::Float64\nend\n\n# Implement get_calc (evaluates custom function)\nfunction AstroCallbacks.get_calc(calc::CustomCostCalc)\n    sma_calc = OrbitCalc(calc.spacecraft, SMA())\n    current_sma = get_calc(sma_calc)\n    return (current_sma - calc.target_sma)^2  # Quadratic cost\nend\n\n# Usage\ncost_calc = CustomCostCalc(\n    (sc, tgt) -> (get_calc(OrbitCalc(sc, SMA())) - tgt)^2,\n    sat,\n    42000.0  # target GEO radius\n)\n# get_calc(cost_calc) evaluates arbitrary function\n\n# Pattern: Maximum flexibility, any computation, same interface\n\n\n\nUse Case: Attribute Queries\n\nExternal modules check calc attributes before use.\n\n# Optimizer checks before creating SolverVariable\nstate_calc = OrbitCalc(sat, Cartesian())\nif is_settable(state_calc) && is_numeric(state_calc)\n    var = SolverVariable(calc=state_calc, lower=..., upper=...)\nelse\n    error(\"Calc must be settable and numeric for optimization\")\nend\n\n# Plotter queries dimensionality\nsma_calc = OrbitCalc(sat, SMA())\nif length(sma_calc) == 1\n    plot_scalar_timeseries(sma_calc)\nelse\n    plot_vector_timeseries(sma_calc)\nend\n\n# Reporter handles non-numeric calcs\ntime_calc = TimeCalc(sat.time, UTC(), ISOT())\nif is_numeric(time_calc)\n    println(\"Time: \", get_calc(time_calc))\nelse\n    println(\"Time: \", get_calc(time_calc))  # String output\nend\n\n\n\nUse Case: Error Cases\n\nExternal modules check calc attributes before use.\n\n# Optimizer checks before creating SolverVariable\nstate_calc = OrbitCalc(sat, Cartesian())\nif is_settable(state_calc) && is_numeric(state_calc)\n    var = SolverVariable(calc=state_calc, lower=..., upper=...)\nelse\n    error(\"Calc must be settable and numeric for optimization\")\nend\n\n# Plotter queries dimensionality\nsma_calc = OrbitCalc(sat, SMA())\nif length(sma_calc) == 1\n    plot_scalar_timeseries(sma_calc)\nelse\n    plot_vector_timeseries(sma_calc)\nend\n\n# Reporter handles non-numeric calcs\ntime_calc = TimeCalc(sat.time, UTC(), ISOT())\nif is_numeric(time_calc)\n    println(\"Time: \", get_calc(time_calc))\nelse\n    println(\"Time: \", get_calc(time_calc))  # String output\nend\n\n\n\nError Cases\n\nInvalid operations produce clear error messages.\n\n# Error: Setting read-only calc\nmu_calc = BodyCalc(earth, GravParam())\n# set_calc!(mu_calc, 400000.0)\n# ERROR: Cannot set_calc! on read-only BodyCalc(earth, GravParam())\n\n# Error: Type mismatch\nstate_calc = OrbitCalc(sat, Cartesian())\n# set_calc!(state_calc, \"invalid\")\n# ERROR: Expected Vector{Float64}, got String\n\n# Error: Out-of-range value\nsma_calc = OrbitCalc(sat, SMA())\n# set_calc!(sma_calc, -7000.0)\n# ERROR: SMA must be positive, got -7000.0\n\n# Error: Unsupported variable type\n# calc = OrbitCalc(sat, UnsupportedVariable())\n# ERROR: No method get_calc(::OrbitCalc{Spacecraft, UnsupportedVariable})\n\n","category":"section"},{"location":"dev/astrocallbacks_spec/#Design-Decisions-and-Rationale","page":"AstroCallbacks – Spec (v0.1)","title":"Design Decisions and Rationale","text":"Why get/set pattern instead of property access?\n\nEnables dispatch on variable type\nSupports conversions (e.g., time scale/format conversions)\nAllows validation and side effects\nWorks with AD frameworks\n\nWhy subject-variable binding pattern?\n\nType-safe: compiler catches invalid combinations\nExtensible: users can add new combinations via multiple dispatch\nSelf-documenting: OrbitCalc(sat, SMA()) is clear\nAlternative considered: string-based lookup (\"sma\") - rejected for type safety\n\nWhy separate calc types per subject?\n\nClear ownership: OrbitCalc operates on spacecraft, ManeuverCalc on maneuvers\nEnables subject-specific optimizations\nBetter error messages\nAlternative: single universal Calc type - rejected for clarity and dispatch\n\nWhy mutable domain objects?\n\nIn-place propagation requires mutable spacecraft\nOptimization requires modifying variables without recreating objects\nAlternative: immutable with copy-on-write - rejected for performance\n\nCalc Attributes System\n\nExternal modules query calc capabilities before use:\n\nSettability: Can optimizer modify this? (is_settable(calc))\nValue Type: Numeric or non-numeric? (value_type(calc))\nContinuity: Suitable for gradient-based optimization? (is_continuous(calc))\nDimensionality: Scalar or vector? (length(get_calc(calc)))\nDifferentiability: Supports AD? (implementation-dependent)\n\nWhy attributes instead of fixed calc categories?\n\nFlexible: same calc can be numeric in one format, string in another (TimeCalc)\nExtensible: users can add custom attributes\nSelf-describing: calcs declare their own capabilities\nEnables runtime checks in external modules","category":"section"},{"location":"dev/astrocallbacks_spec/#Conventions-and-Constraints","page":"AstroCallbacks – Spec (v0.1)","title":"Conventions & Constraints","text":"Naming:\n\nCalc types named by subject: OrbitCalc, ManeuverCalc, BodyCalc, TimeCalc\nVariable types named by quantity: SMA, Inc, Cartesian, DeltaVMag\nFollow Julia style: CamelCase for types, snake_case for functions\n\nNumeric Types:\n\nDefault: Float64 for all numeric calculations\nAD compatibility: all numeric calcs must work with ForwardDiff.Dual\nVector returns: Vector{Float64} (not SVector - simplicity over performance here)\n\nMutability:\n\nDomain objects (Spacecraft, Maneuver, Time) are mutable\nCalc objects themselves are typically immutable (just hold references)\nVariable type objects (SMA(), Cartesian()) are immutable singletons\n\nError Handling:\n\nThrow errors for invalid inputs (wrong types, out-of-range values)\nThrow errors for unsupported operations (set_calc! on read-only calc)\nValidation at calc construction when possible\nClear error messages: \"Cannot set_calc! on read-only calc OrbitCalc(sat, SMA())\"\n\nUnits:\n\nDistances: km\nVelocities: km/s  \nAngles: radians (internal), may accept degrees in constructors with explicit type\nTime: Julian Date (Float64) for numeric formats\nMass: kg\nGravitational parameter: km³/s²","category":"section"},{"location":"dev/astrocallbacks_spec/#4.-Package-Interactions-(Where-it-fits)","page":"AstroCallbacks – Spec (v0.1)","title":"4. Package Interactions (Where it fits)","text":"Package Dependencies:\n\nAstroStates - spacecraft state representations (CartesianState, etc.)\nAstroManeuvers - maneuver types (ImpulsiveManeuver, etc.)\nAstroUniverse - celestial bodies\nAstroEpochs - Time type and time scale/format handling\n\nUsed by:\n\nAstroSolve - optimization variables and constraints\nPlotting packages - time series of orbit elements, state components\nReporting tools - formatted output of mission data\nCustom analysis scripts - user-defined calculations\n\nExample Interactions:\n\nAstroSolve Integration:\n\n# AstroSolve checks calc attributes before creating SolverVariable\nstate_calc = OrbitCalc(sat, Cartesian())\n\n# Hypothetical: AstroSolve validates before use\nif is_settable(state_calc) && is_continuous(state_calc)\n    var = SolverVariable(calc=state_calc, lower=..., upper=...)\nelse\n    error(\"Calc must be settable and continuous for optimization\")\nend\n\nPlotting Integration:\n\n# Plotting package queries calc over time\nsma_calc = OrbitCalc(sat, SMA())\nsma_values = []\nfor t in time_range\n    set_time!(sat, t)\n    push!(sma_values, get_calc(sma_calc))\nend\nplot(time_range, sma_values)\n\nReporting Integration:\n\n# Reporting accepts any calc, including non-numeric\ntime_calc = TimeCalc(sat.time, UTC(), ISOT())\nsma_calc = OrbitCalc(sat, SMA())\n\nprintln(\"Time: \", get_calc(time_calc))      # \"2025-01-01T00:00:00\"\nprintln(\"SMA: \", get_calc(sma_calc), \" km\") # \"7000.0 km\"","category":"section"},{"location":"dev/astrocallbacks_spec/#5.-Testing-(How-we-verify-it)","page":"AstroCallbacks – Spec (v0.1)","title":"5. Testing (How we verify it)","text":"","category":"section"},{"location":"dev/astrocallbacks_spec/#Test-categories:","page":"AstroCallbacks – Spec (v0.1)","title":"Test categories:","text":"Input Validation\n\nInvalid types rejected (e.g., passing non-spacecraft to OrbitCalc)\nOut-of-range values caught in set_calc! (e.g., negative SMA)\nInconsistent combinations detected (e.g., unsupported variable types)\nClear error messages provided\n\nCorrectness\n\nget_calc returns correct values from domain objects\nset_calc! properly updates underlying objects\nMutability contracts honored (read-only calcs throw on set_calc!)\nType stability maintained\nVector calcs return correct dimensions\n\nNumeric Accuracy\n\nState conversions accurate (Cartesian ↔ Keplerian)\nTime scale conversions accurate (UTC ↔ TDB ↔ TT)\nTolerance: 1e-12 for dimensionless quantities\nReference: validated against published ephemerides, analytical solutions\n\nIntegration\n\nWorks with AstroStates state representations\nCompatible with ForwardDiff for AD\nCalcs properly update when domain objects change\nComposite calcs correctly aggregate values\n\nRegression\n\nFixed bugs have test coverage with issue references\nKnown edge cases covered (singularities in orbital elements, time scale boundaries, etc.)","category":"section"},{"location":"dev/astrocallbacks_spec/#Notes:","page":"AstroCallbacks – Spec (v0.1)","title":"Notes:","text":"Calc-specific edge cases in individual calc tests\nPerformance benchmarks not required unless performance issues identified","category":"section"},{"location":"dev/astrocallbacks_spec/#6.-Implementation-Plan","page":"AstroCallbacks – Spec (v0.1)","title":"6. Implementation Plan","text":"Refactor function names for attributes and test\nChange calc_is_settable() → is_settable()\nChange calc_numvars() → length()\nAdd is_numeric() (new function)\nUpdate all tests to use new naming convention\nImplement Cartesian() and other state reps\nTODO: Resolve ManeuverCalc constructor interface inconsistency\nCurrent: Struct has 3 fields (man, sc, var) but examples show both 2-arg and 3-arg constructors\nExamples in maneuvercalc_deltavvector.jl show: ManeuverCalc(dv, DeltaVVector())\nDocstring in AstroCallbacks.jl shows: ManeuverCalc(m, sc, DeltaVVector())\nDecision needed: Should constructors take minimum args? Does DeltaVVector need spacecraft?\nImpact: Update all examples and docs to match chosen interface\nPrinciple: Constructors should take minimum required arg set","category":"section"},{"location":"#AstroCallbacks","page":"AstroCallbacks","title":"AstroCallbacks","text":"AstroCallbacks provides fundamental calculations used throughout the Epicycle ecosystem. These calculations can be used in targeting and optimization variables and constraints, propagator stopping conditions, I/O operations, and eventally solver-for and consider parameters for orbit determination.\n\nThe module serves as a foundation for higher-level astrodynamics operations, providing core mathematical functions and utilities needed across multiple Epicycle packages.","category":"section"},{"location":"#Calculation-Framework","page":"AstroCallbacks","title":"Calculation Framework","text":"AstroCallbacks contains the \"Calcs\" - a collection of structs that provide a unified interface for setting and getting quantities throughout Epicycle. These calculation objects can be used in stopping conditions, solver variables and constraints, and estimator solve-for and consider parameters.\n\nThe Calc framework provides type-stable access to commonly needed astrodynamics quantities while maintaining automatic differentiation compatibility. Each Calc struct implements standardized interfaces for both retrieving values from spacecraft states, celestial bodies, and setting target values for optimization.","category":"section"},{"location":"#Calc-Types","page":"AstroCallbacks","title":"Calc Types","text":"The framework includes several categories of calculations, and is designed for extensibility. A few types of Calcs include:\n\nOrbitCalc: Semi-major axis, eccentricity, inclination, incoming/outgoing asymptotes, periapsis conditions, and other orbital properties\nBodyCalc: Celestial body gravitational parameters, physical properties, and other body-specific quantities  \nManeuverCalc: Δv components and magnitude, thrust direction, and other maneuver-related properties\n\nEach Calc type supports both getter operations (extracting values) and setter operations (defining target values for optimization or constraints).","category":"section"},{"location":"#Quick-Start","page":"AstroCallbacks","title":"Quick Start","text":"Examples of common orbital calculations: (see AstroProp and AstroSolve docs for interation into those packages in stopping conditions, optimization variables, and constraints.)\n\nusing AstroCallbacks, AstroStates, AstroModels\n\n# Create a spacecraft with orbital state\nsc = Spacecraft(state = CartesianState([7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]), \n                time = Time(\"2024-01-01T12:00:00\", UTC(), ISOT()), \n                mass = 1000.0)\n\n# Get semi-major axis from current state\nsma_calc = OrbitCalc(sc, SMA())\na = get_calc(sma_calc)           \nset_calc!(sma_calc, 10000.0)  \n\n# Set target incoming asymptote (rp = 6900, C3 = 14.0)\nhyp = OrbitCalc(sc, IncomingAsymptote())\nset_calc!(hyp, [6900.0, 14.0, 0.0, 0.0, 0.0, 0.0])  \n    \n# Set and get Earth's mu\nmu_calc = BodyCalc(earth, GravParam())\nμ = get_calc(mu_calc)            \nset_calc!(mu_calc, 3.986e5)      \n\n# Set and get maneuver elements\ntoi = ImpulsiveManeuver()\ndvvec_calc = ManeuverCalc(toi, sc, DeltaVVector())\nΔv = get_calc(dvvec_calc)   \nset_calc!(dvvec_calc, [0.2, 0.3, 0.4])","category":"section"},{"location":"#Table-of-Contents","page":"AstroCallbacks","title":"Table of Contents","text":"","category":"section"},{"location":"#API-Reference","page":"AstroCallbacks","title":"API Reference","text":"","category":"section"},{"location":"#AstroCallbacks.BodyCalc","page":"AstroCallbacks","title":"AstroCallbacks.BodyCalc","text":"BodyCalc(body::AbstractCelestialBody, var::AbstractBodyVar)\n\nCalc struct for set/get body-derived variables for a CelestialBody\n\nFields\n\nbody::B where B<:AbstractCelestialBody\nvar::V where V<:AbstractBodyVar\n\nNotes:\n\nFor a list of all supported BodyCalc variables, see ?AbstractBodyVar.\n\nExamples\n\nmu_calc = BodyCalc(earth, GravParam())\nmuval = get_calc(mu_calc)\nset_calc!(mu_calc, 3.986e5)\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.Constraint","page":"AstroCallbacks","title":"AstroCallbacks.Constraint","text":"Constraint(calc; lower_bounds, upper_bounds, scale)\n\nContainer that binds a calc and its bounds/scale for use in optimization, estimation, and analysis.\n\nFields\n\ncalc::C where C<:AbstractCalc\nlower_bounds::Vector{T}\nupper_bounds::Vector{T}\nscale::Vector{T}\nnumvars::Int\n\nNotes:\n\nThe keyword constructor infers numvars from the calc.\nElement type T is promoted across the three vectors (supports Dual numbers and BigFloat).\nUse func_eval(::Constraint) to evaluate the calc and return a Vector.\n\nExamples\n\nmu_calc = BodyCalc(earth, GravParam())\ncon = Constraint(calc=mu_calc, lower_bounds=[3.9e5], upper_bounds=[4.1e5], scale=[1.0])\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.Constraint-Tuple{}","page":"AstroCallbacks","title":"AstroCallbacks.Constraint","text":"function Constraint(; calc::AbstractCalc,\n                     lower_bounds::Union{AbstractVector{<:Real}, Nothing} = nothing,\n                     upper_bounds::Union{AbstractVector{<:Real}, Nothing} = nothing,\n                     scale::Union{AbstractVector{<:Real}, Nothing} = nothing)\n\nKeyword outer constructor for Constraint with intelligent defaults.\n\nAt least one of lower_bounds or upper_bounds must be specified.\n\nIf lower_bounds is not specified, defaults to fill(-Inf, n) where n is inferred from calc\nIf upper_bounds is not specified, defaults to fill(Inf, n) where n is inferred from calc  \nIf scale is not specified, defaults to ones(T, n) where T is inferred from bounds\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.DeltaVMag","page":"AstroCallbacks","title":"AstroCallbacks.DeltaVMag","text":"DeltaVMag <: AbstractManeuverVar\n\nTag struct indicating magnitude of the delta-V vector of a maneuver.\n\nExamples\n\n# dv::ImpulsiveManeuver — replace with your maneuver\ndvmag_calc = ManeuverCalc(dv, DeltaVMag())\nΔv = get_calc(dvmag_calc)     \n\nSee also\n\nDeltaVVector\nsubtypes(AbstractManeuverVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.Ecc","page":"AstroCallbacks","title":"AstroCallbacks.Ecc","text":"Ecc <: AbstractOrbitVar\n\nTag struct indicating Keplerian eccentricity of an orbit.\n\nExamples\n\n# sc::Spacecraft — replace with your Spacecraft instance\necc_calc = OrbitCalc(Spacecraft(), Ecc())\na = get_calc(ecc_calc)           \nset_calc!(ecc_calc, 0.02)        # set Ecc to 0.02\n\nSee also\n\nTA, RAAN, SMA\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.GravParam","page":"AstroCallbacks","title":"AstroCallbacks.GravParam","text":"GravParam <: AbstractBodyVar\n\nTag struct indicating gravitational parameter μ of a celestial body.\n\nExamples\n\nmu_calc = BodyCalc(earth, GravParam())\nμ = get_calc(mu_calc)            \nset_calc!(mu_calc, 3.986e5)       \n\nSee also\n\nBodyCalc\nsubtypes(AbstractBodyVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.Inc","page":"AstroCallbacks","title":"AstroCallbacks.Inc","text":"Inc <: AbstractOrbitVar\n\nTag struct indicating Keplerian inclination (radians) of a spacecraft.\n\nExamples\n\nsc = Spacecraft()\ninc_calc = OrbitCalc(sc, Inc())\ninc = get_calc(inc_calc)                # e.g., 0.4974 (28.5 degrees)\nset_calc!(inc_calc, deg2rad(2.0))     # set inclination to 2 degrees\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.ManeuverCalc","page":"AstroCallbacks","title":"AstroCallbacks.ManeuverCalc","text":"ManeuverCalc(man, sc::Spacecraft, var::AbstractManeuverVar)\n\nCalc struct for set/get maneuver-derived variables for a Maneuver and Spacecraft.\n\nFields\n\nman::M where M is a maneuver model (e.g., ImpulsiveManeuver)\nsc::S where S<:Spacecraft\nvar::V where V<:AbstractManeuverVar\n\nNotes:\n\nSee ?AbstractManeuverVar for supported maneuver variables (e.g., DeltaVVector).\nUse getcalc(::ManeuverCalc) to evaluate and setcalc!(::ManeuverCalc, values) to assign when supported.\n\nExamples\n\nm = ImpulsiveManeuver(axes=Inertial(), Isp=300.0, element1=0.01, element2=0.02,\n    element3=-0.03)\nsc = Spacecraft(\n    state     = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 1.0]),\n    time      = Time(\"2020-01-01T00:00:00\", TAI(), ISOT()),\n)\n\nmc_vec = ManeuverCalc(m, sc, DeltaVVector())\ndv = get_calc(mc_vec)\nset_calc!(mc_vec, [0.01, 0.02, -0.03])\n\nmc_mag = ManeuverCalc(m, sc, DeltaVMag())\ndvm = get_calc(mc_mag)\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.OrbitCalc","page":"AstroCallbacks","title":"AstroCallbacks.OrbitCalc","text":"OrbitCalc(sc::Spacecraft, var::AbstractOrbitVar; dependency = nothing)\n\nCalc struct for set/get orbit-derived variables for a spacecraft.\n\nFields\n\nsc::Spacecraft: Subject spacecraft.\nvar::AbstractOrbitVar: Orbit variable tag to evaluate (e.g., PositionVector()).\ndep: Optional dependency (e.g., another Spacecraft) or nothing.\n\nNotes:\n\nFor a list of all supported BodyCalc variables, see ?AbstractOrbitVar.\nConversions that require μ obtain it from the CoordinateSystem origin when available.\nUse get_calc(::OrbitCalc) to evaluate \nUse set_calc!(::OrbitCalc, values) to assign when supported.\n\nExamples\n\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 1.0]),\n    time  = Time(\"2020-09-21T12:23:12\", TAI(), ISOT()),\n)\noc = OrbitCalc(sc, PositionVector())\nr  = get_calc(oc)\nset_calc!(oc, [7000.0, 300.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.OrbitCalc-Union{Tuple{V}, Tuple{Spacecraft, V}} where V<:AbstractOrbitVar","page":"AstroCallbacks","title":"AstroCallbacks.OrbitCalc","text":"OrbitCalc(sc::Spacecraft, var::V; dependency=nothing) where {V<:AbstractOrbitVar}\n\nOuter constructor for OrbitCalc\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.OutGoingRLA","page":"AstroCallbacks","title":"AstroCallbacks.OutGoingRLA","text":"OutGoingRLA <: AbstractOrbitVar\n\nTag struct indicating outgoing hyperbolic asymptote right ascension (radians).\n\nExamples\n\n# sc::Spacecraft — replace with your Spacecraft instance\nrla_calc = OrbitCalc(Spacecraft(), OutGoingRLA())\nΩ_out = get_calc(rla_calc)       # e.g., 1.047\nset_calc!(rla_calc, pi/3)        # set outgoing RLA to 60 degrees\n\nSee also\n\nSMA, TA, RAAN\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.PosDotVel","page":"AstroCallbacks","title":"AstroCallbacks.PosDotVel","text":"PosDotVel <: AbstractOrbitVar\n\nTag struct indicating dot product of Cartesian position and velocity vectors.\n\nExamples\n\nsc = Spacecraft()\nposdotvel_calc = OrbitCalc(Spacecraft(), PosDotVel())\nr = get_calc(posdotvel_calc)\nset_calc!(posdotvel_calc, [7000.0, 300.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.PosMag","page":"AstroCallbacks","title":"AstroCallbacks.PosMag","text":"PosMag <: AbstractOrbitVar\n\nTag struct indicating Cartesian position vector magnitude (km) of a spacecraft.\n\nExamples\n\nposmag_calc = OrbitCalc(Spacecraft(), PosMag())\nr = get_calc(posmag_calc)          # e.g., 7020.31\nset_calc!(posmag_calc, 10000.0)    # set |r| to 10000 km (keeps direction)\n\nSee also\n\nPositionVector, VelocityVector, SMA\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.PosX","page":"AstroCallbacks","title":"AstroCallbacks.PosX","text":"PosX <: AbstractOrbitVar\n\nTag struct indicating Cartesian position vector x-component (km) of a spacecraft.\n\nExamples\n\nposx_calc = OrbitCalc(Spacecraft(), PosX())\nr = get_calc(posx_calc)          \nset_calc!(posx_calc, 10000.0)    \n\nSee also\n\nPositionVector, VelocityVector, SMA\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.PosZ","page":"AstroCallbacks","title":"AstroCallbacks.PosZ","text":"PosZ <: AbstractOrbitVar\n\nTag struct indicating Cartesian position vector z-component (km) of a spacecraft.\n\nExamples\n\nposz_calc = OrbitCalc(Spacecraft(), PosZ())\nr = get_calc(posz_calc)          \nset_calc!(posz_calc, 1000.0)    \n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.PositionVector","page":"AstroCallbacks","title":"AstroCallbacks.PositionVector","text":"PositionVector <: AbstractOrbitVar\n\nTag struct indicating Cartesian position vector (x, y, z) of a spacecraft.\n\nExamples\n\n# sc::Spacecraft — replace with your Spacecraft instance\nposvec_calc = OrbitCalc(Spacecraft(), PositionVector())\nr = get_calc(posvec_calc)\nset_calc!(posvec_calc, [7000.0, 300.0, 0.0])\n\nSee also\n\nPosMag, VelocityVector\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.RAAN","page":"AstroCallbacks","title":"AstroCallbacks.RAAN","text":"RAAN <: AbstractOrbitVar\n\nTag struct indicating Keplerian right ascension of ascending node (radians) of a spacecraft.\n\nExamples\n\nraan_calc = OrbitCalc(Spacecraft(), RAAN())\nΩ = get_calc(raan_calc)            # e.g., 1.234\nset_calc!(raan_calc, pi/2)         # set RAAN to 90 degrees\n\nSee also\n\nSMA, TA, INC\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.SMA","page":"AstroCallbacks","title":"AstroCallbacks.SMA","text":"SMA <: AbstractOrbitVar\n\nTag struct indicating Keplerian semi-major axis (km) of a spacecraft.\n\nExamples\n\nsma_calc = OrbitCalc(Spacecraft(), SMA())\na = get_calc(sma_calc)           # e.g., 7000.0\nset_calc!(sma_calc, 10000.0)     # set SMA to 10000 km\n\nSee also\n\nTA, RAAN, PositionVector\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.TA","page":"AstroCallbacks","title":"AstroCallbacks.TA","text":"TA <: AbstractOrbitVar\n\nTag struct indicating Keplerian true anomaly (radians) of a spacecraft.\n\nExamples\n\nta_calc = OrbitCalc(Spacecraft(), TA())\nθ = get_calc(ta_calc)            # e.g., 0.5235987756\nset_calc!(ta_calc, pi/6)         # set TA to 30 degrees\n\nSee also\n\nSMA, RAAN, INC\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.VelMag","page":"AstroCallbacks","title":"AstroCallbacks.VelMag","text":"VelMagMag <: AbstractOrbitVar\n\nTag struct indicating Cartesian velocity vector magnitude (km/s) of a spacecraft.\n\nExamples\n\nvelmag_calc = OrbitCalc(Spacecraft(), VelMag())\nr = get_calc(velmag_calc)          # e.g., 7.5\nset_calc!(velmag_calc, 10.0)       # set |v| to 10 km/s (keeps direction)\n\nSee also\n\nPositionVector, VelocityVector, SMA\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks.VelocityVector","page":"AstroCallbacks","title":"AstroCallbacks.VelocityVector","text":"VelocityVector <: AbstractOrbitVar\n\nTag struct indicating Cartesian velocity vector (vx, vy, vz) of a spacecraft.\n\nExamples\n\n# sc::Spacecraft — replace with your Spacecraft instance\nvelvec_calc = OrbitCalc(Spacecraft(), VelocityVector())\nr = get_calc(velvec_calc)\nset_calc!(velvec_calc, [7000.0, 300.0, 0.0])\n\nSee also\n\nPosMag, PositionVector\nsubtypes(AbstractOrbitVar) for a full list of supported variables\n\n\n\n\n\n","category":"type"},{"location":"#AstroCallbacks._extract_mu-Tuple{CoordinateSystem}","page":"AstroCallbacks","title":"AstroCallbacks._extract_mu","text":"function _extract_mu(cs::CoordinateSystem)\n\nExtract μ from a coordinate system origin if it exists\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks._infer_numvars-Tuple{AbstractCalc}","page":"AstroCallbacks","title":"AstroCallbacks._infer_numvars","text":"function _infer_numvars(c::AbstractCalc)\n\nReturn the number of variables for a calc.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks._set_calc_type!-Tuple{AbstractCalc, Any}","page":"AstroCallbacks","title":"AstroCallbacks._set_calc_type!","text":"_set_calc_type!(c::AbstractCalc, newval)\n\nFallback implementation for calc types that don't have specific _set_calc_type! methods. This should only be reached if settability checking is bypassed.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks._set_calc_type!-Tuple{ManeuverCalc, AbstractVector{<:Real}}","page":"AstroCallbacks","title":"AstroCallbacks._set_calc_type!","text":"_set_calc_type!(c::ManeuverCalc, vals::AbstractVector{<:Real})\n\nAssign new value(s) to a settable maneuver-derived variable.\n\nArguments\n\nc::ManeuverCalc: Container holding the maneuver model, spacecraft, and variable tag.\nvals::AbstractVector{<:Real}: New value(s) for the variable.\n\nNotes:\n\nDelegates to the variable-specific _set!(c, vals) implementation.\nSettability is checked by the generic set_calc! method.\n\nReturns\n\nReturns nothing. Performs inplace update of Maneuver.\nSpacecraft state is not modified.  Use maneuver!() to apply maneuver effects.\n\nExamples\n\nm  = ImpulsiveManeuver(axes=Inertial(), Isp=300.0, element1=0.01, element2=0.02, element3=-0.03)\nsc = Spacecraft(state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 1.0]),\n                time  = Time(\"2020-01-01T00:00:00\", TAI(), ISOT()))\nmc = ManeuverCalc(m, sc, DeltaVVector())\nset_calc!(mc, [0.01, 0.02, -0.03])\n\n# output\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks._set_calc_type!-Tuple{OrbitCalc, Real}","page":"AstroCallbacks","title":"AstroCallbacks._set_calc_type!","text":"_set_calc_type!(c::OrbitCalc, newval::Real)\n\nType-specific implementation for OrbitCalc scalar assignments. Pass in real as a 1x1 vector to vector dispatch.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks._set_calc_type!-Tuple{OrbitCalc, Vector{<:Real}}","page":"AstroCallbacks","title":"AstroCallbacks._set_calc_type!","text":"set_calc!(c::OrbitCalc, newval::Vector{<:Real})\n\nAssign a new value to a settable orbit-derived variable.\n\nArguments\n\nc::OrbitCalc: Container holding the spacecraft and variable tag.\nnewval::Vector{<:Real}: New value(s) for the variable.\n\nNotes:\n\nRequired input state is determined by calc_input_statetag(c.var) and converted as needed.\nAfter assignment, the spacecraft’s state is converted back to its original type and updated.\nNon-settable variables throw an error (see calc_is_settable).\n\nReturns\n\nOrbitState: The updated spacecraft state.\n\nExamples\n\nsc = Spacecraft(\n    state = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 1.0]),\n    time  = Time(\"2020-09-21T12:23:12\", TAI(), ISOT()),\n)\noc = OrbitCalc(sc, PositionVector())\nset_calc!(oc, [7000.0, 300.0, 0.0])\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks._state_for_calc-Tuple{OrbitCalc}","page":"AstroCallbacks","title":"AstroCallbacks._state_for_calc","text":"function _state_for_calc(c::OrbitCalc)::AbstractOrbitState\n\nCompute the state type required for the orbit calc variable.  Performs conversion if needed.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks._subjects_from_calc-Tuple{OrbitCalc}","page":"AstroCallbacks","title":"AstroCallbacks._subjects_from_calc","text":"function _subjects_from_calc(c::AbstractCalc)\n\nExtract the references used in a Calc instance. For example, an OrbitCalc will return the spacecraft it references.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.calc_input_statetag-Tuple{AbstractOrbitVar}","page":"AstroCallbacks","title":"AstroCallbacks.calc_input_statetag","text":"function calc_input_statetag(v::AbstractOrbitVar)\n\nFallback to catch undeclared OrbitCalc state type tags\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.calc_is_settable-Tuple{AbstractCalcVariable}","page":"AstroCallbacks","title":"AstroCallbacks.calc_is_settable","text":"calc_is_settable(::AbstractCalcVariable)::Bool\n\nFallback method to indicate if a Calc variable is settable.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.convert_orbitcalc_state-Tuple{AbstractOrbitState, CoordinateSystem, AbstractOrbitStateType}","page":"AstroCallbacks","title":"AstroCallbacks.convert_orbitcalc_state","text":"function convert_orbitcalc_state(st::AbstractOrbitState, cs::CoordinateSystem, \n                        target::AbstractOrbitStateType)::AbstractOrbitState\n\nConvert AbstractOrbitState to state types and coordinates needed for OrbitCalc variable.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.convert_orbitcalc_state-Tuple{OrbitState, CoordinateSystem, AbstractOrbitStateType}","page":"AstroCallbacks","title":"AstroCallbacks.convert_orbitcalc_state","text":"function convert_orbitcalc_state(os::OrbitState, cs::CoordinateSystem, target::AbstractOrbitStateType)::AbstractOrbitState\n\nConvert OrbitState to state types and coordinates needed for OrbitCalc variable.\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.func_eval-Tuple{Constraint}","page":"AstroCallbacks","title":"AstroCallbacks.func_eval","text":"function func_eval(constraint::Constraint)\n\nEvaluate the constraint's calc and return a Vector preserving eltype (AD-friendly)\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.get_calc-Tuple{BodyCalc}","page":"AstroCallbacks","title":"AstroCallbacks.get_calc","text":"function get_calc(c::AbstractCalc)\n\nCompute the value of a Calc variable. Generic get_calc methods  interface simple Calc types. More complicated types (i.e. OrbitCalc have custom interfaces)  \n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.get_calc-Tuple{OrbitCalc}","page":"AstroCallbacks","title":"AstroCallbacks.get_calc","text":"get_calc(c::OrbitCalc)\n\nCompute the value of an orbit-derived variable..\n\nArguments\n\nc::OrbitCalc: Container holding the spacecraft, variable tag, and optional dependency.\n\nReturns\n\nNumber or Vector{<:Real}: Computed value of the requested orbit variable.\n\nNotes:\n\nRequired input state is determined by calc_input_statetag(c.var) and converted as needed.\nIf a conversion requires μ, it is taken from c.sc.coord_sys.origin when available.\n\nExamples\n\nsc = Spacecraft(\n    state     = CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 1.0]),\n    time      = Time(\"2020-09-21T12:23:12\", TAI(), ISOT()),\n)\noc = OrbitCalc(sc, PositionVector())\nval = get_calc(oc)\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.set_calc!-Tuple{AbstractCalc, Any}","page":"AstroCallbacks","title":"AstroCallbacks.set_calc!","text":"set_calc!(c::AbstractCalc, newval)\n\nSet calc after checking if it is settable.  (Generic dispatch to type-specific implementations.)\n\n\n\n\n\n","category":"method"},{"location":"#AstroCallbacks.to_concrete_state-Tuple{OrbitState}","page":"AstroCallbacks","title":"AstroCallbacks.to_concrete_state","text":"function to_concrete_state(os::OrbitState)::AbstractState\n\nConverts an OrbitState to its equivalent concrete AbstractState\n\nArguments\n\nos::OrbitState: The OrbitState instance to convert.\n\n\n\n\n\n","category":"method"}]
}
