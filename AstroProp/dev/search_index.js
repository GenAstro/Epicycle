var documenterSearchIndex = {"docs":
[{"location":"dev/astroprop_spec/#AstroProp-Stopping-Conditions-–-Spec-(v0.1)","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"AstroProp Stopping Conditions – Spec (v0.1)","text":"","category":"section"},{"location":"dev/astroprop_spec/#1.-Overview-and-Scope-(What-are-we-building?)","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"1. Overview and Scope (What are we building?)","text":"Purpose:\n\nStopping conditions enable termination of orbital propagation when specific events occur (state-based) or time thresholds are reached (time-based). They integrate with the propagation loop to detect events and halt integration at precise conditions.\n\nIn-scope:\n\nState-based stopping conditions (position, velocity, orbital elements)\nTime-based stopping conditions (elapsed duration, absolute epoch)\nEvent detection and root-finding during propagation\nDirection-aware crossing detection (increasing, decreasing, any)\nTime scale handling (TT for Earth-centered, TDB for other centers)\nOptimization-compatible duration variables (accept positive/negative values)\n\nOut-of-scope:\n\nContinuous event logging (only stop at first occurrence)\nMulti-event chains (stop conditions are single-target)\nMultiple time-based stopping conditions (only one time-based stop allowed per propagation)\nEvent sequencing logic (that's AstroSolve)\nCustom event functions beyond StopAt pattern","category":"section"},{"location":"dev/astroprop_spec/#2.-Requirements-(What-we-are-building.)","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"2. Requirements (What we are building.)","text":"R1: State-Based Stopping\n\nMust support stopping when any calc variable (position, velocity, orbital elements) crosses a target value\nMust detect crossings with specified direction (increasing, decreasing, or any)\nMust achieve target value within specified tolerance\n\nR2: Time-Based Duration Stopping\n\nMust support stopping after elapsed time duration (seconds, days)\nMust accept positive durations (forward propagation) and negative durations (backward propagation)\nMust infer propagation direction from duration sign when direction=:infer\nMust work as optimization variables (no rejection of negative values)\nMust use appropriate dynamical time scale (TT for Earth-centered, TDB otherwise)\n\nR3: Absolute Time Stopping\n\nMust support stopping at a specific absolute epoch (past or future)\nMust handle time scale conversions automatically\nMust infer propagation direction from time comparison when direction=:infer\n\nR4: Type Safety\n\nMust use AbstractCalcVariable type hierarchy for compile-time validation\nMust reject invalid variable types at construction\nMust provide clear error messages for type mismatches\n\nR5: Integration with Propagation\n\nMust work with OrdinaryDiffEq.jl callback system for state-based conditions\nMust set integration time span directly for time-based conditions (no callbacks needed)\nMust preserve propagation history when stopping","category":"section"},{"location":"dev/astroprop_spec/#3.-Design-(How-we-are-building-it.)","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"3. Design (How we are building it.)","text":"","category":"section"},{"location":"dev/astroprop_spec/#Core-Components","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"Core Components","text":"Types:\n\nStopAt{S,V<:AbstractCalcVariable,T} - Generic stopping condition wrapper\nFields: subject, var, target, direction\nImmutable struct holding stopping criteria\nType parameters ensure compile-time safety\nIntegratorTimeCalc <: AbstractCalcVariable - Abstract base for time-based stops\nMarker type distinguishing time-based from state-based\nHandled specially by propagate() (no callback, sets time span)\nNot general-purpose calcs - propagation-specific only\nPropDurationSeconds <: IntegratorTimeCalc - Elapsed time in seconds\nPositive value = forward propagation\nNegative value = backward propagation\nZero not allowed\nPropDurationDays <: IntegratorTimeCalc - Elapsed time in days\nSame sign semantics as PropDurationSeconds\nConverted to seconds internally (×86400)\n\nFunctions:\n\nStopAt(subject, var, target; direction=0) - Main constructor\ndirection: -1 (decreasing), 0 (any), +1 (increasing)\nValidates var <: AbstractCalcVariable\nStopAt(subject::Spacecraft, target_time::Time; direction=0) - Convenience for absolute time\nConverts absolute time to elapsed seconds\nUses TT for Earth-centered, TDB otherwise (based on force model central body)\nSupports past times with direction=:infer, errors with direction=:forward\npropagate(prop, spacecraft, stop_condition; direction=:forward) - Integration driver\ndirection keyword: :forward (default), :backward, or :infer (analyze stop condition)\n:infer determines direction from stop condition (duration sign, time comparison)\nExplicit :forward/:backward can validate agreement with stop condition\n\nDirection Inference:\n\nFor PropDuration*: Direction inferred from duration sign (positive=forward, negative=backward)\nFor StopAt(Time): Direction inferred from time comparison (target>current=forward, target<current=backward)\nFor state-based: Direction defaults to :forward when :infer specified\nExplicit :forward/:backward validates against inferred direction\n\nPatterns:\n\nState-based: StopAt(subject, CalcVariable(), target_value; direction=...)\nDuration-based: StopAt(subject, PropDurationSeconds|Days(), duration) with direction=:infer\nAbsolute time: StopAt(subject, Time(...)) with direction=:infer","category":"section"},{"location":"dev/astroprop_spec/#Usage-Examples","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"Usage Examples","text":"UC-1: State-Based Stopping (Addresses R1)\n\nStop when spacecraft crosses specific position/velocity threshold.\n\n# Stop at periapsis (r·v = 0, increasing)\nstop_peri = StopAt(sat, PosDotVel(), 0.0; direction=+1)\npropagate(prop, sat, stop_peri)\n\n# Stop at radius = 7000 km (any crossing)\nstop_radius = StopAt(sat, PosMag(), 7000.0)\npropagate(prop, sat, stop_radius)\n\n# Stop at x = 500 km (decreasing)\nstop_x = StopAt(sat, PosX(), 500.0; direction=-1)\npropagate(prop, sat, stop_x)\n\nKey Points:\n\nUses AstroCallbacks calc variables (PosDotVel, PosMag, PosX)\nDirection control for precise event detection\nIntegrator finds exact crossing via root-finding\n\n\n\nUC-2: Forward Duration Stopping (Addresses R2)\n\nPropagate forward for specified duration.\n\n# Propagate for 3600 seconds (1 hour) - default :forward works\nstop_1hr = StopAt(sat, PropDurationSeconds(), 3600.0)\npropagate(prop, sat, stop_1hr)  # direction=:forward (default)\n\n# Propagate for 2.5 days\nstop_days = StopAt(sat, PropDurationDays(), 2.5)\npropagate(prop, sat, stop_days)  # Default :forward matches positive duration\n\n# Can explicitly validate if desired\npropagate(prop, sat, stop_days; direction=:forward)\n\nKey Points:\n\nPositive duration with default :forward direction works naturally\nNo need for :infer in common forward case\nUses TT for Earth-centered, TDB otherwise\nNo callback overhead (sets integration time span directly)\n\n\n\nUC-3: Backward Duration Stopping (Addresses R2)\n\nPropagate backward for specified duration.\n\n# Propagate backward for 7200 seconds (2 hours) - use :infer or :backward\nstop_back = StopAt(sat, PropDurationSeconds(), -7200.0)\npropagate(prop, sat, stop_back; direction=:infer)  # Infers :backward from negative\n# OR\npropagate(prop, sat, stop_back; direction=:backward)  # Explicit backward\n\n# Propagate backward for 1.5 days\nstop_back_days = StopAt(sat, PropDurationDays(), -1.5)\npropagate(prop, sat, stop_back_days; direction=:infer)  # Infers from sign\n\nKey Points:\n\nNegative duration requires explicit direction (default :forward would conflict)\nUse direction=:infer to infer from sign automatically\nOr use explicit direction=:backward\nSpacecraft time decreases after propagation\n\n\n\nUC-4: Duration in Optimization (Addresses R2)\n\nUse duration as optimization variable.\n\n# Duration is optimizable parameter\nduration_calc = VariableCalc(1.5)  # Initial guess: 1.5 days\nvar = SolverVariable(calc=duration_calc, lower=-10.0, upper=10.0)\n\n# In objective/constraint function - use :infer for automatic direction\nfunction propagate_and_evaluate(duration_calc)\n    dur_val = get_calc(duration_calc)\n    stop = StopAt(sat, PropDurationDays(), dur_val)\n    \n    # direction=:infer handles positive or negative duration automatically\n    propagate(prop, sat, stop; direction=:infer)\n    \n    # Evaluate cost/constraint...\nend\n\nKey Points:\n\nOptimizer can explore negative durations (backward propagation)\ndirection=:infer automatically handles sign changes (one line, no if-test!)\nMuch cleaner than manual direction checking\nNo error thrown for negative values\n\n\n\nUC-5: Absolute Time Stopping (Addresses R3)\n\nStop at specific epoch (past or future).\n\n# Target time 1 day in the future - default :forward works\ntarget_future = Time(\"2015-09-22T12:00:00\", UTC(), ISOT())\npropagate(prop, sat, StopAt(sat, target_future))  # direction=:forward (default)\n\n# Target time in the past - use :infer or explicit :backward\ntarget_past = Time(\"2015-09-20T12:00:00\", UTC(), ISOT())\npropagate(prop, sat, StopAt(sat, target_past); direction=:infer)  # Infers :backward\n# OR\npropagate(prop, sat, StopAt(sat, target_past); direction=:backward)  # Explicit\n\n# Internally converts to elapsed seconds in correct time scale\n# For Earth: uses TT\n# For Mars/others: uses TDB\n\nKey Points:\n\nTime scale conversion automatic (TT for Earth, TDB for others based on force model central body)\nFuture times work with default :forward\nPast times work with :infer (infers :backward from comparison) or explicit :backward\nPast times error with default :forward (conflict detection)\nDirection inferred from time comparison when :infer used\nImplemented as PropDurationSeconds internally with appropriate sign\n\n\n\nUC-6: Error Cases (Addresses R4)\n\nInvalid configurations are rejected.\n\n# Error: invalid direction value\nstop = StopAt(sat, PropDurationDays(), 1.5)\npropagate(prop, sat, stop; direction=:invalid)\n# ERROR: Invalid direction :invalid, must be :infer, :forward, or :backward\n\n# Error: explicit direction conflicts with inferred\nstop = StopAt(sat, PropDurationDays(), -1.5)  # Negative → infers :backward\npropagate(prop, sat, stop; direction=:forward)  # But user says :forward\n# ERROR: Inferred direction is :backward (negative duration) but explicit direction is :forward\n\n# Error: zero duration\nstop = StopAt(sat, PropDurationDays(), 0.0)\npropagate(prop, sat, stop)\n# ERROR: Duration must be non-zero\n\n# Error: multiple time-based stops\nstop1 = StopAt(sat, PropDurationSeconds(), 3600.0)\nstop2 = StopAt(sat, PropDurationDays(), 1.0)\npropagate(prop, sat, stop1, stop2)\n# ERROR: Multiple time-based stopping conditions not allowed\n\n# Error: positive duration with :backward\nstop = StopAt(sat, PropDurationDays(), 1.5)  # Positive → infers :forward\npropagate(prop, sat, stop; direction=:backward)  # But user says :backward\n# ERROR: Duration is positive (forward) but explicit direction is :backward\n\nKey Points:\n\nExplicit direction validated against inferred direction (both positive→:backward and negative→:forward conflict)\nZero duration rejected\nMultiple time-based stops rejected (ambiguous which to use)\nClear error messages with context\n\n","category":"section"},{"location":"dev/astroprop_spec/#Design-Decisions-and-Rationale","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"Design Decisions and Rationale","text":"Why PropDuration* instead of general elapsed time calcs?\n\nProblem: Elapsed time requires anchor point, unclear who owns it\nTried: RelativeTimeCalc(sat, ElapsedDays()) with anchor-at-construction\nIssue: Inline construction in loops creates new anchor each iteration\nSolution: PropDuration* are propagation-specific, anchor managed by propagate()\nFuture: May add general RelativeTimeCalc later with explicit anchor management\n\nWhy duration sign encodes direction with :infer?\n\nAlternative 1: Always positive, direction keyword required → errors in optimization\nAlternative 2: Signed duration, manual direction keyword → boilerplate in optimization\nSolution: Signed duration + direction=:infer (default) infers from sign\nBenefits: Clean optimization (no if-test), explicit override available, works for absolute time too\nTrade-off: Slightly \"magical\" but ergonomics win justifies it\n\nWhy separate StopAt(Time) constructor?\n\nCommon use case: \"propagate to epoch\"\nConvenience: Handles time scale conversion automatically\nImplementation: Converts to PropDurationSeconds internally\nAlternative considered: User manually computes elapsed time - rejected for ergonomics\n\nWhy IntegratorTimeCalc subtypes instead of TimeCalc?\n\nTimeCalc is for general time queries (scale conversions, formatting)\nPropDuration* are propagation-specific, not general-purpose\nInheritance from AbstractCalcVariable for type safety in StopAt\nNo make_calc() implementations (can't create OrbitCalc with these)\n\nWhy TT for Earth, TDB for others?\n\nEarth-based missions: TT (Terrestrial Time) is standard dynamical time\nSolar system missions: TDB (Barycentric Dynamical Time) is standard\nConsistency: Matches how integrator time is managed internally\nDetection: Based on force model central body (forces.center), not coordinate system\nReason: Propagation dynamics are governed by the central gravitational body","category":"section"},{"location":"dev/astroprop_spec/#Conventions-and-Constraints","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"Conventions & Constraints","text":"Naming:\n\nPropDuration* prefix signals propagation-specific scope\nLeaves ElapsedDays/Seconds/Hours available for future general calcs\nStopAt named for action (stop at event/time)\n\nNumeric Types:\n\nDuration: Float64 (can be negative for backward)\nTarget values: Float64 or Vector{Float64} (matches calc output)\nTime: Julian Date (Float64) internally\nTolerance: Integrator-dependent (typically 1e-9 relative)\n\nMutability:\n\nStopAt struct is immutable (just configuration)\nSpacecraft is mutated in-place by propagate()\nPropagation history updated during integration\n\nError Handling:\n\nThrow errors for invalid types at construction\nThrow errors for past target times\nThrow errors for direction keyword conflicts\nValidation before propagation starts (fail fast)\nClear error messages: \"Duration is negative (-1.5) but direction is :forward\"\n\nDuration Sign Semantics:\n\nPositive: Forward propagation (time increases)\nNegative: Backward propagation (time decreases)\nZero: Not allowed (would cause division by zero in validation)\nValidation: If direction keyword provided, must match sign\n\nDirection Keyword:\n\nDefault: :forward (most common case - forward propagation)\n:infer: Opt-in analysis of stop condition to determine direction\nTime-based (PropDuration*): Inferred from duration sign (positive=forward, negative=backward)\nTime-based (absolute): Inferred from time comparison (target>current=forward, target<current=backward)\nState-based: Defaults to :forward when :infer specified\nExplicit :backward: Required for backward propagation with default behavior\nExplicit :forward/:backward can validate against inferred direction when using :infer\nValues: :forward (default), :backward, :infer","category":"section"},{"location":"dev/astroprop_spec/#4.-Package-Interactions-(Where-it-fits)","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"4. Package Interactions (Where it fits)","text":"Package Dependencies:\n\nAstroCallbacks - OrbitCalc, AbstractCalcVariable hierarchy\nAstroEpochs - Time type, scale conversions\nAstroModels - Spacecraft type\nOrdinaryDiffEq - Integration and callback system\n\nUsed by:\n\nUser propagation scripts\nAstroSolve - optimization with time-based variables\nExample/tutorial code\n\nExample Interactions:\n\n# AstroCallbacks provides calc variables\nusing AstroCallbacks: PosMag, PosDotVel, PosX\n\n# AstroProp provides StopAt and propagate\nstop_condition = StopAt(sat, PosMag(), 7000.0)\npropagate(prop, sat, stop_condition)\n\n# AstroSolve uses duration as optimization variable\nduration_var = VariableCalc(2.0)\nsolver_var = SolverVariable(calc=duration_var, lower=-5.0, upper=5.0)","category":"section"},{"location":"dev/astroprop_spec/#5.-Testing-(How-we-verify-it)","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"5. Testing (How we verify it)","text":"","category":"section"},{"location":"dev/astroprop_spec/#Test-categories:","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"Test categories:","text":"Input Validation\n\nInvalid variable types rejected at StopAt construction\nPast target time throws error\nDirection-duration sign conflicts throw error\nZero duration throws error\nClear error messages for all validation failures\n\nCorrectness\n\nState-based stops achieve target within tolerance\nDirection constraints honored (increasing/decreasing crossings)\nDuration-based stops advance time by correct amount\nAbsolute time stops arrive at target epoch\nBackward propagation decreases time correctly\n\nNumeric Accuracy\n\nDuration-based: elapsed time matches target ±1e-6 seconds\nState-based: target value achieved ±1e-3 km or ±1e-6 rad\nTime scale conversions accurate ±1e-9 days\nReference: Analytical solutions, published ephemerides\n\nIntegration\n\nWorks with OrbitCalc variables from AstroCallbacks\nTime conversions via AstroEpochs\nPropagation updates Spacecraft state correctly\nHistory segments preserved after stopping\n\nRegression\n\nDuration sign semantics (positive=forward, negative=backward)\nDirection validation catches conflicts\nTT/TDB selection based on central body\nStopAt(Time) past-time detection","category":"section"},{"location":"dev/astroprop_spec/#Test-Coverage:","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"Test Coverage:","text":"PropDuration Tests:\n\nForward propagation (seconds, days)\nBackward propagation with :infer (seconds, days)\nBackward propagation with explicit :backward\nZero duration error\nDirection conflict validation (negative+:forward, positive+:backward)\nMultiple time-based stops error\n\nAbsolute Time Tests:\n\nFuture time stop\nPast time error\nTime scale conversion (UTC→TT, various scales)\n\nTime Scale Tests:\n\nEarth-centered uses TT\nMars-centered uses TDB\nOther bodies use TDB\n\nState-Based Tests:\n\nRadius crossing (any direction)\nPosition component (increasing/decreasing)\nOrbital element crossings","category":"section"},{"location":"dev/astroprop_spec/#Notes:","page":"AstroProp Stopping Conditions – Spec (v0.1)","title":"Notes:","text":"Tolerances reflect integrator accuracy, not event detection\nEvent detection accuracy depends on callback root-finding\nPropDuration* are propagation-specific, not tested as general calcs","category":"section"},{"location":"#AstroProp","page":"AstroProp","title":"AstroProp","text":"AstroProp provides force models, orbital propagators, and stopping conditions for modelling spacecraft motion. AstroProp provides interfaces to the extensive  numerical integration libraries in Julia's OrdinaryDiffEq.jl.  AstroProp is tested against the General Mission Analysis Tool (GMAT).","category":"section"},{"location":"#Quick-Start","page":"AstroProp","title":"Quick Start","text":"The example below shows how to propagate a spacecraft using various stopping conditions:\n\nusing Epicycle\n\n# Spacecraft\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)\n\n# Forces + integrator\ngravity = PointMassGravity(earth, (moon, sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate for 1 hour (3600 seconds)\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), 3600.0))\n\n# Propagate to an absolute time\ntarget_time = Time(\"2015-09-22T12:00:00\", TDB(), ISOT())\npropagate(prop, sat, StopAt(sat, target_time))\n\n# Propagate to periapsis (r·v = 0, increasing crossing)\npropagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=+1))\nprintln(get_state(sat, Keplerian()))\n\n# Propagate backward for 2 hours using negative duration\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), -7200.0); direction=:infer)\n\n# Stop when |r| reaches 7000 km \npropagate(prop, sat, StopAt(sat, PosMag(), 7000.0))\nprintln(get_state(sat, SphericalRADEC()))       \n\n# Propagate multiple spacecraft with multiple stopping conditions\nsc1 = Spacecraft(); sc2 = Spacecraft() \nstop_sc1_node = StopAt(sc1, PosZ(), 0.0)\nstop_sc2_periapsis = StopAt(sc2, PosDotVel(), 0.0; direction=+1)\npropagate(prop, [sc1, sc2], stop_sc1_node, stop_sc2_periapsis)","category":"section"},{"location":"#Function-Syntax","page":"AstroProp","title":"Function Syntax","text":"","category":"section"},{"location":"#propagate","page":"AstroProp","title":"propagate","text":"Propagates one or more spacecraft under specified forces to one or more stopping conditions.\n\nSyntax:\n\nsol = propagate(propagator, spacecraft, stops...; direction=:forward, kwargs...)\n\nParameters:\n\npropagator: An OrbitPropagator containing the force model and integrator configuration\nspacecraft: A Spacecraft or Vector{Spacecraft} to propagate\nstops...: One or more StopAt stopping conditions (varargs)\ndirection: (optional) :forward (default), :backward, or :infer - controls time integration direction\nkwargs...: Additional keyword arguments passed to the ODE solver\n\nReturns:\n\nsol: ODE solution object from DifferentialEquations.jl\n\nCommon usage patterns:\n\n# Single spacecraft, single stop\npropagate(prop, sat, stop)\n\n# Single spacecraft, multiple stops\npropagate(prop, sat, stop1, stop2, stop3)\n\n# Multiple spacecraft, multiple stops\npropagate(prop, [sat1, sat2], stop1, stop2)\n\n# With direction keyword\npropagate(prop, sat, stop; direction=:backward)\n\nSee the following sections for detailed configuration:\n\nForce Model Configuration - Setting up gravitational forces\nIntegrator Selection - Choosing integrators and tolerances\nStopping Conditions - State-based and time-based stop syntax","category":"section"},{"location":"#Propagator-Configuration","page":"AstroProp","title":"Propagator Configuration","text":"An OrbitPropagator combines a force model and integrator configuration to define how spacecraft motion is computed. This section covers the configuration of both components.\n\nBasic setup pattern:\n\n# 1. Define the gravitational forces\ngravity = PointMassGravity(central_body, (perturbers...,))\nforces = ForceModel(gravity)\n\n# 2. Configure the numerical integrator\ninteg = IntegratorConfig(algorithm; dt=step, reltol=rtol, abstol=atol)\n\n# 3. Create the propagator\nprop = OrbitPropagator(forces, integ)","category":"section"},{"location":"#Force-Model-Configuration","page":"AstroProp","title":"Force Model Configuration","text":"The force model defines the dynamics for propagation. Currently, AstroProp only supports point-mass gravity models through PointMassGravity.  \n\nBasic usage:\n\n# Earth-centered with perturbations from Moon and Sun\ngravity = PointMassGravity(earth, (moon, sun))\nforces = ForceModel(gravity)\n\nComponents:\n\nCentral body: The primary gravitational body (e.g., earth, mars, sun)\nPerturbing bodies: Tuple of additional bodies whose gravity affects the trajectory (e.g., (moon, sun))\n\nCommon configurations:\n\n# LEO - Earth only (fast, low-fidelity)\ngravity_leo = PointMassGravity(earth, ())\n\n# LEO/MEO - Earth with Moon and Sun (standard accuracy)\ngravity_standard = PointMassGravity(earth, (moon, sun))\n\n# Interplanetary - Sun-centered with planetary perturbations\ngravity_interplanetary = PointMassGravity(sun, (earth, mars, jupiter))","category":"section"},{"location":"#Integrator-Selection","page":"AstroProp","title":"Integrator Selection","text":"AstroProp leverages Julia's DifferentialEquations.jl ecosystem, providing access to a wide range of high-performance numerical integrators. The choice of integrator and its parameters affects both the accuracy and speed of your propagation.","category":"section"},{"location":"#Common-Integrators","page":"AstroProp","title":"Common Integrators","text":"Recommended integrators for orbital mechanics:\n\nTsit5(): Tsitouras 5th order adaptive method. Good default choice for most applications with moderate accuracy requirements.\nVern9(): Verner 9th order adaptive method. Higher accuracy for demanding applications like precision orbit determination.\nDP5(): Dormand-Prince 5th order method. Classic choice, similar performance to Tsit5.\nVern7(): Verner 7th order method. Balance between Vern9 accuracy and Tsit5 speed.\n\nFor a complete list of available integrators, see the DifferentialEquations.jl documentation.","category":"section"},{"location":"#Integrator-Parameters","page":"AstroProp","title":"Integrator Parameters","text":"The IntegratorConfig accepts several key parameters that control integration behavior:\n\ndt - Initial/suggested step size (seconds)\n\nSets the initial time step for adaptive integrators\nTypical values: 10-60 seconds for LEO, 60-600 seconds for GEO, 86400.0 for interplanetary\nSmaller steps increase computation time but may improve accuracy near discontinuities\n\nreltol - Relative error tolerance\n\nControls accuracy relative to the magnitude of the state\nTypical values: 1e-9 to 1e-12 for high-precision work, 1e-6 to 1e-9 for general use\nSmaller values = higher accuracy but slower computation\n\nabstol - Absolute error tolerance  \n\nControls absolute error floor (important when state components are near zero)\nTypical values: 1e-9 to 1e-12 for position/velocity\nShould generally match or be slightly smaller than reltol\n\nExample configurations:\n\n# Fast propagation (lower accuracy)\ninteg_fast = IntegratorConfig(Tsit5(); dt=60.0, reltol=1e-6, abstol=1e-6)\n\n# Standard propagation (good balance)\ninteg_standard = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\n\n# High-precision propagation\ninteg_precise = IntegratorConfig(Vern9(); dt=10.0, reltol=1e-12, abstol=1e-12)\n\ntip: Starting Point\nIf you're unsure, start with Tsit5() with dt=10.0, reltol=1e-9, and abstol=1e-9. Adjust based on your accuracy requirements and performance needs.","category":"section"},{"location":"#Stopping-Conditions","page":"AstroProp","title":"Stopping Conditions","text":"AstroProp supports two categories of stopping conditions: state-based and time-based.","category":"section"},{"location":"#State-Based-Stopping-Conditions","page":"AstroProp","title":"State-Based Stopping Conditions","text":"State-based stops trigger when a calculated quantity (position, velocity, or derived value) crosses a target value. These use calculation variables from AstroCallbacks:\n\n# Stop at periapsis (r·v = 0, velocity increasing)\nStopAt(sat, PosDotVel(), 0.0; direction=+1)\n\n# Stop at apoapsis (r·v = 0, velocity decreasing)  \nStopAt(sat, PosDotVel(), 0.0; direction=-1)\n\n# Stop when radius reaches 7000 km (any direction)\nStopAt(sat, PosMag(), 7000.0; direction=0)\n\n# Stop at ascending node (z = 0, increasing)\nStopAt(sat, PosZ(), 0.0; direction=+1)\n\nThe direction parameter specifies which zero-crossing triggers the stop:\n\n+1: Trigger when value is increasing (positive derivative)\n-1: Trigger when value is decreasing (negative derivative)  \n0: Trigger on any crossing (default)\n\nnote: Event Crossing Direction\nThe direction parameter on StopAt for state-based stops controls which side of the zero-crossing triggers the callback. This is different from the direction keyword on propagate() which controls the time integration direction.","category":"section"},{"location":"#Time-Based-Stopping-Conditions","page":"AstroProp","title":"Time-Based Stopping Conditions","text":"Time-based stops allow propagation for a specified duration or until an absolute epoch:\n\nElapsed Time Stops:\n\n# Propagate forward for 3600 seconds\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), 3600.0))\n\n# Propagate forward for 2.5 days\npropagate(prop, sat, StopAt(sat, PropDurationDays(), 2.5))\n\n# Propagate backward for 1 hour (negative duration)\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), -3600.0); direction=:infer)\n\nAbsolute Time Stops:\n\n\n# Propagate to a future epoch\nsat = Spacecraft(\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n)\ntarget = Time(\"2015-09-22T12:00:00\", UTC(), ISOT())\npropagate(prop, sat, StopAt(sat, target))\n\n# Propagate backward to a past epoch\npast = Time(\"2015-09-20T12:00:00\", UTC(), ISOT())\npropagate(prop, sat, StopAt(sat, past); direction=:infer)\n\nwarning: Time-Based Direction Parameter\nTime-based stopping conditions must use direction=0 (the default). The event crossing direction concept does not apply to time-based stops. Use the direction keyword on propagate() to control backward vs forward propagation.","category":"section"},{"location":"#Direction-Keywords","page":"AstroProp","title":"Direction Keywords","text":"The propagate() function accepts a direction keyword to control time integration:\n\n:forward (default): Integrate forward in time. This is the most common case.\n:backward: Integrate backward in time explicitly.\n:infer: Automatically infer direction from the time-based stop condition.\n\nWhen to use :infer:\n\nThe :infer keyword is particularly useful in optimization and when the propagation direction may vary:\n\n# Optimization variable (can be positive or negative)\nduration = optimize_parameter  # Could be -1000.0 or +1000.0\n\n# Using :infer allows the sign to determine direction automatically\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), duration); direction=:infer)\n\nDirection Sign Semantics:\n\nFor PropDurationSeconds and PropDurationDays, the sign of the duration encodes the propagation direction:\n\nPositive duration: Forward propagation\nNegative duration: Backward propagation\n\nThis design enables clean optimization code where the duration variable can explore both positive and negative values.\n\ntip: Optimization Compatibility\nWhen using time-based stops with optimization, use direction=:infer and let the duration sign indicate direction. This avoids the need for manual if-tests to switch between forward and backward propagation.\n\nConflict Detection:\n\nAstroProp validates that explicit directions don't contradict duration signs:\n\n# These cause errors:\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), -100.0); direction=:forward)  # Error!\npropagate(prop, sat, StopAt(sat, PropDurationDays(), 2.0); direction=:backward)      # Error!\n\n# These are valid:\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), -100.0); direction=:backward) # ✓\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), -100.0); direction=:infer)    # ✓\npropagate(prop, sat, StopAt(sat, PropDurationSeconds(), 100.0); direction=:forward)   # ✓","category":"section"},{"location":"#Time-Scale-Handling","page":"AstroProp","title":"Time Scale Handling","text":"AstroProp automatically selects the appropriate time scale for propagation based on the central body of the force model:\n\nEarth-centered propagation: Use Terrestrial Time (TT)\nAll other bodies: Use Barycentric Dynamical Time (TDB)\n\nThis ensures the correct dynamical time scale is used in the integration of the equations of motion. Time scale conversions are handled automatically:\n\nInput times (on the spacecraft or in StopAt) can be in any scale\nThe propagator converts to the appropriate scale (TT or TDB) based on the force model's central body\nThe final spacecraft time is updated in the same propagation scale\n\nnote: Force Model Central Body\nThe integration time scale is determined by the central body in your dynamics model. You can express spacecraft states in any coordinate or time system and AstroProp will still use the appropriate dynamical time scale for the integration of the equations of motion under the hood. ","category":"section"},{"location":"#Core-Functions","page":"AstroProp","title":"Core Functions","text":"","category":"section"},{"location":"#API-Reference","page":"AstroProp","title":"API Reference","text":"","category":"section"},{"location":"#Index","page":"AstroProp","title":"Index","text":"","category":"section"},{"location":"#AstroProp.OrbitPropagator","page":"AstroProp","title":"AstroProp.OrbitPropagator","text":"OrbitPropagator\n\nOrbital propagator configuration combining force models and integration settings.\n\nFields\n\nforces::ForceModel: Force model defining the orbital dynamics\ninteg::IntegratorConfig: Integration configuration (solver, tolerances, step size)\n\nExamples\n\ngravity = PointMassGravity(earth,(moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.IntegratorConfig","page":"AstroProp","title":"AstroProp.IntegratorConfig","text":"IntegratorConfig\n\nConfiguration parameters for orbital integration using DifferentialEquations.jl solvers.\n\nFields\n\nintegrator::Any: ODE solver algorithm (e.g., Vern7(), Tsit5())\ndt::Union{Nothing, Float64}: Fixed step size in seconds, or Nothing for adaptive stepping\nreltol::Float64: Relative tolerance for integration accuracy\nabstol::Float64: Absolute tolerance for integration accuracy\n\nExample\n\ninteg = IntegratorConfig(Vern7(); dt=3600.0, abstol = 1e-12, reltol=1e-12)\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.propagate","page":"AstroProp","title":"AstroProp.propagate","text":"propagate(op::OrbitPropagator, sc_or_scs, stops...; direction=:forward, kwargs...)\n\nNumerically integrate spacecraft equations of motion using propagator  until stopping conditions are met.\n\nArguments\n\nop::OrbitPropagator: Propagator configuration containing force model and integrator settings\nsc_or_scs: Single Spacecraft or Vector{Spacecraft} to propagate\nstops...: One or more StopAt stopping conditions\n\nKeyword Arguments\n\ndirection::Symbol=:forward: Time integration direction\n:forward - Integrate forward in time (default)\n:backward - Integrate backward in time\n:infer - Automatically determine from time-based stop conditions (duration sign or time comparison)\nkwargs...: Additional arguments passed to the underlying ODE solver\n\nNotes\n\nThe direction keyword controls time integration direction (which way time moves). This is different from StopAt's direction field, which controls event crossing direction for state-based stops (increasing/decreasing zero-crossing detection).\n\nReturns\n\nODESolution from DifferentialEquations.jl containing the complete trajectory solution. Access final states via sol.u[end], times via sol.t, or interpolate at any time.\n\nExamples\n\nusing Epicycle\n\n# Spacecraft\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    #name=\"SC-StopAt\",\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)\n\n# Forces + integrator\ngravity = PointMassGravity(earth, (moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate to periapsis\npropagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=+1))\n\n# Propagate backwards to node\npropagate(prop, sat, StopAt(sat, PosX(), 0.0); direction=:backward)\n\n# Propagate multiple spacecraft with multiple stopping conditions\nsc1 = Spacecraft(); sc2 = Spacecraft() \nstop_sc1_node = StopAt(sc1, PosZ(), 0.0)\nstop_sc2_periapsis = StopAt(sc2, PosDotVel(), 0.0; direction=+1)\npropagate(prop, [sc1,sc2], stop_sc1_node, stop_sc2_periapsis)\n\n\n\n\n\n\nThis interface will be deprecated in future releases.\n\npropagate(model::DynSys, config::IntegratorConfig, stop_conditions...; \n          direction=:forward, prop_stm=false, kwargs...)\n\nPropagate spacecraft orbital states using numerical integration.\n\n\n\n\n\n","category":"function"},{"location":"#AstroProp.StopAt","page":"AstroProp","title":"AstroProp.StopAt","text":"StopAt{S,V<:AbstractCalcVariable,T}\n\nGeneric stopping condition for orbital propagation based on calculated quantities or time.\n\nFields\n\nsubject::S: The object to evaluate (e.g., Spacecraft, Maneuver, CelestialBody)\nvar::V: The calculation variable to monitor (e.g., PosX(), VelMag(), PropDurationSeconds())\ntarget::T: Target value to stop at (numeric value or vector matching calc output)\ndirection::Int: Event crossing direction for state-based stops (-1: decreasing, 0: any, +1: increasing)\nFor time-based stops (PropDuration*), must be 0 (event crossing not applicable)\nFor state-based stops, controls which direction of zero-crossing triggers the event\n\nConstructor\n\nStopAt(subject, var, target; direction::Int=0)\n\nNotes\n\nThe direction field is for event crossing direction (state-based stops only). For time integration direction (forward/backward), use the direction keyword in propagate().\n\nExamples\n\n# Stop when spacecraft reaches ascending node (z-position = 0, increasing)\nsc = Spacecraft(state=CartesianState([7000.0, 0, 0, 0, 7.5, 0]))\nstop_cond = StopAt(sc, PosZ(), 0.0; direction=+1)\n\n# Stop at apoapsis (position dot velocity = 0, decreasing)  \nstop_apo = StopAt(sc, PosDotVel(), 0.0; direction=-1)\n\n# Stop after 1 hour (time-based: direction must be 0)\nstop_time = StopAt(sc, PropDurationSeconds(), 3600.0)\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.DynSys","page":"AstroProp","title":"AstroProp.DynSys","text":"DynSys(; spacecraft, forces)\n\nContainer for a dynamic system segment.\n\nKeyword Arguments\n\nspacecraft: Vector of spacecraft structs (subtypes of Spacecraft)\nforces: OrbitODE model (e.g. CartesianForceModel)\n\nFields\n\nspacecraft::Vector{<:Spacecraft}: Collection of spacecraft to propagate\nforces::OrbitODE: Force model defining the dynamics\n\nConstructor\n\nDynSys(; spacecraft, forces)\n\nExample\n\nsc = Spacecraft()\ngravity = PointMassGravity(earth, ())\nsys = DynSys(spacecraft=[sc], forces=gravity)\n\nNotes\n\nThis interface will be deprecated in future releases\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.ForceModel","page":"AstroProp","title":"AstroProp.ForceModel","text":"ForceModel{N} <: OrbitODE\n\nA collection of orbital dynamics forces and perturbations for spacecraft propagation.\n\nFields\n\nforces::NTuple{N, OrbitODE}: Tuple of force models (e.g., gravity, drag, solar radiation pressure)\ncenter::Union{CelestialBody, Nothing}: Central gravitational body, determined automatically from forces\n\nConstructor\n\nForceModel(forces...)\nForceModel(force_tuple)\n\nThe central body is automatically determined from the primary gravitational force in the model.\n\nExample\n\ngravity = PointMassGravity(earth, ())\nmodel = ForceModel(gravity)\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.ForceModel-Union{Tuple{Tuple{Vararg{T}}}, Tuple{T}} where T<:OrbitODE","page":"AstroProp","title":"AstroProp.ForceModel","text":"ForceModel(forces...)\nForceModel(force_tuple)\n\nCreate a force model for orbital propagation from one or more force components.\n\nArguments\n\nforces...: Variable number of force objects (e.g., PointMassGravity)\nforce_tuple: Tuple of force objects\n\nReturns\n\nForceModel{N}: Force model with N force components\n\nThe central gravitational body is automatically determined from the primary  gravitational force in the collection.\n\nExamples\n\ngravity = PointMassGravity(earth)\nmodel = ForceModel(gravity)\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.IntegratorTimeCalc","page":"AstroProp","title":"AstroProp.IntegratorTimeCalc","text":"IntegratorTimeCalc <: AbstractCalcVariable\n\nBase type for stopping conditions based on integrator time rather than spacecraft state. These are specific to propagation contexts and cannot be used as general calculation variables.\n\nSubtypes\n\nPropDurationSeconds: Stop after a specified number of seconds\nPropDurationDays: Stop after a specified number of days\n\nNotes\n\nThese types are handled specially in propagate() by setting the integration time span directly rather than using callbacks. They derive from AbstractCalcVariable for type safety in StopAt but do not have corresponding make_calc() implementations.\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.PointMassGravity","page":"AstroProp","title":"AstroProp.PointMassGravity","text":"PointMassGravity\n\nCombined force model for central body gravity and N-body point-mass perturbations.\n\nFields\n\ncentral_body::CelestialBody: The central body about which dynamics are referenced.\nperturbers::Tuple{Vararg{CelestialBody}}: Other celestial bodies treated as point-mass perturbers.\ndependencies::Vector{Type{<:AbstractVar}}: Vector of variable dependencies (e.g., PosVel)\nnum_funs::Int: Number of functions in the ODE\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.PosVel","page":"AstroProp","title":"AstroProp.PosVel","text":"PosVel <: AbstractState\n\nPosition-velocity state representation for orbital propagation. This is a legacy  state type used internally by the propagation system.\n\nFields\n\nnumvars::Int: Number of state variables (always 6 for position and velocity)\n\nNotes\n\nThis struct is marked for deprecation and should be replaced with new state  representations from AstroStates.\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.PropDurationDays","page":"AstroProp","title":"AstroProp.PropDurationDays","text":"PropDurationDays <: IntegratorTimeCalc\n\nStopping condition based on elapsed time in days.\n\nUsage\n\n# Stop after 2.5 days\nStopAt(sc, PropDurationDays(), 2.5)\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.PropDurationSeconds","page":"AstroProp","title":"AstroProp.PropDurationSeconds","text":"PropDurationSeconds <: IntegratorTimeCalc\n\nStopping condition based on elapsed time in seconds.\n\nUsage\n\n# Stop after 1 hour (3600 seconds)\nStopAt(sc, PropDurationSeconds(), 3600.0)\n\n\n\n\n\n","category":"type"},{"location":"#AstroProp.StopAt-Tuple{Spacecraft, Time}","page":"AstroProp","title":"AstroProp.StopAt","text":"StopAt(subject::Spacecraft, target_time::Time; direction::Int=0)\n\nConvenience constructor to stop at an absolute time by converting to elapsed seconds. Supports both forward propagation (target after current) and backward propagation (target before current).\n\nArguments\n\nsubject::Spacecraft: The spacecraft being propagated\ntarget_time::Time: The absolute time to stop at (can be past or future)\ndirection::Int=0: Event crossing direction (must be 0 for time-based stops)\n\nNotes\n\nThis direction parameter is for event crossing (not applicable to time stops, always use 0). For time integration direction (forward/backward in time), use the direction keyword in propagate() with values :forward, :backward, or :infer.\n\nExample\n\nusing AstroEpochs\n\n# Forward to future time (default direction=:forward in propagate works)\nstop_future = StopAt(sc, Time(\"2025-12-26T12:00:00\", UTC(), ISOT()))\npropagate(prop, sc, stop_future)  # Uses default direction=:forward\n\n# Backward to past time (use direction=:infer in propagate to auto-detect)\nstop_past = StopAt(sc, Time(\"2025-12-24T12:00:00\", UTC(), ISOT()))\npropagate(prop, sc, stop_past; direction=:infer)  # Infers :backward from negative elapsed time\n# OR explicitly:\npropagate(prop, sc, stop_past; direction=:backward)\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.StopAtApoapsis-Tuple{Spacecraft}","page":"AstroProp","title":"AstroProp.StopAtApoapsis","text":"StopAtApo(sc::Spacecraft)\n\nConstructs a ContinuousCallback for stopping at apoapsis of sc.     This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.StopAtAscendingNode-Tuple{Spacecraft}","page":"AstroProp","title":"AstroProp.StopAtAscendingNode","text":"StopAtAscendingNode(sc::Spacecraft)\n\nConstructs a ContinuousCallback for stopping at ascending node of sc. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.StopAtDays-Tuple{Float64}","page":"AstroProp","title":"AstroProp.StopAtDays","text":"StopAtDays(days::Float64)\n\nReturns a DiscreteCallback that stops the integrator after days of simulation time. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.StopAtPeriapsis-Tuple{Spacecraft}","page":"AstroProp","title":"AstroProp.StopAtPeriapsis","text":"StopAtPeriapsis(sc::Spacecraft)\n\nConstructs a ContinuousCallback for stopping at periapsis of sc. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.StopAtRadius-Tuple{Spacecraft, Float64}","page":"AstroProp","title":"AstroProp.StopAtRadius","text":"StopAtRadius(sc::Spacecraft, target_radius::Float64)\n\nReturns a ContinuousCallback that triggers when norm(pos) - target_radius = 0. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.StopAtSeconds-Tuple{Float64}","page":"AstroProp","title":"AstroProp.StopAtSeconds","text":"StopAtSeconds(seconds::Float64)\n\nReturns a DiscreteCallback that stops the integrator at t = seconds. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp._build_callback-Tuple{StopAt, Any}","page":"AstroProp","title":"AstroProp._build_callback","text":"_build_callback(cond::StopAt, dynsys)\n\nBuild a DifferentialEquations.jl ContinuousCallback for a StopAt condition.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp._posvel_from_u-Tuple{Any, Any, Spacecraft}","page":"AstroProp","title":"AstroProp._posvel_from_u","text":"function posvelfrom_u(u, dynsys, sc::Spacecraft)\n\nExtract a 6x1 Cartesian pos/vel slice for a spacecraft from integrator state u\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp._sc_index-Tuple{Any, Spacecraft}","page":"AstroProp","title":"AstroProp._sc_index","text":"scindex(dynsys, sc::Spacecraft)\n\nFind spacecraft index in a DynSys\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp._subject_update_from_u!-Tuple{Any, Any, Any}","page":"AstroProp","title":"AstroProp._subject_update_from_u!","text":"subjectupdatefromu!(subject, dynsys, u)\n\nUpdate a subject from the integrator state u (specialize per subject type)\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp._subject_update_from_u!-Tuple{Spacecraft, Any, Any}","page":"AstroProp","title":"AstroProp._subject_update_from_u!","text":"subjectupdatefromu!(sc::Spacecraft, dynsys, u)\n\nMap Cartesian state slice to spacecraft struct state\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.accel_eval!-Tuple{PointMassGravity, Time, Vector, Vector, Spacecraft, Any}","page":"AstroProp","title":"AstroProp.accel_eval!","text":"accel_eval!(model::PointMassGravity, t::Time, x̄::Vector, \n             x̄̇::Vector, sc::Spacecraft, params; jac::Dict = Dict())\n\nEvaluate the acceleration due to point-mass gravity from central and perturbing bodies.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.apsis_condition-Tuple{Spacecraft}","page":"AstroProp","title":"AstroProp.apsis_condition","text":"apoapsis_condition(sc::Spacecraft)\n\nReturns a closure that evaluates the apoapsis condition r ⋅ v = 0  using the spacecraft's registered :posvel index in the ODE registry. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.ascnode_condition-Tuple{Spacecraft}","page":"AstroProp","title":"AstroProp.ascnode_condition","text":"ascnode_condition(sc::Spacecraft)\n\nReturns a closure that evaluates the ascending node condition z = 0 using the spacecraft's registered :posvel index in the ODE registry. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.check_duplicates-Tuple{Tuple{Vararg{CelestialBody}}}","page":"AstroProp","title":"AstroProp.check_duplicates","text":"function check_duplicates(bodies::Tuple{Vararg{CelestialBody}})\n\nValidate that all names in force model are unique\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.compute_point_mass_gravity!-Union{Tuple{T}, Tuple{Time, AbstractVector{T}, AbstractVector{T}, CelestialBody, Tuple{Vararg{CelestialBody}}}} where T","page":"AstroProp","title":"AstroProp.compute_point_mass_gravity!","text":"nbody_perts(t::Time, center::CelestialBody, pert_bodies::Tuple{Vararg{CelestialBody}}; jac::Bool=false)\n\nCompute the gravitational acceleration on a central body due to a tuple of perturbing bodies using Newtonian point-mass gravity.\n\nArguments\n\nt::Time: State epoch\nposvel::Vector  Orbit state (position and velocity) \ncenter::CelestialBody: The central body of propagation\npert_bodies::Tuple{Vararg{CelestialBody}}: Tuple of perturbing celestial bodies (e.g., Moon, Sun)\njac::Bool: Optional keyword (default = false) to return the Jacobian of the perturbing acceleration with respect to the central body's position\ntol::Real: Optional tolerance on singularity testing (default 1e-12)\n\nReturns\n\nIf jac == false: a_pert::Vector{Float64} — total perturbing acceleration\nIf jac == true: (a_pert::Vector{Float64}, jacobian::Matrix{Float64})\n\nNotes\n\nRequires AstroUniverse.translate(from::CelestialBody, to::CelestialBody, jd_tdb::Float64) to return the vector from from to to in inertial coordinates.\nUnits must be consistent with the gravitational parameters (mu) of the celestial bodies.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.make_calc-Tuple{Any, Any}","page":"AstroProp","title":"AstroProp.make_calc","text":"make_calc(subject, var)\n\nCreate a calculation object from a subject and variable for use in stopping conditions.\n\nArguments\n\nsubject: The object to evaluate (e.g., Spacecraft, Maneuver, CelestialBody)\nvar: The calculation variable (must be <: AbstractOrbitVar)\n\nReturns\n\nA calculation object that can be used with get_calc() to evaluate the variable on the subject.\n\nExtensibility\n\nThis is an extensibility point for the stopping condition framework. Users and packages should extend this function for new subject/variable combinations:\n\n# Example extension for a custom subject type\nmake_calc(my_object::MyType, v::AbstractOrbitVar) = CustomCalc(my_object, v)\n\nExamples\n\n# Built-in case: spacecraft orbital variables\ncalc = make_calc(spacecraft, PosX())\ncurrent_x = get_calc(calc)\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.propagate-Tuple{DynSys, IntegratorConfig, Vararg{Any}}","page":"AstroProp","title":"AstroProp.propagate","text":"This interface will be deprecated in future releases.\n\npropagate(model::DynSys, config::IntegratorConfig, stop_conditions...; \n          direction=:forward, prop_stm=false, kwargs...)\n\nPropagate spacecraft orbital states using numerical integration.\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.propagate-Tuple{OrbitPropagator, Any, Vararg{Any}}","page":"AstroProp","title":"AstroProp.propagate","text":"propagate(op::OrbitPropagator, sc_or_scs, stops...; direction=:forward, kwargs...)\n\nNumerically integrate spacecraft equations of motion using propagator  until stopping conditions are met.\n\nArguments\n\nop::OrbitPropagator: Propagator configuration containing force model and integrator settings\nsc_or_scs: Single Spacecraft or Vector{Spacecraft} to propagate\nstops...: One or more StopAt stopping conditions\n\nKeyword Arguments\n\ndirection::Symbol=:forward: Time integration direction\n:forward - Integrate forward in time (default)\n:backward - Integrate backward in time\n:infer - Automatically determine from time-based stop conditions (duration sign or time comparison)\nkwargs...: Additional arguments passed to the underlying ODE solver\n\nNotes\n\nThe direction keyword controls time integration direction (which way time moves). This is different from StopAt's direction field, which controls event crossing direction for state-based stops (increasing/decreasing zero-crossing detection).\n\nReturns\n\nODESolution from DifferentialEquations.jl containing the complete trajectory solution. Access final states via sol.u[end], times via sol.t, or interpolate at any time.\n\nExamples\n\nusing Epicycle\n\n# Spacecraft\nsat = Spacecraft(\n    state=CartesianState([7000.0, 300.0, 0.0, 0.0, 7.5, 0.03]),\n    time=Time(\"2015-09-21T12:23:12\", TAI(), ISOT()),\n    #name=\"SC-StopAt\",\n    coord_sys=CoordinateSystem(earth, ICRFAxes()),\n)\n\n# Forces + integrator\ngravity = PointMassGravity(earth, (moon,sun))\nforces  = ForceModel(gravity)\ninteg   = IntegratorConfig(Tsit5(); dt=10.0, reltol=1e-9, abstol=1e-9)\nprop    = OrbitPropagator(forces, integ)\n\n# Propagate to periapsis\npropagate(prop, sat, StopAt(sat, PosDotVel(), 0.0; direction=+1))\n\n# Propagate backwards to node\npropagate(prop, sat, StopAt(sat, PosX(), 0.0); direction=:backward)\n\n# Propagate multiple spacecraft with multiple stopping conditions\nsc1 = Spacecraft(); sc2 = Spacecraft() \nstop_sc1_node = StopAt(sc1, PosZ(), 0.0)\nstop_sc2_periapsis = StopAt(sc2, PosDotVel(), 0.0; direction=+1)\npropagate(prop, [sc1,sc2], stop_sc1_node, stop_sc2_periapsis)\n\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.rebind-Tuple{StopAt, Dict{Any, Any}}","page":"AstroProp","title":"AstroProp.rebind","text":"rebind(stop_condition::StopAt, owner_map::Dict{Any,Any})\n\nCreate a new StopAt condition with updated subject references based on an owner mapping.\n\nArguments\n\nstop_condition::StopAt: The original stopping condition\nowner_map::Dict{Any,Any}: Mapping from old subjects to new subjects\n\nReturns\n\nA new StopAt with the subject updated according to the mapping, while preserving the variable, target, and direction unchanged.\n\nUsage\n\nThis function is used internally when transferring stopping conditions between different propagation contexts where the subject objects may need to be remapped.\n\nExample\n\nold_stop = StopAt(old_spacecraft, PosX(), 7000.0)\nowner_map = Dict(old_spacecraft => new_spacecraft)\nnew_stop = rebind(old_stop, owner_map)\n# new_stop.subject == new_spacecraft, other fields unchanged\n\n\n\n\n\n","category":"method"},{"location":"#AstroProp.stop_affect!-Tuple{Any}","page":"AstroProp","title":"AstroProp.stop_affect!","text":"stop_affect!(integrator)\n\nCallback effect to stop the integration. This interface is replaced by AstroCallbacks Calcs and will be deprecated in future releases.\n\n\n\n\n\n","category":"method"}]
}
